"""
Скрипт для обработки результатов теста Выявление буллинг структуры Норкина
"""

import pandas as pd
from tkinter import messagebox
from lachesis_support_functions import round_mean,sort_name_class

class BadOrderVBS(Exception):
    """
    Исключение для обработки случая когда колонки не совпадают
    """
    pass


class BadValueVBS(Exception):
    """
    Исключение для неправильных значений в вариантах ответов
    """
    pass

class BadCountColumnsVBS(Exception):
    """
    Исключение для обработки случая если количество колонок не равно 25
    """
    pass


def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]






def processing_result_vbs(row):
    """
    Обработка результатов тестирования
    """

    # Создаем словарь для хранения данных
    dct_type = {'инициатор': 0, 'помощник': 0, 'защитник': 0,
                'жертва': 0,
                'наблюдатель': 0
                }

    # 1
    if row[0] == 'да, я дружу со всеми':
        dct_type['инициатор'] += 1
        dct_type['защитник'] += 1
    elif row[0] == 'у меня есть пару друзей':
        dct_type['помощник'] += 1
        dct_type['жертва'] += 1
    elif row[0] == 'нет, я ни с кем не дружу':
        pass
    elif row[0] == 'мне бы хотелось дружить со всеми':
        dct_type['наблюдатель'] += 1

    # 2
    if row[1] == 'да, если человек мне не симпатичен, я не буду с ним общаться':
        dct_type['помощник'] += 1
    elif row[1] == 'нет, главное, чтобы человек был интересен':
        dct_type['защитник'] += 1
        dct_type['наблюдатель'] += 1
    elif row[1] == 'я сам страдаю из-за своей внешности':
        dct_type['жертва'] += 1
    elif row[1] == 'конечно, если человек не обладает хорошей внешностью, он не заслуживает ничего хорошего':
        dct_type['инициатор'] += 1

    # 3
    if row[2] == 'да, один или два':
        dct_type['жертва'] += 1
    elif row[2] == 'нет, мне приятны все':
        dct_type['защитник'] += 1
    elif row[2] == 'мне все не нравятся':
        dct_type['наблюдатель'] += 1
    elif row[2] == 'да, но они не приятны всем в классе':
        dct_type['инициатор'] += 1
        dct_type['помощник'] += 1

    # 4
    if row[3] == 'да, во всем':
        pass
    elif row[3] == 'иногда':
        dct_type['жертва'] += 1
    elif row[3] == 'нет, на меня все равняются':
        dct_type['инициатор'] += 1
        dct_type['защитник'] += 1
        dct_type['наблюдатель'] += 1
    elif row[3] == 'нет, я не чувствую себя хуже других':
        dct_type['помощник'] += 1

    # 5
    if row[4] == 'буду общаться с ним так же, как всегда,':
        dct_type['защитник'] += 1
        dct_type['жертва'] += 1
    elif row[4] == 'буду смеяться над ним':
        dct_type['помощник'] += 1
    elif row[4] == 'перестану с ним общаться':
        dct_type['инициатор'] += 1
    elif row[4] == 'буду общаться только тогда, когда не видят другие ребята':
        dct_type['наблюдатель'] += 1

    # 6
    if row[5] == 'да мы очень дружны':
        dct_type['инициатор'] += 1
    elif row[5] == 'нет, мы почти не общаемся':
        dct_type['помощник'] += 1
    elif row[5] == 'в основном да, если не считать некоторых':
        pass
    elif row[5] == 'у нас есть ребята, которые всех «задирают»':
        dct_type['защитник'] += 1
        dct_type['жертва'] += 1
        dct_type['наблюдатель'] += 1

    # 7
    if row[6] == 'да':
        dct_type['жертва'] += 1
    elif row[6] == 'нет':
        dct_type['защитник'] += 1
        dct_type['инициатор'] += 1
    elif row[6] == 'иногда':
        dct_type['помощник'] += 1
        dct_type['наблюдатель'] += 1
    elif row[6] == 'часто':
        pass

    # 8
    if row[7] == 'облегчение, хорошо, что меня это не касается':
        dct_type['наблюдатель'] += 1
    elif row[7] == 'несправедливость и заступаюсь за одноклассника':
        dct_type['защитник'] += 1
    elif row[7] == 'ничего не чувствую, наверняка он это заслужил':
        dct_type['помощник'] += 1
    elif row[7] == 'мне нет до этого никакого дела':
        dct_type['инициатор'] += 1
        dct_type['жертва'] += 1

    # 9
    if row[8] == 'да, но это бывает редко':
        dct_type['защитник'] += 1
    elif row[8] == 'мы и так постоянно проводим свободное время вместе':
        dct_type['инициатор'] += 1
    elif row[8] == 'нет, мне с ними не интересно':
        dct_type['помощник'] += 1
        dct_type['жертва'] += 1
    elif row[8] == 'нет, потому что некоторые ребята все портят':
        dct_type['наблюдатель'] += 1

    # 10
    if row[9] == 'да это так и мне это неприятно':
        dct_type['наблюдатель'] += 1
    elif row[9] == 'нет, со мной все дружат':
        dct_type['защитник'] += 1
        dct_type['инициатор'] += 1
    elif row[9] == 'да, но меня это устраивает':
        dct_type['жертва'] += 1
    elif row[9] == 'это я не хочу с ними общаться':
        dct_type['помощник'] += 1





def processing_vbs(base_df: pd.DataFrame, answers_df: pd.DataFrame):
    """
    Функция для обработки
    :param base_df: часть датафрейма с описательными колонками
    :param answers_df: часть датафрейма с ответами
    """
    out_answer_df = base_df.copy()  # делаем копию для последующего соединения с сырыми ответами
    if len(answers_df.columns) != 25:  # проверяем количество колонок с вопросами
        raise BadCountColumnsVBS

    lst_check_cols = ['Среди одноклассников у меня много друзей',
                      'Для меня важна внешность окружающих',
                      'В моем классе есть ребята, которые мне не приятны',
                      'Мне кажется, что мои одноклассники лучше меня',
                      'Если мой одноклассник пришел в очках',
                      'У меня очень дружный класс',
                      'Я часто испытываю чувство одиночества и тревоги',
                      'Если при мне обижают одноклассника, я чувствую',
                      'Я бы хотел проводить больше времени с одноклассниками',
                      'Мне кажется, что мои одноклассники не хотят со мной общаться',
                      'У нас в классе есть пару ребят, на которых все равняются',
                      'Когда меня ругают, я испытываю чувство гнева',
                      'В нашем классе есть несколько ребят, которых все боятся',
                      'Мне бы хотелось учиться в другом классе или школе',
                      'Мне кажется, что с помощью силы можно решить любую проблему',
                      'В моем классе есть один (несколько) человек, с которыми никто не дружит',
                      'Мне кажется, что в нашем классе часто происходят акты насилия (обзывания, насмешки, обидные жесты или действия)',
                      'Если я увижу драку между одноклассниками, то я',
                      'Мне кажется, что в коллективе меня недооценивают',
                      'По-моему, педагоги в школе унижают и оскорбляют учащихся',
                      'Если бы мой класс был на корабле, я бы стал',
                      'Если у человека изъяны во внешности (бородавки, косоглазие, ожирение и др.)',
                      'Если при мне кто-то подвергается насмешкам',
                      'Я часто огорчаюсь, когда не пользуюсь успехом в классе',
                      'Я нуждаюсь в поддержке одноклассников',
                      ]

    # Проверяем порядок колонок
    order_main_columns = lst_check_cols  # порядок колонок и названий как должно быть
    order_temp_df_columns = list(answers_df.columns)  # порядок колонок проверяемого файла
    error_order_lst = []  # список для несовпадающих пар
    # Сравниваем попарно колонки
    for main, temp in zip(order_main_columns, order_temp_df_columns):
        if main != temp:
            error_order_lst.append(f'На месте колонки {main} находится колонка {temp}')
            error_order_message = ';'.join(error_order_lst)
    if len(error_order_lst) != 0:
        raise BadOrderVBS

    valid_values = [['да, я дружу со всеми','у меня есть пару друзей','нет, я ни с кем не дружу','мне бы хотелось дружить со всеми'],
                    ['да, если человек мне не симпатичен, я не буду с ним общаться','нет, главное, чтобы человек был интересен','я сам страдаю из-за своей внешности','конечно, если человек не обладает хорошей внешностью, он не заслуживает ничего хорошего'],
                    ['да, один или два','нет, мне приятны все','мне все не нравятся','да, но они не приятны всем в классе'],
                    ['да, во всем','иногда','нет, на меня все равняются','нет, я не чувствую себя хуже других'],
                    ['буду общаться с ним так же, как всегда,','буду смеяться над ним','перестану с ним общаться','буду общаться только тогда, когда не видят другие ребята'],
                    ['да мы очень дружны','нет, мы почти не общаемся','в основном да, если не считать некоторых','у нас есть ребята, которые всех «задирают»'],
                    ['да','нет','иногда','часто'],
                    ['облегчение, хорошо, что меня это не касается','несправедливость и заступаюсь за одноклассника','ничего не чувствую, наверняка он это заслужил','мне нет до этого никакого дела'],
                    ['да, но это бывает редко','мы и так постоянно проводим свободное время вместе','нет, мне с ними не интересно','нет, потому что некоторые ребята все портят'],
                    ['да это так и мне это неприятно','нет, со мной все дружат','да, но меня это устраивает','это я не хочу с ними общаться'],
                    ['да, я думаю, что я один из них','да, но они этого не заслуживают','нет, у нас таких нет','да, я тоже на них равняюсь'],
                    ['да','нет','иногда','часто'],
                    ['да, они всех унижают, а иногда и бьют','нет, у нас таких нет','я и сам из их числа — меня все боятся','конечно, так и должно быть, это нормально'],
                    ['да, мне не нравится наш коллектив','нет, меня все устраивает','иногда, после ссоры с одноклассниками','нет, а вдруг там будет хуже'],
                    ['да это самый действенный способ','нет, лучше решать «мирным» путем','иногда без этого не обойтись','все зависит от обстоятельств и от людей'],
                    ['да и мне их жаль','нет, мы все дружим','да, но они этого заслуживают','я сам из их числа'],
                    ['да, постоянно ссоры и драки','нет, у нас такого не бывает','почти нет, если не считать пару случаев','конечно, так и должно быть'],
                    ['пройду мимо это меня не касается','обязательно остановлюсь и посмотрю','сниму это все на телефон, и после размещу в интернете, пусть все увидят','попытаюсь остановить драку и выяснить в чем дело'],
                    ['да','нет','иногда','часто'],
                    ['да','нет','иногда','часто'],
                    ['капитаном','помощником капитана','обычным матросом','юнгой'],
                    ['это повод для насмешек','я с таким не буду общаться','меня это не беспокоит, буду общаться','не буду общаться, чтобы не уронить свою репутацию'],
                    ['я буду поступать так же, как все','встану на его защиту','один из первых стану смеяться над ним','ничего делать не буду, меня это не касается'],
                    ['да, для меня это очень важно','нет, мне все равно','я всегда пользуюсь успехом','нет, я никогда не был успешен в классе'],
                    ['да','нет','иногда','часто']
                    ]

    lst_error_answers = []  # список для хранения строк где найдены неправильные ответы

    for idx, lst_values in enumerate(valid_values):
        mask = ~answers_df.iloc[:, idx].isin(lst_values)  # проверяем на допустимые значения
        # Получаем строки с отличающимися значениями
        result_check = answers_df.iloc[:, idx][mask]

        if len(result_check) != 0:
            error_row = list(map(lambda x: x + 2, result_check.index))
            error_row = list(map(str, error_row))
            error_row_lst = [f'В {idx + 1} вопросной колонке на строке {value}' for value in error_row]
            error_in_column = ','.join(error_row_lst)
            lst_error_answers.append(error_in_column)

    if len(lst_error_answers) != 0:
        error_message = ';'.join(lst_error_answers)
        raise BadValueVBS

    base_df[f'Необработанное'] = answers_df.apply(processing_result_vbs, axis=1)
    base_df[f'Роль'] = base_df[f'Необработанное'].apply(
        extract_key_max_value)
    base_df[f'Числовой_показатель_роли'] = base_df[f'Необработанное'].apply(
        extract_max_value)









