"""
Скрипт для обработки результатов теста Сфера профессиональных предпочтений
"""
import pandas as pd
from tkinter import messagebox
from lachesis_support_functions import round_mean,sort_name_class

class BadOrderSPP(Exception):
    """
    Исключение для обработки случая когда колонки не совпадают
    """
    pass


class BadValueSPP(Exception):
    """
    Исключение для неправильных значений в вариантах ответов
    """
    pass


class BadCountColumnsSPP(Exception):
    """
    Исключение для обработки случая если количество колонок не равно 24
    """
    pass


def calc_level_spp(value):
    """
    Функция для подсчета уровня склонности к то или иной сфере
    """
    if 0 <= value <= 3:
        return 'профессиональная склонность не выражена'
    elif 4 <= value <= 6:
        return 'слабо выраженная профессиональная склонность'
    elif 7 <= value <= 9:
        return 'средне выраженная профессиональная склонность'
    elif 10 <= value <= 12:
        return 'ярко выраженная профессиональная склонность'

def calc_mean(df:pd.DataFrame,type_calc:str,lst_cat:list,val_cat):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Группа или Курс
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :return:датафрейм
    """
    if type_calc == 'Группа':
        calc_mean_df = pd.pivot_table(df, index=lst_cat,
                                           values=[val_cat],
                                           aggfunc=round_mean)
        calc_mean_df.reset_index(inplace=True)
        calc_mean_df.rename(columns={val_cat: 'Среднее значение'}, inplace=True)

        return calc_mean_df
    else:
        calc_mean_df = pd.pivot_table(df, index=lst_cat,
                                           values=val_cat,
                                           aggfunc=round_mean)
        calc_mean_df.reset_index(inplace=True)
        calc_mean_df.rename(columns={val_cat:'Среднее значение'},inplace=True)
        return calc_mean_df



def calc_count_sphere_spp(df:pd.DataFrame, type_calc:str, lst_cat:list, val_cat, col_cat):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Группа или Курс
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :param col_cat: колонка по которой будет формироваться свод
    :return:датафрейм
    """
    if type_calc == 'Группа':
        count_df = pd.pivot_table(df, index=lst_cat,
                                                 columns=col_cat,
                                                 values=val_cat,
                                                 aggfunc='count', margins=True, margins_name='Итого')

        lst_sphere = count_df.columns[:-1]
        count_df.reset_index(inplace=True)

        for sphere in lst_sphere:
            count_df[f'% {sphere} от общего'] = round(
            count_df[f'{sphere}'] / count_df['Итого'], 2) * 100


        return count_df
    else:
        count_df = pd.pivot_table(df, index=lst_cat,
                                  columns=col_cat,
                                  values=val_cat,
                                  aggfunc='count', margins=True, margins_name='Итого')

        lst_sphere = count_df.columns[:-1]
        count_df.reset_index(inplace=True)

        for sphere in lst_sphere:
            count_df[f'% {sphere} от общего'] = round(
            count_df[f'{sphere}'] / count_df['Итого'], 2) * 100

        return count_df



def calc_count_level_spp(df:pd.DataFrame, type_calc:str, lst_cat:list, val_cat, col_cat, lst_cols:list):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Группа или Курс
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :param col_cat: колонка по которой будет формироваться свод
    :param lst_cols: список с колонками
    :return:датафрейм
    """
    if type_calc == 'Группа':
        count_df = pd.pivot_table(df, index=lst_cat,
                                                 columns=col_cat,
                                                 values=val_cat,
                                                 aggfunc='count', margins=True, margins_name='Итого')


        count_df.reset_index(inplace=True)
        count_df = count_df.reindex(columns=lst_cols)
        count_df['% профессиональная склонность не выражена от общего'] = round(
            count_df['профессиональная склонность не выражена'] / count_df['Итого'], 2) * 100
        count_df['% слабо выраженная профессиональная склонность от общего'] = round(
            count_df['слабо выраженная профессиональная склонность'] / count_df['Итого'], 2) * 100
        count_df['% средне выраженная профессиональная склонность от общего'] = round(
            count_df['средне выраженная профессиональная склонность'] / count_df['Итого'], 2) * 100
        count_df['% ярко выраженная профессиональная склонность от общего'] = round(
            count_df['ярко выраженная профессиональная склонность'] / count_df['Итого'], 2) * 100


        return count_df
    else:
        count_df = pd.pivot_table(df, index=lst_cat,
                                  columns=col_cat,
                                  values=val_cat,
                                  aggfunc='count', margins=True, margins_name='Итого')

        count_df.reset_index(inplace=True)
        count_df = count_df.reindex(columns=lst_cols)
        count_df['% профессиональная склонность не выражена от общего'] = round(
            count_df['профессиональная склонность не выражена'] / count_df['Итого'], 2) * 100
        count_df['% слабо выраженная профессиональная склонность от общего'] = round(
            count_df['слабо выраженная профессиональная склонность'] / count_df['Итого'], 2) * 100
        count_df['% средне выраженная профессиональная склонность от общего'] = round(
            count_df['средне выраженная профессиональная склонность'] / count_df['Итого'], 2) * 100
        count_df['% ярко выраженная профессиональная склонность от общего'] = round(
            count_df['ярко выраженная профессиональная склонность'] / count_df['Итого'], 2) * 100

        return count_df








def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]


def processing_result_spp(row):
    """
    Обработка результатов тестирования
    """

    # Создаем словарь для хранения данных
    dct_type = {'сфера работы с людьми': 0, 'сфера умственного труда': 0, 'сфера технических интересов': 0,
                'сфера эстетики и искусства': 0,
                'сфера физического труда, подвижной деятельности': 0,
                'сфера материальных интересов, планово-экономических видов работ': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении

    # 1
    if row[0] == 'общаться с самыми разными людьми':
        dct_type['сфера работы с людьми'] += 1
    elif row[0] == 'что-нибудь делать своими руками – мебель, одежду, машины и т.д.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[0] == 'снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[общаться с самыми разными людьми], [что-нибудь делать своими руками – мебель, одежду, машины и т.д.], [снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.]'

    # 2
    if row[1] == 'художественная форма, мастерство писателя или режиссера':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[1] == 'сюжет, действие героев':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[1] == 'информация, которая может пригодиться в жизни':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[художественная форма, мастерство писателя или режиссера], [сюжет, действие героев], [информация, которая может пригодиться в жизни]'

    # 3
    if row[2] == 'в области науки':
        dct_type['сфера умственного труда'] += 1
    elif row[2] == 'за общественную деятельность':
        dct_type['сфера работы с людьми'] += 1
    elif row[2] == 'в области искусства':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[в области науки], [за общественную деятельность], [в области искусства]'

    # 4
    if row[3] == 'управляющим банка':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[3] == 'главным инженером на производстве':
        dct_type['сфера технических интересов'] += 1
    elif row[3] == 'начальником экспедиции':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[управляющим банка], [главным инженером на производстве], [начальником экспедиции]'

    # 5
    if row[4] == 'достижения науки':
        dct_type['сфера умственного труда'] += 1
    elif row[4] == 'развитие производства':
        dct_type['сфера технических интересов'] += 1
    elif row[4] == 'взаимопонимание среди людей':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[достижения науки], [развитие производства], [взаимопонимание среди людей]'

    # 6
    if row[5] == 'благоустройством школы (столовая, спортзал, компьютеры)':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[5] == 'созданием дружного, сплоченного коллектива':
        dct_type['сфера работы с людьми'] += 1
    elif row[5] == 'разработкой новых технологий обучения':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[благоустройством школы (столовая, спортзал, компьютеры)], [созданием дружного, сплоченного коллектива], [разработкой новых технологий обучения]'

    # 7
    if row[6] == 'внешний вид экспонатов (цвет, форма)':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[6] == 'внутреннее устройство экспонатов (механизм)':
        dct_type['сфера умственного труда'] += 1
    elif row[6] == 'практическое применение экспонатов':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[внешний вид экспонатов (цвет, форма)], [внутреннее устройство экспонатов (механизм)], [практическое применение экспонатов]'

    # 8
    if row[7] == 'мужество, смелость, выносливость':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[7] == 'дружелюбие, чуткость, отзывчивость':
        dct_type['сфера работы с людьми'] += 1
    elif row[7] == 'ответственность, аккуратность':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[мужество, смелость, выносливость], [дружелюбие, чуткость, отзывчивость], [ответственность, аккуратность]'

    # 9
    if row[8] == 'писать стихи или музыку или рисовать':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[8] == 'ставить различные опыты':
        dct_type['сфера умственного труда'] += 1
    elif row[8] == 'тренироваться':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[писать стихи или музыку или рисовать], [ставить различные опыты], [тренироваться]'

    # 10
    if row[9] == 'экстремальный туризм (альпинизм, виндсерфинг, горные лыжи)':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[9] == 'деловое общение':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[9] == 'возможность знакомства с историей и культурой другой страны':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[экстремальный туризм (альпинизм, виндсерфинг, горные лыжи)], [деловое общение], [возможность знакомства с историей и культурой другой страны]'

    # 11
    if row[10] == 'о машине нового типа':
        dct_type['сфера технических интересов'] += 1
    elif row[10] == 'о новой научной теории':
        dct_type['сфера умственного труда'] += 1
    elif row[10] == 'о человеческих взаимоотношениях':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[о машине нового типа], [о новой научной теории], [о человеческих взаимоотношениях]'

    # 12
    if row[11] == 'технический':
        dct_type['сфера технических интересов'] += 1
    elif row[11] == 'музыкальный':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[11] == 'спортивный':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[технический], [музыкальный], [спортивный]'

    # 13
    if row[12] == 'улучшению взаимопонимания между учителями и учениками':
        dct_type['сфера работы с людьми'] += 1
    elif row[12] == 'поддержанию здоровья учащихся, занятиям спортом':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[12] == 'укреплению дисциплины':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[улучшению взаимопонимания между учителями и учениками], [поддержанию здоровья учащихся, занятиям спортом], [укреплению дисциплины]'

    # 14
    if row[13] == 'научно-популярные фильмы':
        dct_type['сфера умственного труда'] += 1
    elif row[13] == 'программы о культуре и спорте':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[13] == 'спортивные программы':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[научно-популярные фильмы], [программы о культуре и спорте], [спортивные программы]'

    # 15
    if row[14] == 'с машинами, механизмами':
        dct_type['сфера технических интересов'] += 1
    elif row[14] == 'с объектами природы':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[14] == 'с детьми или сверстниками':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[с машинами, механизмами], [с объектами природы], [с детьми или сверстниками]'

    # 16
    if row[15] == 'давать знания и умения':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[15] == 'учить общению с другими людьми':
        dct_type['сфера работы с людьми'] += 1
    elif row[15] == 'обучать навыкам работы':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[давать знания и умения], [учить общению с другими людьми], [обучать навыкам работы]'

    # 17
    if row[16] == 'вести здоровый образ жизни':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[16] == 'иметь возможность заниматься творчеством':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[16] == 'иметь удобные бытовые условия':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[вести здоровый образ жизни], [иметь возможность заниматься творчеством], [иметь удобные бытовые условия]'

    # 18
    if row[17] == 'защита интересов и прав граждан':
        dct_type['сфера работы с людьми'] += 1
    elif row[17] == 'забота о материальном благополучии людей':
        dct_type['сфера технических интересов'] += 1
    elif row[17] == 'наука и технический прогресс':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[защита интересов и прав граждан], [забота о материальном благополучии людей], [наука и технический прогресс]'

    # 19
    if row[18] == 'физкультуры':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[18] == 'математики':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[18] == 'труда':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[физкультуры], [математики], [труда]'

    # 20
    if row[19] == 'планировать производство продукции':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[19] == 'изготавливать изделия':
        dct_type['сфера технических интересов'] += 1
    elif row[19] == 'заниматься сбытом продукции':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[планировать производство продукции], [изготавливать изделия], [заниматься сбытом продукции]'

    # 21
    if row[20] == 'о выдающихся ученых и их открытиях':
        dct_type['сфера умственного труда'] += 1
    elif row[20] == 'о творчестве ученых и музыкантов':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[20] == 'об интересных изобретениях':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №21'] = f'Полученное значение-{row[20]} не совпадает с эталонными:[о выдающихся ученых и их открытиях], [о творчестве ученых и музыкантов], [об интересных изобретениях]'

    # 22
    if row[21] == 'делая что-то по хозяйству':
        dct_type['сфера технических интересов'] += 1
    elif row[21] == 'с книгой':
        dct_type['сфера умственного труда'] += 1
    elif row[21] == 'на выставках, концертах и пр.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №22'] = f'Полученное значение-{row[21]} не совпадает с эталонными:[делая что-то по хозяйству], [с книгой], [на выставках, концертах и пр.]'

    # 23
    if row[22] == 'о художественной выставке':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[22] == 'о ситуации на фондовой бирже':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[22] == 'о научном открытии':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №23'] = f'Полученное значение-{row[22]} не совпадает с эталонными:[о художественной выставке], [о ситуации на фондовой бирже], [о научном открытии]'

    # 24
    if row[23] == 'в помещении, где много людей':
        dct_type['сфера работы с людьми'] += 1
    elif row[23] == 'в необычных условиях':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[23] == 'в обычном кабинете':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №24'] = f'Полученное значение-{row[23]} не совпадает с эталонными:[в помещении, где много людей], [в необычных условиях], [в обычном кабинете]'

    # проверяем на ошибки
    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # сортируем по убыванию
        result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
        begin_str = '\n'
        # создаем строку с результатами
        for sphere, value in result_lst:
            begin_str += f'{sphere}: {value};\n'

        # добавляем описание
        return begin_str


def processing_spp(base_df: pd.DataFrame, answers_df: pd.DataFrame):
    """
    Функция для обработки результатов тестирования сферы профессиональных предпочтений учащихся
    :return:
    """
    try:
        out_answer_df = base_df.copy()  # делаем копию для последующего соединения с сырыми ответами
        if len(answers_df.columns) != 24:
            raise BadCountColumnsSPP

        lst_check_cols = ['Мне хотелось бы в своей профессиональной деятельности','В книге или кинофильме меня больше всего привлекает',
                          'Меня обрадует Нобелевская премия','Я скорее соглашусь стать',
                          'Будущее людей определяют','На месте директора школы я прежде всего займусь',
                          'На технической выставке меня больше всего привлечет','В людях я ценю прежде всего',
                          'В свободное от работы время я буду','В заграничных поездках меня больше всего привлечет',
                          'Мне интереснее беседовать','Если бы в моей школе было всего три кружка, я бы выбрал(а)',
                          'В школе больше внимания следует уделять','Я с большим интересом смотрю',
                          'Мне было бы интереснее работать','Школа в первую очередь должна',
                          'Каждый человек должен','Для благополучия общества в первую очередь необходима',
                          'Мне больше всего нравятся уроки','Мне интереснее было бы',
                          'Я предпочитаю читать статьи','Свободное время я охотнее провожу',
                          'Больший интерес у меня вызовет сообщение','Я предпочитаю работать',
                          ]

        # Проверяем порядок колонок
        order_main_columns = lst_check_cols  # порядок колонок и названий как должно быть
        order_temp_df_columns = list(answers_df.columns)  # порядок колонок проверяемого файла
        error_order_lst = []  # список для несовпадающих пар
        # Сравниваем попарно колонки
        for main, temp in zip(order_main_columns, order_temp_df_columns):
            if main != temp:
                error_order_lst.append(f'На месте колонки {main} находится колонка {temp}')
                error_order_message = ';'.join(error_order_lst)
        if len(error_order_lst) != 0:
            raise BadOrderSPP

        valid_values = [['общаться с самыми разными людьми','что-нибудь делать своими руками – мебель, одежду, машины и т.д.','снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.'],
                        ['художественная форма, мастерство писателя или режиссера','сюжет, действие героев','информация, которая может пригодиться в жизни'],
                        ['в области науки','за общественную деятельность','в области искусства'],
                        ['управляющим банка','главным инженером на производстве','начальником экспедиции'],
                        ['достижения науки','развитие производства','взаимопонимание среди людей'],
                        ['благоустройством школы (столовая, спортзал, компьютеры)','созданием дружного, сплоченного коллектива','разработкой новых технологий обучения'],
                        ['внешний вид экспонатов (цвет, форма)','внутреннее устройство экспонатов (механизм)','практическое применение экспонатов'],
                        ['мужество, смелость, выносливость','дружелюбие, чуткость, отзывчивость','ответственность, аккуратность'],
                        ['писать стихи или музыку или рисовать','ставить различные опыты','тренироваться'],
                        ['экстремальный туризм (альпинизм, виндсерфинг, горные лыжи)','деловое общение','возможность знакомства с историей и культурой другой страны'],
                        ['о машине нового типа','о новой научной теории','о человеческих взаимоотношениях'],
                        ['технический','музыкальный','спортивный'],
                        ['улучшению взаимопонимания между учителями и учениками','поддержанию здоровья учащихся, занятиям спортом','укреплению дисциплины'],
                        ['научно-популярные фильмы','программы о культуре и спорте','спортивные программы'],
                        ['с машинами, механизмами','с объектами природы','с детьми или сверстниками'],
                        ['давать знания и умения','учить общению с другими людьми','обучать навыкам работы'],
                        ['вести здоровый образ жизни','иметь возможность заниматься творчеством','иметь удобные бытовые условия'],
                        ['защита интересов и прав граждан','забота о материальном благополучии людей','наука и технический прогресс'],
                        ['физкультуры','математики','труда'],
                        ['планировать производство продукции','изготавливать изделия','заниматься сбытом продукции'],
                        ['о выдающихся ученых и их открытиях','о творчестве ученых и музыкантов','об интересных изобретениях'],
                        ['делая что-то по хозяйству','с книгой','на выставках, концертах и пр.'],
                        ['о художественной выставке','о ситуации на фондовой бирже','о научном открытии'],
                        ['в помещении, где много людей','в необычных условиях','в обычном кабинете'],
                        ]

        lst_error_answers = [] # список для хранения строк где найдены неправильные ответы

        for idx,lst_values in enumerate(valid_values):
            mask = ~answers_df.iloc[:,idx].isin(lst_values) # проверяем на допустимые значения
            # Получаем строки с отличающимися значениями
            result_check = answers_df.iloc[:,idx][mask]

            if len(result_check) != 0:
                error_row = list(map(lambda x: x + 2, result_check.index))
                error_row = list(map(str, error_row))
                error_row_lst = [f'В {idx+1} вопросной колонке на строке {value}' for value in error_row]
                error_in_column = ','.join(error_row_lst)
                lst_error_answers.append(error_in_column)

        if len(lst_error_answers) !=0:
            error_message = ';'.join(lst_error_answers)
            raise BadValueSPP

        base_df[f'Необработанное'] = answers_df.apply(processing_result_spp, axis=1)
        base_df[f'Обработанное'] = base_df[f'Необработанное'].apply(
            extract_key_max_value)
        base_df[f'Максимум'] = base_df[f'Необработанное'].apply(
            extract_max_value)
        base_df[f'Уровень'] = base_df[f'Максимум'].apply(
            calc_level_spp)


        # Создаем датафрейм для создания части в общий датафрейм
        part_df = pd.DataFrame(columns=['СПП_Необработанное', 'СПП_Обработанное','СПП_Максимум','СПП_Уровень'])
        part_df['СПП_Необработанное'] = base_df['Необработанное']
        part_df['СПП_Обработанное'] = base_df['Обработанное']
        part_df['СПП_Максимум'] = base_df['Максимум']
        part_df['СПП_Уровень'] = base_df['Уровень']

        base_df.sort_values(by='Максимум', ascending=False, inplace=True)  # сортируем
        out_answer_df = pd.concat([out_answer_df, answers_df], axis=1)  # Датафрейм для проверки

        # Создаем строку с описанием
        description_result = """
Шкала оценки результатов
10-12 баллов – ярко выраженная профессиональная склонность;
7-9 баллов – средне выраженная профессиональная склонность;
4-6 баллов – слабо выраженная профессиональная склонность;
0-3 баллов – профессиональная склонность не выражена.

Примеры профессий для каждой сферы
Сфера работы с людьми: учитель, педагог, экскурсовод, воспитатель,  социолог, психолог, менеджер по персоналу, следователь.
Сфера умственного труда: ученый-исследователь (математик, физик, химик, кибернетик, археолог, геолог),  инженер, юрист, врач, эколог, архитектор, продюсер.
Сфера технических интересов:  программист, электротехник, радиотехник, Web-мастер, статистик, водитель, технолог, диспетчер, секретарь-машинистка, телефонист.
Сфера эстетики и искусства: художник, дизайнер, писатель, поэт,  режиссер, артист, конструктор, косметолог, костюмер, гример, кондитер, портной-кутюрье, цветовод.
Сфера физического труда,  подвижной деятельности: спортсмен, фотограф, экспедитор, парикмахер,  бармен, официант, стюардесса, продавец, закройщик, специалист по ремонту, кассир, медперсонал, бригадир, кладовщик,  почтальон,  фермер,  водитель-дальнобойщик, полицейский, военный.
Сфера материальных интересов,  планово-экономических видов работ: экономист, администратор, менеджер, предприниматель, аудитор, специалист по рекламе, брокер, агент страховых компаний, коммерсант, завхоз.
                """

        # создаем описание результата
        base_df[f'Описание_результата'] = 'Сфера профессиональных предпочтений.\n' + base_df[
            f'Необработанное'] + description_result
        part_df['СПП_Описание_результата'] = base_df[f'Описание_результата']

        # Общий свод по уровням склонности всего в процентном соотношении
        base_svod_all_df = pd.DataFrame(
            index=['профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
                   'средне выраженная профессиональная склонность',
                   'ярко выраженная профессиональная склонность', 'Итого'])

        svod_level_df = pd.pivot_table(base_df, index='Уровень',
                                       values='Максимум',
                                       aggfunc='count')

        svod_level_df['% от общего'] = round(
            svod_level_df['Максимум'] / svod_level_df['Максимум'].sum(), 3) * 100

        base_svod_all_df = base_svod_all_df.join(svod_level_df)

        # # Создаем суммирующую строку
        base_svod_all_df.loc['Итого'] = svod_level_df.sum()
        base_svod_all_df.reset_index(inplace=True)
        base_svod_all_df.rename(columns={'index': 'Уровень склонности', 'Максимум': 'Количество'}, inplace=True)


        # формируем основной словарь
        out_dct = {'Списочный результат': base_df, 'Список для проверки': out_answer_df,
                   'Свод по уровням': base_svod_all_df,
                   }

        lst_level = ['профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
                   'средне выраженная профессиональная склонность',
                   'ярко выраженная профессиональная склонность']
        dct_level = dict()

        for level in lst_level:
            temp_df = base_df[base_df['Уровень'] == level]
            if temp_df.shape[0] != 0:
                if level == 'профессиональная склонность не выражена':
                    level = 'не выражена'
                elif level == 'слабо выраженная профессиональная склонность':
                    level = 'слабо выражена'
                elif level == 'средне выраженная профессиональная склонность':
                    level = 'средне выражена'
                elif level == 'ярко выраженная профессиональная склонность':
                    level = 'ярко выражена'
                dct_level[level] = temp_df

        out_dct.update(dct_level)

        # Общий свод по сферам всего в процентном соотношении
        svod_sphere_df = pd.pivot_table(base_df, index='Обработанное',
                                        values='Максимум',
                                        aggfunc='count')

        svod_sphere_df['% от общего'] = round(
            svod_sphere_df['Максимум'] / svod_sphere_df['Максимум'].sum(), 3) * 100

        svod_sphere_df.sort_index(inplace=True)

        # # Создаем суммирующую строку
        svod_sphere_df.loc['Итого'] = svod_sphere_df.sum()
        svod_sphere_df.reset_index(inplace=True)
        svod_sphere_df.rename(columns={'index': 'Предпочтительная склонность', 'Максимум': 'Количество'},
                              inplace=True)

        # формируем списки по сферам деятельности
        lst_sphere = base_df['Обработанное'].unique()
        lst_sphere.sort()  # сортируем
        dct_sphere = {'Свод по склонностям': svod_sphere_df}  # словарь для хранения списков

        for sphere in lst_sphere:
            temp_df = base_df[base_df['Обработанное'] == sphere]
            dct_sphere[sphere] = temp_df

        new_keys = {'сфера работы с людьми': 'Работа с людьми', 'сфера умственного труда': 'Умственный труд',
                    'сфера технических интересов': 'Технические интересы', 'сфера эстетики и искусства': 'Эстетика и искусство',
                    'сфера физического труда, подвижной деятельности': 'Физический труд',
                    'сфера материальных интересов, планово-экономических видов работ': 'Материальные интересы',
                    }

        renamed_dict = {new_keys.get(key, key): value for key, value in dct_sphere.items()}

        out_dct.update(renamed_dict)


        """
            Своды 
            """
        lst_reindex_group_cols = ['Группа','профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
                   'средне выраженная профессиональная склонность',
                   'ярко выраженная профессиональная склонность','Итого']
        lst_reindex_group_sex_cols = ['Группа','Пол','профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
                   'средне выраженная профессиональная склонность',
                   'ярко выраженная профессиональная склонность','Итого']

        lst_reindex_course_cols = ['Курс','профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
                   'средне выраженная профессиональная склонность',
                   'ярко выраженная профессиональная склонность','Итого']
        lst_reindex_course_sex_cols = ['Курс','Пол','профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
                   'средне выраженная профессиональная склонность',
                   'ярко выраженная профессиональная склонность','Итого']

        # Своды по уровням
        # Группа
        svod_group_level_df = calc_mean(base_df, 'Группа', ['Группа', 'Уровень'], 'Максимум')
        svod_count_group_level_df = calc_count_level_spp(base_df, 'Группа', ['Группа'], 'Максимум', 'Уровень',
                                                         lst_reindex_group_cols)

        # Группа Пол
        svod_group_level_sex_df = calc_mean(base_df, 'Группа', ['Группа', 'Уровень', 'Пол'], 'Максимум')
        svod_count_group_level_sex_df = calc_count_level_spp(base_df, 'Группа', ['Группа', 'Пол'], 'Максимум', 'Уровень',
                                                             lst_reindex_group_sex_cols)

        # Курс
        svod_course_level_df = calc_mean(base_df, 'Курс', ['Курс', 'Уровень'], 'Максимум')
        svod_count_course_level_df = calc_count_level_spp(base_df, 'Курс', ['Курс'], 'Максимум',
                                                           'Уровень', lst_reindex_course_cols)

        # Курс Пол
        svod_course_level_sex_df = calc_mean(base_df, 'Курс', ['Курс', 'Уровень', 'Пол'], 'Максимум')
        svod_count_course_level_sex_df = calc_count_level_spp(base_df, 'Курс', ['Курс', 'Пол'],
                                                               'Максимум',
                                                               'Уровень', lst_reindex_course_sex_cols)

        # Своды по сферам
        # Группа
        svod_group_sphere_df = calc_mean(base_df, 'Группа', ['Группа', 'Обработанное'], 'Максимум')
        svod_count_group_sphere_df = calc_count_sphere_spp(base_df, 'Группа', ['Группа'], 'Максимум', 'Обработанное')

        # Группа Пол
        svod_group_sphere_sex_df = calc_mean(base_df, 'Группа', ['Группа', 'Обработанное', 'Пол'], 'Максимум')
        svod_count_group_sphere_sex_df = calc_count_sphere_spp(base_df, 'Группа', ['Группа', 'Пол'], 'Максимум',
                                                                'Обработанное')

        # Курс
        svod_course_sphere_df = calc_mean(base_df, 'Курс', ['Курс', 'Обработанное'], 'Максимум')
        svod_count_course_sphere_df = calc_count_sphere_spp(base_df, 'Курс', ['Курс'], 'Максимум',
                                                             'Обработанное')

        # Курс Пол
        svod_course_sphere_sex_df = calc_mean(base_df, 'Курс', ['Курс', 'Обработанное', 'Пол'],
                                              'Максимум')
        svod_count_course_sphere_sex_df = calc_count_sphere_spp(base_df, 'Курс', ['Курс', 'Пол'],
                                                                 'Максимум', 'Обработанное')

        svod_dct = {'Ср. Уровень Группа': svod_group_level_df, 'Кол. Уровень Группа': svod_count_group_level_df,
                    'Ср. Уровень Группа Пол': svod_group_level_sex_df,
                    'Кол. Уровень Группа Пол': svod_count_group_level_sex_df,
                    'Ср. Уровень Курс': svod_course_level_df,
                    'Кол. Уровень Курс': svod_count_course_level_df,
                    'Ср. Уровень Курс Пол': svod_course_level_sex_df,
                    'Кол. Уровень Курс Пол': svod_count_course_level_sex_df,

                    'Ср. Сфера Группа': svod_group_sphere_df, 'Кол. Сфера Группа': svod_count_group_sphere_df,
                    'Ср. Сфера Группа Пол': svod_group_sphere_sex_df,
                    'Кол. Сфера Группа Пол': svod_count_group_sphere_sex_df,
                    'Ср. Сфера Курс': svod_course_sphere_df,
                    'Кол. Сфера Курс': svod_count_course_sphere_df,
                    'Ср. Сфера Курс Пол': svod_course_sphere_sex_df,
                    'Кол. Сфера Курс Пол': svod_count_course_sphere_sex_df,

                    }
        out_dct.update(svod_dct)  # добавляем чтобы сохранить порядок


        return out_dct, part_df

    except BadOrderSPP:
        messagebox.showerror('Лахеcис',
                             f'При обработке вопросов теста Сфера профессиональных предпочтений обнаружены неправильные вопросы. Проверьте названия колонок с вопросами:\n'
                             f'{error_order_message}\n'
                             f'Используйте при создании Яндекс-формы написание вопросов из руководства пользователя программы Лахесис.')
    except BadValueSPP:
        messagebox.showerror('Лахеcис',
                             f'При обработке вопросов теста Сфера профессиональных предпочтений обнаружены неправильные варианты ответов. Проверьте ответы на указанных строках:\n'
                             f'{error_message}\n'
                             f'Используйте при создании Яндекс-формы написание вариантов ответа из руководства пользователя программы Лахесис.')


    except BadCountColumnsSPP:
        messagebox.showerror('Лахеcис',
                             f'Проверьте количество колонок с ответами на тест Сфера профессиональных предпочтений\n'
                             f'Должно быть 24 колонки с ответами')