"""
Скрипт для обработки результатов теста Направленность на вид инженерной деятельности
"""

import pandas as pd
from tkinter import messagebox
from lachesis_support_functions import round_mean, sort_name_class


class BadValueNVID(Exception):
    """
    Исключение для неправильных значений в вариантах ответов
    """
    pass


class BadCountColumnsNVID(Exception):
    """
    Исключение для обработки случая если количество колонок не равно 24
    """
    pass


def extract_key_max_value(cell: str) -> str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n', '')  # убираем переносы
    lst_temp = cell.split(';')  # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key, value = result.split(': ')  # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)


def extract_max_value(cell: str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n', '')  # убираем переносы
    lst_temp = cell.split(';')  # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key, value = result.split(': ')  # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]


def processing_result_nvid(row):
    """
    Обработка результатов тестирования
    """

    # Создаем словарь для хранения данных
    dct_type = {'научно-исследовательская деятельность': 0,
                'проектно-конструкторская': 0,
                'производственная': 0,
                'организаторская': 0,
                }

    # 1
    if row[0] == 'Планировать и проводить эксперименты для проверки научных гипотез, догадок, выявления закономерностей':
        dct_type['научно-исследовательская деятельность'] += 1
    elif row[0] == 'Эксплуатировать машины, механизмы, приборы (управлять, следить, регулировать)':
        dct_type['производственная'] += 1

    # 2
    if row[1] == 'Проектировать, конструировать новые приборы, машины, механизмы':
        dct_type['проектно-конструкторская'] += 1
    elif row[1] == 'Организовывать, планировать, координировать производственную деятельность людей':
        dct_type['организаторская'] += 1

    # 3
    if row[2] == 'Обеспечивать эффективную безаварийную работу сложных технических устройств':
        dct_type['производственная'] += 1
    elif row[2] == 'Вносить усовершенствования в конструкцию технических устройств':
        dct_type['проектно-конструкторская'] += 1

    # 4
    if row[3] == 'Разрабатывать и внедрять в производство современные формы и методы организации труда':
        dct_type['организаторская'] += 1
    elif row[3] == 'Искать оптимальные решения научных и технических проблем, формулировать новые задачи':
        dct_type['научно-исследовательская деятельность'] += 1

    # 5
    if row[4] == 'Эксплуатировать машины, механизмы, приборы (управлять, следить, регулировать)':
        dct_type['производственная'] += 1
    elif row[4] == 'Организовывать, планировать координировать производственную деятельность людей':
        dct_type['организаторская'] += 1

    # 6
    if row[5] == 'Искать оптимальные решения научных и технических проблем, формулировать новые задачи':
        dct_type['научно-исследовательская деятельность'] += 1
    elif row[5] == 'Вносить усовершенствования в конструкцию технических устройств':
        dct_type['проектно-конструкторская'] += 1

    # 7
    if row[6] == 'Обеспечивать эффективную безаварийную работу сложных технических устройств':
        dct_type['производственная'] += 1
    elif row[6] == 'Искать оптимальные решения научных и технических проблем, формулировать новые задачи':
        dct_type['научно-исследовательская деятельность'] += 1

    # 8
    if row[7] == 'Разрабатывать и внедрять в производство современные формы и методы организации труда':
        dct_type['организаторская'] += 1
    elif row[7] == 'Вносить усовершенствования в конструкцию технических устройств':
        dct_type['проектно-конструкторская'] += 1

    # 9
    if row[8] == 'Проектировать, конструировать новые приборы, машины, механизмы':
        dct_type['проектно-конструкторская'] += 1
    elif row[8] == 'Эксплуатировать машины, механизмы, приборы (управлять следить, регулировать)':
        dct_type['производственная'] += 1

    # 10
    if row[9] == 'Планировать и проводить эксперименты для проверки научных гипотез, догадок, выявлять закономерности':
        dct_type['научно-исследовательская деятельность'] += 1
    elif row[9] == 'Организовывать, планировать, координировать производственную деятельность людей':
        dct_type['организаторская'] += 1

    # 11
    if row[10] == 'Разрабатывать и внедрять в производство современные формы и методы организации труда':
        dct_type['организаторская'] += 1
    elif row[10] == 'Обеспечивать эффективную безаварийную работу сложных технических устройств':
        dct_type['производственная'] += 1

    # 12
    if row[11] == 'Проектировать, конструировать новые приборы, машины, механизмы':
        dct_type['проектно-конструкторская'] += 1
    elif row[11] == 'Планировать и проводить эксперименты для проверки гипотез, догадок, выявлять закономерности':
        dct_type['научно-исследовательская деятельность'] += 1

    # 13
    if row[12] == 'Искать оптимальные решения научных и технических проблем, формулировать новые задачи':
        dct_type['научно-исследовательская деятельность'] += 1
    elif row[12] == 'Эксплуатировать машины, механизмы, приборы (управлять следить, регулировать)':
        dct_type['производственная'] += 1

    # 14
    if row[13] == 'Вносить усовершенствования в конструкцию технических устройств':
        dct_type['проектно-конструкторская'] += 1
    elif row[13] == 'Организовывать, планировать, координировать производственную деятельность людей':
        dct_type['организаторская'] += 1

    # 15
    if row[14] == 'Эксплуатировать машины, механизмы, приборы (управлять, следить, регулировать)':
        dct_type['производственная'] += 1
    elif row[14] == 'Вносить усовершенствования в конструкцию технических устройств':
        dct_type['проектно-конструкторская'] += 1

    # 16
    if row[15] == 'Организовывать, планировать, координировать производственную деятельность людей':
        dct_type['организаторская'] += 1
    elif row[15] == 'Искать оптимальные решения научных и технических проблем, формулировать новые задачи':
        dct_type['научно-исследовательская деятельность'] += 1

    # 17
    if row[16] == 'Обеспечивать эффективную безаварийную работу сложных технических устройств':
        dct_type['производственная'] += 1
    elif row[16] == 'Организовывать, планировать, координировать производственную деятельность людей':
        dct_type['организаторская'] += 1

    # 18
    if row[17] == 'Искать оптимальные решения научных и технических проблем, формулировать новые задачи':
        dct_type['научно-исследовательская деятельность'] += 1
    elif row[17] == 'Проектировать, конструировать новые приборы, машины, механизмы':
        dct_type['проектно-конструкторская'] += 1

    # 19
    if row[18] == 'Обеспечивать эффективную безаварийную работу сложных технических устройств':
        dct_type['производственная'] += 1
    elif row[18] == 'Планировать и проводить эксперименты для проверки научных гипотез, догадок, выявлять закономерности':
        dct_type['научно-исследовательская деятельность'] += 1

    # 20
    if row[19] == 'Разрабатывать и внедрять в производство современные методы и формы организации труда':
        dct_type['организаторская'] += 1
    elif row[19] == 'Проектировать, конструировать новые приборы, машины, механизмы':
        dct_type['проектно-конструкторская'] += 1

    # 21
    if row[20] == 'Планировать, проводить эксперименты для проверки научных гипотез, догадок, выявлять закономерности':
        dct_type['научно-исследовательская деятельность'] += 1
    elif row[20] == 'Разрабатывать и внедрять в производство современные формы и методы организации труда':
        dct_type['организаторская'] += 1

    # 22
    if row[21] == 'Проектировать, конструировать новые приборы, машины, механизмы':
        dct_type['проектно-конструкторская'] += 1
    elif row[21] == 'Обеспечивать эффективную безаварийную работу сложных технических устройств':
        dct_type['производственная'] += 1

    # 23
    if row[22] == 'Разрабатывать и внедрять в производство современные методы, формы организации труда':
        dct_type['организаторская'] += 1
    elif row[22] == 'Обеспечивать эффективную безаварийную работу сложных технических устройств':
        dct_type['производственная'] += 1

    # 24
    if row[23] == 'Вносить усовершенствования в конструкцию технических устройств':
        dct_type['проектно-конструкторская'] += 1
    elif row[23] == 'Планировать и проводить эксперименты для проверки научных гипотез, догадок, выявлять закономерности':
        dct_type['научно-исследовательская деятельность'] += 1


    # сортируем по убыванию
    result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
    begin_str = '\n'
    # создаем строку с результатами
    for sphere, value in result_lst:
        begin_str += f'{sphere}: {value};\n'

    # добавляем описание
    return begin_str


def calc_level_nvid(value):
    """
    Функция для подсчета уровня склонности к то или иной сфере
    """
    if 0 <= value <= 8:
        return 'склонность не выражена'
    elif 9 <= value <= 12:
        return 'склонность выражена'



def calc_mean(df:pd.DataFrame,type_calc:str,lst_cat:list,val_cat):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Группа или Курс
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :return:датафрейм
    """
    if type_calc == 'Группа':
        calc_mean_df = pd.pivot_table(df, index=lst_cat,
                                           values=[val_cat],
                                           aggfunc=round_mean)
        calc_mean_df.reset_index(inplace=True)
        calc_mean_df.rename(columns={val_cat: 'Среднее значение'}, inplace=True)

        return calc_mean_df
    else:
        calc_mean_df = pd.pivot_table(df, index=lst_cat,
                                           values=val_cat,
                                           aggfunc=round_mean)
        calc_mean_df.reset_index(inplace=True)
        calc_mean_df.rename(columns={val_cat:'Среднее значение'},inplace=True)
        return calc_mean_df



def calc_count_sphere_nvid(df:pd.DataFrame, type_calc:str, lst_cat:list, val_cat, col_cat):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Группа или Курс
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :param col_cat: колонка по которой будет формироваться свод
    :return:датафрейм
    """
    if type_calc == 'Группа':
        count_df = pd.pivot_table(df, index=lst_cat,
                                                 columns=col_cat,
                                                 values=val_cat,
                                                 aggfunc='count', margins=True, margins_name='Итого')

        lst_sphere = count_df.columns[:-1]
        count_df.reset_index(inplace=True)

        for sphere in lst_sphere:
            count_df[f'% {sphere} от общего'] = round(
            count_df[f'{sphere}'] / count_df['Итого'], 2) * 100

        return count_df
    else:
        count_df = pd.pivot_table(df, index=lst_cat,
                                  columns=col_cat,
                                  values=val_cat,
                                  aggfunc='count', margins=True, margins_name='Итого')

        lst_sphere = count_df.columns[:-1]
        count_df.reset_index(inplace=True)

        for sphere in lst_sphere:
            count_df[f'% {sphere} от общего'] = round(
            count_df[f'{sphere}'] / count_df['Итого'], 2) * 100

        return count_df




def calc_count_level_nvid(df:pd.DataFrame, type_calc:str, lst_cat:list, val_cat, col_cat, lst_cols:list):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Группа или Курс
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :param col_cat: колонка по которой будет формироваться свод
    :param lst_cols: список с колонками
    :return:датафрейм
    """
    if type_calc == 'Группа':
        count_df = pd.pivot_table(df, index=lst_cat,
                                                 columns=col_cat,
                                                 values=val_cat,
                                                 aggfunc='count', margins=True, margins_name='Итого')


        count_df.reset_index(inplace=True)
        count_df = count_df.reindex(columns=lst_cols)
        count_df['% склонность не выражена от общего'] = round(
            count_df['склонность не выражена'] / count_df['Итого'], 2) * 100
        count_df['% склонность выражена от общего'] = round(
            count_df['склонность выражена'] / count_df['Итого'], 2) * 100


        return count_df
    else:
        count_df = pd.pivot_table(df, index=lst_cat,
                                  columns=col_cat,
                                  values=val_cat,
                                  aggfunc='count', margins=True, margins_name='Итого')

        count_df.reset_index(inplace=True)
        count_df = count_df.reindex(columns=lst_cols)
        count_df['% склонность не выражена от общего'] = round(
            count_df['склонность не выражена'] / count_df['Итого'], 2) * 100
        count_df['% склонность выражена от общего'] = round(
            count_df['склонность выражена'] / count_df['Итого'], 2) * 100

        return count_df








def processing_nvid(base_df: pd.DataFrame, answers_df: pd.DataFrame):
    """
        Фугкция для обработки данных НВИД
        :return:
        """
    try:
        out_answer_df = base_df.copy()  # делаем копию для последующего соединения с сырыми ответами
        if answers_df.shape[1] != 24:
            raise BadCountColumnsNVID
        # Переименовываем колонки
        answers_df.columns = [f'Вопрос_ №{i}' for i in range(1, 25)]

        valid_values = [['Планировать и проводить эксперименты для проверки научных гипотез, догадок, выявления закономерностей','Эксплуатировать машины, механизмы, приборы (управлять, следить, регулировать)'],
                        ['Проектировать, конструировать новые приборы, машины, механизмы','Организовывать, планировать, координировать производственную деятельность людей'],
                        ['Обеспечивать эффективную безаварийную работу сложных технических устройств','Вносить усовершенствования в конструкцию технических устройств'],
                        ['Разрабатывать и внедрять в производство современные формы и методы организации труда','Искать оптимальные решения научных и технических проблем, формулировать новые задачи'],
                        ['Эксплуатировать машины, механизмы, приборы (управлять, следить, регулировать)','Организовывать, планировать координировать производственную деятельность людей'],
                        ['Искать оптимальные решения научных и технических проблем, формулировать новые задачи','Вносить усовершенствования в конструкцию технических устройств'],
                        ['Обеспечивать эффективную безаварийную работу сложных технических устройств','Искать оптимальные решения научных и технических проблем, формулировать новые задачи'],
                        ['Разрабатывать и внедрять в производство современные формы и методы организации труда','Вносить усовершенствования в конструкцию технических устройств'],
                        ['Проектировать, конструировать новые приборы, машины, механизмы','Эксплуатировать машины, механизмы, приборы (управлять следить, регулировать)'],
                        ['Планировать и проводить эксперименты для проверки научных гипотез, догадок, выявлять закономерности','Организовывать, планировать, координировать производственную деятельность людей'],
                        ['Разрабатывать и внедрять в производство современные формы и методы организации труда','Обеспечивать эффективную безаварийную работу сложных технических устройств'],
                        ['Проектировать, конструировать новые приборы, машины, механизмы','Планировать и проводить эксперименты для проверки гипотез, догадок, выявлять закономерности'],
                        ['Искать оптимальные решения научных и технических проблем, формулировать новые задачи','Эксплуатировать машины, механизмы, приборы (управлять следить, регулировать)'],
                        ['Вносить усовершенствования в конструкцию технических устройств','Организовывать, планировать, координировать производственную деятельность людей'],
                        ['Эксплуатировать машины, механизмы, приборы (управлять, следить, регулировать)','Вносить усовершенствования в конструкцию технических устройств'],
                        ['Организовывать, планировать, координировать производственную деятельность людей','Искать оптимальные решения научных и технических проблем, формулировать новые задачи'],
                        ['Обеспечивать эффективную безаварийную работу сложных технических устройств','Организовывать, планировать, координировать производственную деятельность людей'],
                        ['Искать оптимальные решения научных и технических проблем, формулировать новые задачи','Проектировать, конструировать новые приборы, машины, механизмы'],
                        ['Обеспечивать эффективную безаварийную работу сложных технических устройств','Планировать и проводить эксперименты для проверки научных гипотез, догадок, выявлять закономерности'],
                        ['Разрабатывать и внедрять в производство современные методы и формы организации труда','Проектировать, конструировать новые приборы, машины, механизмы'],
                        ['Планировать, проводить эксперименты для проверки научных гипотез, догадок, выявлять закономерности','Разрабатывать и внедрять в производство современные формы и методы организации труда'],
                        ['Проектировать, конструировать новые приборы, машины, механизмы','Обеспечивать эффективную безаварийную работу сложных технических устройств'],
                        ['Разрабатывать и внедрять в производство современные методы, формы организации труда','Обеспечивать эффективную безаварийную работу сложных технических устройств'],
                        ['Вносить усовершенствования в конструкцию технических устройств','Планировать и проводить эксперименты для проверки научных гипотез, догадок, выявлять закономерности']
                        ]

        lst_error_answers = []  # список для хранения строк где найдены неправильные ответы

        for idx, lst_values in enumerate(valid_values):
            mask = ~answers_df.iloc[:, idx].isin(lst_values)  # проверяем на допустимые значения
            # Получаем строки с отличающимися значениями
            result_check = answers_df.iloc[:, idx][mask]

            if len(result_check) != 0:
                error_row = list(map(lambda x: x + 2, result_check.index))
                error_row = list(map(str, error_row))
                error_row_lst = [f'В {idx + 1} вопросной колонке на строке {value}' for value in error_row]
                error_in_column = ','.join(error_row_lst)
                lst_error_answers.append(error_in_column)

        if len(lst_error_answers) != 0:
            error_message = ';'.join(lst_error_answers)
            raise BadValueNVID

        base_df[f'Необработанное'] = answers_df.apply(processing_result_nvid, axis=1)
        base_df[f'Обработанное'] = base_df[f'Необработанное'].apply(
            extract_key_max_value)
        base_df[f'Максимум'] = base_df[f'Необработанное'].apply(
            extract_max_value)

        base_df[f'Уровень'] = base_df[f'Максимум'].apply(
            calc_level_nvid)

        # Создаем датафрейм для создания части в общий датафрейм
        part_df = pd.DataFrame(
            columns=['НВИД_Необработанное', 'НВИД_Обработанное', 'НВИД_Максимум', 'НВИД_Уровень', 'НВИД_Описание_результата'])
        part_df['НВИД_Необработанное'] = base_df['Необработанное']
        part_df['НВИД_Обработанное'] = base_df['Обработанное']
        part_df['НВИД_Максимум'] = base_df['Максимум']
        part_df['НВИД_Уровень'] = base_df['Уровень']



        # Общий свод по уровням склонности всего в процентном соотношении
        base_svod_all_df = pd.DataFrame(
            index=['склонность не выражена',
                 'склонность выражена',
                   'Итого'])

        svod_level_df = pd.pivot_table(base_df, index='Уровень',
                                       values='Максимум',
                                       aggfunc='count')

        svod_level_df['% от общего'] = round(
            svod_level_df['Максимум'] / svod_level_df['Максимум'].sum(), 3) * 100

        base_svod_all_df = base_svod_all_df.join(svod_level_df)

        # # Создаем суммирующую строку
        base_svod_all_df.loc['Итого'] = svod_level_df.sum()
        base_svod_all_df.reset_index(inplace=True)
        base_svod_all_df.rename(columns={'index': 'Уровень склонности', 'Максимум': 'Количество'}, inplace=True)

        # формируем основной словарь
        out_dct = {'Списочный результат': base_df, 'Список для проверки': out_answer_df,
                   'Свод по уровням': base_svod_all_df,
                   }

        lst_level = ['склонность не выражена',
                 'склонность выражена']
        dct_level = dict()

        for level in lst_level:
            temp_df = base_df[base_df['Уровень'] == level]
            if temp_df.shape[0] != 0:
                dct_level[level] = temp_df

        out_dct.update(dct_level)

        # Общий свод по сферам всего в процентном соотношении
        svod_sphere_df = pd.pivot_table(base_df, index='Обработанное',
                                        values='Максимум',
                                        aggfunc='count')

        svod_sphere_df['% от общего'] = round(
            svod_sphere_df['Максимум'] / svod_sphere_df['Максимум'].sum(), 3) * 100

        svod_sphere_df.sort_index(inplace=True)

        # # Создаем суммирующую строку
        svod_sphere_df.loc['Итого'] = svod_sphere_df.sum()
        svod_sphere_df.reset_index(inplace=True)
        svod_sphere_df.rename(columns={'Обработанное': 'Склонность', 'Максимум': 'Количество'},
                              inplace=True)

        # формируем списки по сферам деятельности
        lst_sphere = base_df['Обработанное'].unique()
        lst_sphere.sort()  # сортируем
        dct_sphere = {'Предпочитаемый труд': svod_sphere_df}  # словарь для хранения списков

        for sphere in lst_sphere:
            temp_df = base_df[base_df['Обработанное'] == sphere]
            if sphere == 'научно-исследовательская деятельность':
                sphere = 'научно-исследовательская'

            dct_sphere[sphere] = temp_df

        out_dct.update(dct_sphere)

        """
                               Своды 
                               """
        lst_reindex_group_cols = ['Группа', 'склонность не выражена',
                 'склонность выражена', 'Итого']
        lst_reindex_group_sex_cols = ['Группа', 'Пол', 'склонность не выражена',
                 'склонность выражена', 'Итого']

        lst_reindex_course_cols = ['Курс', 'склонность не выражена',
                 'склонность выражена', 'Итого']
        lst_reindex_course_sex_cols = ['Курс', 'Пол', 'склонность не выражена',
                 'склонность выражена', 'Итого']

        # Своды по уровням
        # Группа
        svod_group_level_df = calc_mean(base_df, 'Группа', ['Группа', 'Уровень'], 'Максимум')
        svod_count_group_level_df = calc_count_level_nvid(base_df, 'Группа', ['Группа'], 'Максимум', 'Уровень',
                                                          lst_reindex_group_cols)

        # Группа Пол
        svod_group_level_sex_df = calc_mean(base_df, 'Группа', ['Группа', 'Уровень', 'Пол'], 'Максимум')
        svod_count_group_level_sex_df = calc_count_level_nvid(base_df, 'Группа', ['Группа', 'Пол'], 'Максимум', 'Уровень',
                                                              lst_reindex_group_sex_cols)

        # Курс
        svod_course_level_df = calc_mean(base_df, 'Курс', ['Курс', 'Уровень'], 'Максимум')
        svod_count_course_level_df = calc_count_level_nvid(base_df, 'Курс', ['Курс'], 'Максимум',
                                                          'Уровень', lst_reindex_course_cols)

        # Курс Пол
        svod_course_level_sex_df = calc_mean(base_df, 'Курс', ['Курс', 'Уровень', 'Пол'], 'Максимум')
        svod_count_course_level_sex_df = calc_count_level_nvid(base_df, 'Курс', ['Курс', 'Пол'],
                                                              'Максимум',
                                                              'Уровень', lst_reindex_course_sex_cols)

        # Своды по сферам
        # Группа
        svod_group_sphere_df = calc_mean(base_df, 'Группа', ['Группа', 'Обработанное'], 'Максимум')
        svod_count_group_sphere_df = calc_count_sphere_nvid(base_df, 'Группа', ['Группа'], 'Максимум', 'Обработанное')

        # Группа Пол
        svod_group_sphere_sex_df = calc_mean(base_df, 'Группа', ['Группа', 'Обработанное', 'Пол'], 'Максимум')
        svod_count_group_sphere_sex_df = calc_count_sphere_nvid(base_df, 'Группа', ['Группа', 'Пол'], 'Максимум',
                                                               'Обработанное')

        # Курс
        svod_course_sphere_df = calc_mean(base_df, 'Курс', ['Курс', 'Обработанное'], 'Максимум')
        svod_count_course_sphere_df = calc_count_sphere_nvid(base_df, 'Курс', ['Курс'], 'Максимум',
                                                            'Обработанное')

        # Курс Пол
        svod_course_sphere_sex_df = calc_mean(base_df, 'Курс', ['Курс', 'Обработанное', 'Пол'],
                                              'Максимум')
        svod_count_course_sphere_sex_df = calc_count_sphere_nvid(base_df, 'Курс', ['Курс', 'Пол'],
                                                                'Максимум', 'Обработанное')

        svod_dct = {'Ср. Уровень Группа': svod_group_level_df, 'Кол. Уровень Группа': svod_count_group_level_df,
                    'Ср. Уровень Группа Пол': svod_group_level_sex_df,
                    'Кол. Уровень Группа Пол': svod_count_group_level_sex_df,
                    'Ср. Уровень Курс': svod_course_level_df,
                    'Кол. Уровень Курс': svod_count_course_level_df,
                    'Ср. Уровень Курс Пол': svod_course_level_sex_df,
                    'Кол. Уровень Курс Пол': svod_count_course_level_sex_df,

                    'Ср. Труд Группа': svod_group_sphere_df, 'Кол. Труд Группа': svod_count_group_sphere_df,
                    'Ср. Труд Группа Пол': svod_group_sphere_sex_df,
                    'Кол. Труд Группа Пол': svod_count_group_sphere_sex_df,
                    'Ср. Труд Курс': svod_course_sphere_df,
                    'Кол. Труд Курс': svod_count_course_sphere_df,
                    'Ср. Труд Курс Пол': svod_course_sphere_sex_df,
                    'Кол. Труд Курс Пол': svod_count_course_sphere_sex_df,

                    }
        out_dct.update(svod_dct)  # добавляем, чтобы сохранить порядок

        return out_dct, part_df

    except BadValueNVID:
        messagebox.showerror('Лахеcис',
                             f'При обработке вопросов теста Направленность на вид инженерной деятельности Годлиник обнаружены неправильные варианты ответов. Проверьте ответы на указанных строках:\n'
                             f'{error_message}\n'
                             f'Используйте при создании Яндекс-формы написание вариантов ответа из руководства пользователя программы Лахесис.')


    except BadCountColumnsNVID:
        messagebox.showerror('Лахеcис',
                             f'Проверьте количество колонок с ответами на тест Направленность на вид инженерной деятельности Годлиник\n'
                             f'Должно быть 24 колонки с ответами')


















