"""
Скрипт для обработки теста Склонность к исполнительскому или творческому труду Азбель
"""

import pandas as pd
import re
from tkinter import messagebox
from lachesis_support_functions import round_mean, create_union_svod,calc_count_scale



class BadValueSITT(Exception):
    """
    Исключение для неправильных значений в вариантах ответов
    """
    pass


class BadCountColumnsSITT(Exception):
    """
    Исключение для обработки случая если количество колонок не равно 12
    """
    pass

def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]



def processing_result_sitt(row):
    """
    Обработка результатов тестирования
    """

    # Создаем словарь для хранения данных
    dct_type = {'Исполнительский труд': 0,
                'Творческий труд': 0}

    # 1
    if row[0] == 'Моя работа такова, что умение хорошо выполнять её и чёткое соблюдение правил гарантированно приведут к предсказуемому результату':
        dct_type['Исполнительский труд'] += 1
    elif row[0] == 'Даже если я выполняю свою работу качественно, я не могу точно предсказать её результаты':
        dct_type['Творческий труд'] += 1

    # 2
    if row[1] == 'Способы выполнения моей работы более-менее стандартны, известны заранее':
        dct_type['Исполнительский труд'] += 1
    elif row[1] == 'Способы и методы выполнения моей работы очень многообразны, я сам ответственен за их выбор':
        dct_type['Творческий труд'] += 1

    # 3
    if row[2] == 'Что и как мне делать, определяет начальство, моя задача — пунктуально исполнять распоряжения':
        dct_type['Исполнительский труд'] += 1
    elif row[2] == 'Моя работа не подразумевает чётких инструкций, приходится постоянно размышлять о том, как действовать':
        dct_type['Творческий труд'] += 1

    # 4
    if row[3] == 'Я хотел бы выучиться какой-либо профессии, а потом спокойно зарабатывать деньги, больше не тратя времени и сил на дальнейшее обучение':
        dct_type['Исполнительский труд'] += 1
    elif row[3] == 'Я готов заниматься такой работой, которая требует постоянных затрат времени и сил для дальнейшего обучения, профессионального самосовершенствования':
        dct_type['Творческий труд'] += 1

    # 5
    if row[4] == 'Моё отношение к работе описывается пословицей «Лучше синица в руках, чем журавль в небе»':
        dct_type['Исполнительский труд'] += 1
    elif row[4] == 'Моё отношение к работе точнее передаёт фраза «Лучше охотиться за журавлём в небе, чем иметь синицу в руках»':
        dct_type['Творческий труд'] += 1

    # 6
    if row[5] == 'Главное, чтобы работа и заработки были стабильными; возможность развиваться в профессиональной сфере для меня не столь важна':
        dct_type['Исполнительский труд'] += 1
    elif row[5] == 'Мне важно, чтобы на работе была постоянная возможность для профессионального развития, пусть даже в ущерб стабильности':
        dct_type['Творческий труд'] += 1

    # 7
    if row[6] == 'Хотелось бы иметь гарантированную оплату труда, соответствующую времени и силам, которые я трачу на работу':
        dct_type['Исполнительский труд'] += 1
    elif row[6] == 'Оплачиваться должен исключительно результат работы, а не потраченное на его достижение время и усилия':
        dct_type['Творческий труд'] += 1

    # 8
    if row[7] == 'График моей работы подчинён чёткому расписанию: я всегда знаю, где и когда я должен находиться и что именно делать':
        dct_type['Исполнительский труд'] += 1
    elif row[7] == 'Далеко не все моё рабочее время подчинено чёткому расписанию, в значительной степени я сам определяю, когда и где выполнить те или иные дела':
        dct_type['Творческий труд'] += 1

    # 9
    if row[8] == 'Я отношусь к работе как к необходимому условию для того, чтобы обеспечить себе достойную жизнь в нерабочее время':
        dct_type['Исполнительский труд'] += 1
    elif row[8] == 'Я не склонен противопоставлять работу и другие жизненные сферы; для меня трудиться — это и значит жить':
        dct_type['Творческий труд'] += 1

    # 10
    if row[9] == 'Моя работа завершается в момент окончания рабочего дня, я больше не вспоминаю о ней, пока не настанет следующий рабочий день':
        dct_type['Исполнительский труд'] += 1
    elif row[9] == 'Даже когда мой трудовой день закончен, в мыслях я периодически возвращаюсь к рабочим проблемам':
        dct_type['Творческий труд'] += 1

    # 11
    if row[10] == 'Работа для меня — это средство достижения других жизненных целей (заработать на что-то, повысить свой статус в глазах других людей и т.п.)':
        dct_type['Исполнительский труд'] += 1
    elif row[10] == 'Работа ценна для меня именно сама по себе, а не только в связи с теми возможностями, которые она даёт (например, с заработками)':
        dct_type['Творческий труд'] += 1

    # 12
    if row[11] == 'Окажись в моём распоряжении достаточно денег (например, благодаря наследству), я не работал бы, а проводил время как-нибудь иначе':
        dct_type['Исполнительский труд'] += 1
    elif row[11] == 'Я всё равно продолжил бы трудиться, даже если бы в моём распоряжении оказалась крупная сумма денег, позволяющая обеспеченно жить, не работая':
        dct_type['Творческий труд'] += 1


    # сортируем по убыванию
    result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
    begin_str = '\n'
    # создаем строку с результатами
    for sphere, value in result_lst:
        begin_str += f'{sphere}: {value};\n'

    # добавляем описание
    return begin_str


def calc_level_sitt(row):
    """
    Функция для подсчета уровня склонности
    """
    if row[0] == 'Исполнительский труд':
        if 0 <= row[1] <= 1:
            return 'такая работа активно отвергается'
        elif 2 <=  row[1] <= 3:
            return 'склонность не выражена'
        elif 4 <=  row[1] <= 6:
            return 'склонность на среднем уровне'
        elif 7 <=  row[1] <= 9:
            return 'выраженная склонность'
        elif 10 <=  row[1] <= 12:
            return 'ярко выраженная склонность'

    elif row[0] == 'Творческий труд':
        if 0 <= row[1] <= 2:
            return 'такая работа активно отвергается'
        elif 3 <=  row[1] <= 5:
            return 'склонность не выражена'
        elif 6 <=  row[1] <= 8:
            return 'склонность на среднем уровне'
        elif 9 <=  row[1] <= 10:
            return 'выраженная склонность'
        elif 11 <=  row[1] <= 12:
            return 'ярко выраженная склонность'


def create_result_azbel_sitt(base_df:pd.DataFrame, out_dct:dict, lst_svod_cols:list):
    """
    Функция для подсчета результата если указаны колонки по которым нужно провести свод
    :param df: датафрейм с результатами
    :param out_dct: словарь с уже подсчитанными базовыми данными
    :param lst_svod_cols: список сводных колонок
    :return: словарь
    """
    lst_level = ['такая работа активно отвергается', 'склонность не выражена',
                 'склонность на среднем уровне',
                 'выраженная склонность'
                 ]

    lst_sphere = ['Исполнительский труд', 'Творческий труд'
                  ]

    lst_reindex_one_level_cols = lst_svod_cols.copy()
    lst_reindex_one_level_cols.extend( ['такая работа активно отвергается', 'склонность не выражена',
             'склонность на среднем уровне',
             'выраженная склонность','Итого'])

    lst_reindex_one_sphere_cols = lst_svod_cols.copy()
    lst_reindex_one_sphere_cols.extend( ['Исполнительский труд', 'Творческий труд','Итого'])

    svod_count_one_level_df = calc_count_scale(base_df, lst_svod_cols,
                                               'Значение_ведущего_типа',
                                               'Уровень_выраженности',
                                               lst_reindex_one_level_cols, lst_level)

    svod_count_one_sphere_df = calc_count_scale(base_df, lst_svod_cols,
                                                'Значение_ведущего_типа',
                                                'Ведущий_тип',
                                                lst_reindex_one_sphere_cols, lst_sphere)

    # Считаем среднее по субшкалам
    svod_mean_one_df = pd.pivot_table(base_df,
                                      index=lst_svod_cols,
                                      values=['Значение_ведущего_типа',
                                              ],
                                      aggfunc=round_mean)
    svod_mean_one_df.reset_index(inplace=True)
    # упорядочиваем колонки
    new_order_cols = lst_svod_cols.copy()
    new_order_cols.extend((['Значение_ведущего_типа',
                            ]))
    svod_mean_one_df = svod_mean_one_df.reindex(columns=new_order_cols)

    dct_rename_cols_mean = {'Значение_ведущего_типа': 'Среднее значение ведущего типа',
                            }
    svod_mean_one_df.rename(columns=dct_rename_cols_mean, inplace=True)

    # очищаем название колонки по которой делали свод
    out_name_lst = []

    for name_col in lst_svod_cols:
        name = re.sub(r'[\[\]\'+()<> :"?*|\\/]', '_', name_col)
        if len(lst_svod_cols) == 1:
            out_name_lst.append(name[:14])
        elif len(lst_svod_cols) == 2:
            out_name_lst.append(name[:7])
        else:
            out_name_lst.append(name[:4])

    out_name = ' '.join(out_name_lst)
    if len(out_name) > 14:
        out_name = out_name[:14]

    out_dct.update({f'Ср {out_name}': svod_mean_one_df,
                    f'Уровень {out_name}': svod_count_one_level_df,
                    f'Тип {out_name}': svod_count_one_sphere_df,
                    })

    if len(lst_svod_cols) == 1:
        return out_dct
    else:
        for idx, name_column in enumerate(lst_svod_cols):
            lst_reindex_column_level_cols = [lst_svod_cols[idx], 'такая работа активно отвергается', 'склонность не выражена',
             'склонность на среднем уровне',
             'выраженная склонность','Итого']

            lst_reindex_column_sphere_cols = [lst_svod_cols[idx], 'Исполнительский труд', 'Творческий труд','Итого']

            svod_count_column_level_df = calc_count_scale(base_df, lst_svod_cols[idx],
                                                          'Значение_ведущего_типа',
                                                          'Уровень_выраженности',
                                                          lst_reindex_column_level_cols, lst_level)

            svod_count_column_sphere_df = calc_count_scale(base_df, lst_svod_cols[idx],
                                                           'Значение_ведущего_типа',
                                                           'Ведущий_тип',
                                                           lst_reindex_column_sphere_cols, lst_sphere)

            # Считаем среднее по субшкалам
            svod_mean_column_df = pd.pivot_table(base_df,
                                                 index=[lst_svod_cols[idx]],
                                                 values=['Значение_ведущего_типа',
                                                         ],
                                                 aggfunc=round_mean)
            svod_mean_column_df.reset_index(inplace=True)
            # упорядочиваем колонки
            new_order_cols = [lst_svod_cols[idx]].copy()
            new_order_cols.extend((['Значение_ведущего_типа',
                                    ]))
            svod_mean_column_df = svod_mean_column_df.reindex(columns=new_order_cols)

            dct_rename_cols_mean = {'Значение_ведущего_типа': 'Среднее значение ведущего типа',
                                    }
            svod_mean_column_df.rename(columns=dct_rename_cols_mean, inplace=True)


            name_column = lst_svod_cols[idx]
            name_column = re.sub(r'[\[\]\'+()<> :"?*|\\/]', '_', name_column)
            name_column = name_column[:15]

            out_dct.update({f'Ср {name_column}': svod_mean_column_df,
                            f'Уровень {name_column}': svod_count_column_level_df,
                            f'Тип {name_column}': svod_count_column_sphere_df,
                            })
        return out_dct






def processing_azbel_sitt(base_df: pd.DataFrame, answers_df: pd.DataFrame,lst_svod_cols:list):
    """
    Функция для обработки
    :param base_df: часть датафрейма с описательными колонками
    :param answers_df: часть датафрейма с ответами
    :param lst_svod_cols:  список с колонками по которым нужно делать свод
    """
    try:
        out_answer_df = base_df.copy()  # делаем копию для последующего соединения с сырыми ответами
        if answers_df.shape[1] != 12:
            raise BadCountColumnsSITT

        answers_df.columns = [f'Вопрос {i}' for i in range(1, 13)]
        # делаем список списков
        valid_values = [[
                            'Моя работа такова, что умение хорошо выполнять её и чёткое соблюдение правил гарантированно приведут к предсказуемому результату',
                            'Даже если я выполняю свою работу качественно, я не могу точно предсказать её результаты'],
                        ['Способы и методы выполнения моей работы очень многообразны, я сам ответственен за их выбор',
                         'Способы выполнения моей работы более-менее стандартны, известны заранее'],
                        ['Что и как мне делать, определяет начальство, моя задача — пунктуально исполнять распоряжения',
                         'Моя работа не подразумевает чётких инструкций, приходится постоянно размышлять о том, как действовать'],
                        [
                            'Я готов заниматься такой работой, которая требует постоянных затрат времени и сил для дальнейшего обучения, профессионального самосовершенствования',
                            'Я хотел бы выучиться какой-либо профессии, а потом спокойно зарабатывать деньги, больше не тратя времени и сил на дальнейшее обучение'],
                        ['Моё отношение к работе описывается пословицей «Лучше синица в руках, чем журавль в небе»',
                         'Моё отношение к работе точнее передаёт фраза «Лучше охотиться за журавлём в небе, чем иметь синицу в руках»'],
                        [
                            'Мне важно, чтобы на работе была постоянная возможность для профессионального развития, пусть даже в ущерб стабильности',
                            'Главное, чтобы работа и заработки были стабильными; возможность развиваться в профессиональной сфере для меня не столь важна'],
                        [
                            'Хотелось бы иметь гарантированную оплату труда, соответствующую времени и силам, которые я трачу на работу',
                            'Оплачиваться должен исключительно результат работы, а не потраченное на его достижение время и усилия'],
                        [
                            'Далеко не все моё рабочее время подчинено чёткому расписанию, в значительной степени я сам определяю, когда и где выполнить те или иные дела',
                            'График моей работы подчинён чёткому расписанию: я всегда знаю, где и когда я должен находиться и что именно делать'],
                        [
                            'Я отношусь к работе как к необходимому условию для того, чтобы обеспечить себе достойную жизнь в нерабочее время',
                            'Я не склонен противопоставлять работу и другие жизненные сферы; для меня трудиться — это и значит жить'],
                        ['Даже когда мой трудовой день закончен, в мыслях я периодически возвращаюсь к рабочим проблемам',
                         'Моя работа завершается в момент окончания рабочего дня, я больше не вспоминаю о ней, пока не настанет следующий рабочий день'],
                        [
                            'Работа для меня — это средство достижения других жизненных целей (заработать на что-то, повысить свой статус в глазах других людей и т.п.)',
                            'Работа ценна для меня именно сама по себе, а не только в связи с теми возможностями, которые она даёт (например, с заработками)'],
                        [
                            'Я всё равно продолжил бы трудиться, даже если бы в моём распоряжении оказалась крупная сумма денег, позволяющая обеспеченно жить, не работая',
                            'Окажись в моём распоряжении достаточно денег (например, благодаря наследству), я не работал бы, а проводил время как-нибудь иначе']
                        ]

        lst_error_answers = []  # список для хранения строк где найдены неправильные ответы

        for idx, lst_values in enumerate(valid_values):
            mask = ~answers_df.iloc[:, idx].isin(lst_values)  # проверяем на допустимые значения
            # Получаем строки с отличающимися значениями
            result_check = answers_df.iloc[:, idx][mask]

            if len(result_check) != 0:
                error_row = list(map(lambda x: x + 2, result_check.index))
                error_row = list(map(str, error_row))
                error_row_lst = [f'В {idx + 1} вопросной колонке на строке {value}' for value in error_row]
                error_in_column = ','.join(error_row_lst)
                lst_error_answers.append(error_in_column)

        if len(lst_error_answers) != 0:
            error_message = ';'.join(lst_error_answers)
            raise BadValueSITT

        base_df[f'Распределение'] = answers_df.apply(processing_result_sitt, axis=1)
        base_df[f'Ведущий_тип'] = base_df[f'Распределение'].apply(
            extract_key_max_value)
        base_df[f'Значение_ведущего_типа'] = base_df[f'Распределение'].apply(
            extract_max_value)
        base_df[f'Уровень_выраженности'] = base_df[['Ведущий_тип', 'Значение_ведущего_типа']].apply(lambda x: calc_level_sitt(x), axis=1)

        # Создаем датафрейм для создания части в общий датафрейм
        part_df = pd.DataFrame()
        part_df['СИТТ_Распределение'] = base_df['Распределение']
        part_df['СИТТ_Ведущий_тип'] = base_df['Ведущий_тип']
        part_df['СИТТ_Тип_Значение'] = base_df['Значение_ведущего_типа']
        part_df['СИТТ_Тип_Уровень'] = base_df['Уровень_выраженности']

        base_df.sort_values(by='Значение_ведущего_типа', ascending=False, inplace=True)  # сортируем
        out_answer_df = pd.concat([out_answer_df, answers_df], axis=1)  # Датафрейм для проверки

        # Создаем строку с описанием
        description_result = """
        Шкала оценки результатов
        Исполнительский труд:
        10-12 баллов - ярко выраженная склонность;
        7-9 баллов – выраженная склонность;
        4-6 баллов – склонность на среднем уровне;
        2-3 балла – склонность не выражена;
        0-1 баллов – такая работа активно отвергается.
    
        Творческий труд:
        11-12 баллов - ярко выраженная склонность;
        9-10 баллов – выраженная склонность;
        6-8 баллов – склонность на среднем уровне;
        3-5 балла – склонность не выражена;
        0-2 балла – такая работа активно отвергается.
    
        Исполнительский труд подразумевает, что работник будет действовать в более или менее предсказуемых ситуациях по чётко заданным правилам, инструкциям. Типичные примеры таких профессий: кассир, бухгалтер, работник справочной службы. Когда человек занимается подобной работой, проявления творчества с его стороны оказываются нежелательными, а иногда даже опасными. Представь себе, к чему может привести ситуация, когда медсестра, вместо того чтобы чётко выполнять назначения врача и строго придерживаться инструкций по приготовлению препаратов для внутривенных инъекций, погрузится в творческий поиск и начнёт испытывать на больном новые способы приготовления лекарств.\n
        Творческие профессии подразумевают значительную свободу действий, так как работать приходится в ситуациях неопределённости. В них нет, да и не может быть чётких инструкций, которые однозначно предопределяли бы способы выполнения работы. Например, когда режиссёр работает над очередным фильмом, никто не даст ему точных «рецептов» для подбора актёров и не предоставит готовых ответов на все те бесчисленные вопросы, которые возникнут в ходе съёмок. Хотелось бы пояснить: большинство видов работ, в которых нуждается общество, не творческие, а исполнительские. По признаку востребованности именно они находятся на первом месте. Так что если хочешь, чтобы именно тебе досталась творческая работа, нужно уметь делать её очень хорошо и проявлять активность в её поиске.
            """
        # создаем описание результата
        base_df[
            f'Описание_результата'] = 'Склонность к исполнительскому или творческому труду.\nРезультат тестирования:\n' + \
                                      base_df[
                                          f'Распределение'] + description_result
        part_df['СИТТ_Описание_результата'] = base_df[f'Описание_результата']

        # Делаем свод по уровню
        dct_svod_level = {'Значение_ведущего_типа': 'Уровень_выраженности',
                          }
        dct_rename_svod_level = {'Значение_ведущего_типа': 'Количество',
                                 }
        # Списки для шкал
        lst_level = ['такая работа активно отвергается', 'склонность не выражена',
                     'склонность на среднем уровне',
                     'выраженная склонность'
                     ]
        base_svod_level_df = create_union_svod(base_df, dct_svod_level, dct_rename_svod_level, lst_level)

        # Делаем свод по сфере
        dct_svod_sphere = {'Значение_ведущего_типа': 'Ведущий_тип',
                           }

        dct_rename_svod_sphere = {'Значение_ведущего_типа': 'Количество',
                                  }

        # Списки для шкал
        lst_sphere = ['Исполнительский труд', 'Творческий труд'
                      ]

        base_svod_sphere_df = create_union_svod(base_df, dct_svod_sphere, dct_rename_svod_sphere, lst_sphere)

        # считаем среднее значение
        avg_main = round(base_df['Значение_ведущего_типа'].mean(), 2)

        avg_dct = {'Среднее значение Ведущий тип': avg_main,
                   }

        avg_df = pd.DataFrame.from_dict(avg_dct, orient='index')
        avg_df = avg_df.reset_index()
        avg_df.columns = ['Показатель', 'Среднее значение']

        # формируем основной словарь
        out_dct = {'Списочный результат': base_df, 'Список для проверки': out_answer_df,
                   'Среднее': avg_df,
                   'Свод по уровням': base_svod_level_df,
                   }

        # Листы по уровням
        dct_level = dict()
        for level in lst_level:
            temp_df = base_df[base_df['Уровень_выраженности'] == level]
            if temp_df.shape[0] != 0:
                if level == 'такая работа активно отвергается':
                    level = 'активно отвергается'
                elif level == 'склонность не выражена':
                    level = 'не выражена'
                elif level == 'склонность на среднем уровне':
                    level = 'средне выражена'
                dct_level[level] = temp_df
        out_dct.update(dct_level)

        # Добавляем свод по сферам
        out_dct.update({
            'Свод по типам': base_svod_sphere_df,
        })
        # Листы по сферам
        dct_sphere = dict()
        for sphere in lst_sphere:
            temp_df = base_df[base_df['Ведущий_тип'] == sphere]
            if temp_df.shape[0] != 0:

                dct_sphere[sphere] = temp_df
        out_dct.update(dct_sphere)

        """
                                  Сохраняем в зависимости от необходимости делать своды по определенным колонкам
                                  """
        if len(lst_svod_cols) == 0:
            return out_dct, part_df
        else:
            out_dct = create_result_azbel_sitt(base_df, out_dct, lst_svod_cols)

            return out_dct, part_df

    except BadValueSITT:
        messagebox.showerror('Лахеcис',
                             f'При обработке вопросов теста Склонность к исполнительскому или творческому труду Азбель обнаружены неправильные варианты ответов. Проверьте ответы на указанных строках:\n'
                             f'{error_message[:5000]}\n'
                             f'Используйте при создании Яндекс-формы написание вариантов ответа из руководства пользователя программы Лахесис.')


    except BadCountColumnsSITT:
        messagebox.showerror('Лахеcис',
                             f'Проверьте количество колонок с ответами на тест Склонность к исполнительскому или творческому труду Азбель\n'
                             f'Должно быть 12 колонок с ответами')





