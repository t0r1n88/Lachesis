"""
Скрипт для обработки результатов теста ценностные ориентиры в карьере
"""
import pandas as pd
import re
from tkinter import messagebox
from lachesis_support_functions import convert_to_int,round_mean,sort_name_class

class BadOrderCOK(Exception):
    """
    Исключение для обработки случая когда колонки не совпадают
    """
    pass


class BadValueCOK(Exception):
    """
    Исключение для неправильных значений в вариантах ответов
    """
    pass

class BadCountColumnsCOK(Exception):
    """
    Исключение для обработки случая если количество колонок не равно 41
    """
    pass


def calc_level_cok(value):
    """
    Функция для подсчета уровня склонности к то или иной сфере
    """
    if value <= 4:
        return 'не выраженная карьерная ориентация'
    else:
        return 'выраженная карьерная ориентация'

def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]

def processing_result_cok(row):
    """
Функция для вычисления итогового балла  результатов теста Диагностика ценностных ориентаций в карьере
"""

    # Создаем словарь для хранения данных
    dct_type = {'Профессиональная компетентность': 0, 'Менеджмент': 0, 'Автономия (независимость)': 0,
                'Стабильность работы': 0,
                'Стабильность места жительства': 0, 'Служение': 0, 'Вызов': 0,
                'Интеграция стилей жизни': 0, 'Предпринимательство': 0}
    # 1
    dct_type['Профессиональная компетентность'] += row[0]

    # 2
    dct_type['Менеджмент'] += row[1]

    # 3
    dct_type['Автономия (независимость)'] += row[2]

    # 4
    dct_type['Стабильность работы'] += row[3]

    # 5
    dct_type['Служение'] += row[4]

    # 6
    dct_type['Вызов'] += row[5]

    # 7
    dct_type['Интеграция стилей жизни'] += row[6]

    # 8
    dct_type['Предпринимательство'] += row[7]

    # 9
    dct_type['Профессиональная компетентность'] += row[8]

    # 10
    dct_type['Менеджмент'] += row[9]

    # 11
    dct_type['Автономия (независимость)'] += row[10]

    # 12
    dct_type['Стабильность работы'] += row[11]

    # 13
    dct_type['Служение'] += row[12]

    # 14
    dct_type['Вызов'] += row[13]

    # 15
    dct_type['Интеграция стилей жизни'] += row[14]

    # 16
    dct_type['Предпринимательство'] += row[15]

    # 17
    dct_type['Профессиональная компетентность'] += row[16]

    # 18
    dct_type['Менеджмент'] += row[17]

    # 19
    dct_type['Автономия (независимость)'] += row[18]

    # 20
    dct_type['Стабильность места жительства'] += row[19]

    # 21
    dct_type['Служение'] += row[20]

    # 22
    dct_type['Вызов'] += row[21]

    # 23
    dct_type['Интеграция стилей жизни'] += row[22]

    # 24
    dct_type['Предпринимательство'] += row[23]

    # 25
    dct_type['Профессиональная компетентность'] += row[24]

    # 26
    dct_type['Менеджмент'] += row[25]

    # 27
    dct_type['Автономия (независимость)'] += row[26]

    # 28
    dct_type['Стабильность места жительства'] += row[27]

    # 29
    dct_type['Служение'] += row[28]

    # 30
    dct_type['Вызов'] += row[29]

    # 31
    dct_type['Интеграция стилей жизни'] += row[30]

    # 32
    dct_type['Предпринимательство'] += row[31]

    # 33
    dct_type['Профессиональная компетентность'] += row[32]

    # 34
    dct_type['Менеджмент'] += row[33]

    # 35
    dct_type['Автономия (независимость)'] += row[34]

    # 36
    dct_type['Стабильность работы'] += row[35]

    # 37
    dct_type['Служение'] += row[36]

    # 38
    dct_type['Вызов'] += row[37]

    # 39
    dct_type['Интеграция стилей жизни'] += row[38]

    # 40
    dct_type['Предпринимательство'] += row[39]

    # 41
    dct_type['Стабильность места жительства'] += row[40]

    # Делим на 5 результаты
    for key, value in dct_type.items():
        if 'Стабильность' in key:
            dct_type[key] = round(dct_type[key] / 3)
        else:
            dct_type[key] = round(dct_type[key] / 5)
    # Сортируем
    result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)

    begin_str = '\n'
    # создаем строку с результатами
    for sphere, value in result_lst:
        begin_str += f'{sphere}: {value};\n'

    return begin_str






def processing_shein_cok(result_df: pd.DataFrame, answers_df: pd.DataFrame,lst_svod_cols:list):
    """
    Функция для обработки
    :param result_df: часть датафрейма с описательными колонками
    :param answers_df: часть датафрейма с ответами
    :param lst_svod_cols:  список с колонками по которым нужно делать свод
    """
    out_answer_df = result_df.copy()  # делаем копию для последующего соединения с сырыми ответами
    if answers_df.shape[1] != 41:
        raise BadCountColumnsCOK

    # очищаем названия колонок от возможных сочетаний .1 которые добавляет пандас при одинаковых колонках
    clean_df_lst = []
    for name_column in answers_df.columns:
        clean_name = re.sub(r'.\d+$', '', name_column)
        clean_df_lst.append(clean_name)

    answers_df.columns = clean_df_lst

    lst_check_cols = ['Строить свою карьеру в пределах конкретной научной или технической сферы.','Осуществлять наблюдение и контроль над людьми, влиять на них на всех уровнях.',
                      'Иметь возможность делать все по-своему и не быть стесненным правилами какой- либо организации.','Иметь постоянное место работы с гарантированным окладом и социальной защищенностью.',
                      'Употреблять свое умение общаться на пользу людям, помогать другим.','Работать над проблемами, которые представляются почти неразрешимыми.',
                      'Вести такой образ жизни, чтобы интересы семьи и карьеры взаимно уравновешивали друг друга.','Создать и построить нечто, что будет всецело моим произведением или идеей.',
                      'Продолжать работу по своей специальности, чем получить более высокую должность, не связанную с моей специальностью.','Быть первым руководителем в организации.',
                      'Иметь работу, не связанную с режимом или другими организационными ограничениями.','Работать в организации, которая обеспечит мне стабильность на длительный период времени.',
                      'Употребить свои умения и способности на то, чтобы сделать мир лучше.','Соревноваться с другими и побеждать.',
                      'Строить карьеру, которая позволит мне не изменять своему образу жизни.','Создать новое коммерческое предприятие.',
                      'Посвятить всю жизнь избранной профессии.','Занять высокую руководящую должность.',
                      'Иметь работу, которая представляет максимум свободы и автономии в выборе характера занятий, времени выполнения и т.д.','Оставаться на одном месте жительства, чем переехать в связи с повышением.',
                      'Иметь возможность использовать свои умения и таланты для служения важной цели.','Единственная действительная цель моей карьеры – находить и решать трудные проблемы, независимо от того, в какой области они возникли.',
                      'Я всегда стремлюсь уделять одинаковое внимание моей семье и моей карьере.','Я всегда нахожусь в поиске идей, которые дадут мне возможность начать и построить свое собственное дело.',
                      'Я соглашусь на руководящую должность только в том случае, если она находится в сфере моей профессиональной компетенции.','Я хотел бы достичь такого положения в организации, которое давало бы возможность наблюдать за работой других и интегрировать их деятельность.',
                      'В моей профессиональной деятельности я более всего забочусь о своей свободе и автономии.','Для меня важнее остаться на нынешнем месте жительства, чем получить повышение или новую работу в другой деятельности.',
                      'Я всегда искал работу, на которой мог бы приносить пользу другим.','Соревнование и выигрыш – это наиболее важные и волнующие стороны моей карьеры.',
                      'Карьера имеет смысл только в том случае, если она позволяет вести жизнь, которая мне нравится.','Предпринимательская деятельность составляет центральную часть моей карьеры.',
                      'Я бы скорее ушел из организации, чем стал заниматься работой, не связанной с моей профессией.','Я буду считать, что достиг успеха в карьере только тогда, когда стану руководителем высокого уровня в солидной организации.',
                      'Я не хочу, чтобы меня стесняла какая-нибудь организация или мир бизнеса.','Я бы предпочел работать в организации, которая обеспечивает длительный контракт.',
                      'Я бы хотел посвятить свою карьеру достижению важной и полезной цели.','Я чувствую себя преуспевающим только тогда, когда я постоянно вовлечен в решение трудных проблем или в ситуацию соревнования.',
                      'Выбрать и поддерживать определенный образ жизни важнее, чем добиваться успеха в карьере.','Я всегда хотел основать и построить свой собственный бизнес.',
                      'Я предпочитаю работу, которая не связана с командировками.'
                      ]
    # Проверяем порядок колонок
    order_main_columns = lst_check_cols  # порядок колонок и названий как должно быть
    order_temp_df_columns = list(answers_df.columns)  # порядок колонок проверяемого файла
    error_order_lst = []  # список для несовпадающих пар
    # Сравниваем попарно колонки
    for main, temp in zip(order_main_columns, order_temp_df_columns):
        if main != temp:
            error_order_lst.append(f'На месте колонки {main} находится колонка {temp}')
            error_order_message = ';'.join(error_order_lst)
    if len(error_order_lst) != 0:
        raise BadOrderCOK

    answers_df = answers_df.applymap(convert_to_int)  # приводим к инту

    # проверяем правильность
    valid_values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    # Проверяем, есть ли значения, отличающиеся от указанных в списке
    lst_error_answers = []  # список для хранения строк где найдены неправильные ответы

    for i in range(41):
        mask = ~answers_df.iloc[:, i].isin(valid_values)  # проверяем на допустимые значения
        result_check = answers_df.iloc[:, i][mask]
        if len(result_check) != 0:
            error_row = list(map(lambda x: x + 2, result_check.index))
            error_row = list(map(str, error_row))
            error_row_lst = [f'В {i + 1} вопросной колонке на строке {value}' for value in error_row]
            error_in_column = ','.join(error_row_lst)
            lst_error_answers.append(error_in_column)

    if len(lst_error_answers) != 0:
        error_message = ';'.join(lst_error_answers)
        raise BadValueCOK






