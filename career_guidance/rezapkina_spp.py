"""
Скрипт для обработки результатов теста Сфера профессиональных предпочтений
"""
import pandas as pd
import re
from tkinter import messagebox
from lachesis_support_functions import round_mean,create_union_svod,calc_count_scale

class BadOrderSPP(Exception):
    """
    Исключение для обработки случая когда колонки не совпадают
    """
    pass


class BadValueSPP(Exception):
    """
    Исключение для неправильных значений в вариантах ответов
    """
    pass


class BadCountColumnsSPP(Exception):
    """
    Исключение для обработки случая если количество колонок не равно 24
    """
    pass


def calc_level_spp(value):
    """
    Функция для подсчета уровня склонности к то или иной сфере
    """
    if 0 <= value <= 3:
        return 'профессиональная склонность не выражена'
    elif 4 <= value <= 6:
        return 'слабо выраженная профессиональная склонность'
    elif 7 <= value <= 9:
        return 'средне выраженная профессиональная склонность'
    elif 10 <= value <= 12:
        return 'ярко выраженная профессиональная склонность'


def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]


def processing_result_spp(row):
    """
    Обработка результатов тестирования
    """

    # Создаем словарь для хранения данных
    dct_type = {'сфера работы с людьми': 0, 'сфера умственного труда': 0, 'сфера технических интересов': 0,
                'сфера эстетики и искусства': 0,
                'сфера физического труда, подвижной деятельности': 0,
                'сфера материальных интересов, планово-экономических видов работ': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении

    # 1
    if row[0] == 'общаться с самыми разными людьми':
        dct_type['сфера работы с людьми'] += 1
    elif row[0] == 'что-нибудь делать своими руками – мебель, одежду, машины и т.д.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[0] == 'снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[общаться с самыми разными людьми], [что-нибудь делать своими руками – мебель, одежду, машины и т.д.], [снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.]'

    # 2
    if row[1] == 'художественная форма, мастерство писателя или режиссера':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[1] == 'сюжет, действие героев':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[1] == 'информация, которая может пригодиться в жизни':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[художественная форма, мастерство писателя или режиссера], [сюжет, действие героев], [информация, которая может пригодиться в жизни]'

    # 3
    if row[2] == 'в области науки':
        dct_type['сфера умственного труда'] += 1
    elif row[2] == 'за общественную деятельность':
        dct_type['сфера работы с людьми'] += 1
    elif row[2] == 'в области искусства':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[в области науки], [за общественную деятельность], [в области искусства]'

    # 4
    if row[3] == 'управляющим банка':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[3] == 'главным инженером на производстве':
        dct_type['сфера технических интересов'] += 1
    elif row[3] == 'начальником экспедиции':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[управляющим банка], [главным инженером на производстве], [начальником экспедиции]'

    # 5
    if row[4] == 'достижения науки':
        dct_type['сфера умственного труда'] += 1
    elif row[4] == 'развитие производства':
        dct_type['сфера технических интересов'] += 1
    elif row[4] == 'взаимопонимание среди людей':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[достижения науки], [развитие производства], [взаимопонимание среди людей]'

    # 6
    if row[5] == 'благоустройством школы (столовая, спортзал, компьютеры)':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[5] == 'созданием дружного, сплоченного коллектива':
        dct_type['сфера работы с людьми'] += 1
    elif row[5] == 'разработкой новых технологий обучения':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[благоустройством школы (столовая, спортзал, компьютеры)], [созданием дружного, сплоченного коллектива], [разработкой новых технологий обучения]'

    # 7
    if row[6] == 'внешний вид экспонатов (цвет, форма)':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[6] == 'внутреннее устройство экспонатов (механизм)':
        dct_type['сфера умственного труда'] += 1
    elif row[6] == 'практическое применение экспонатов':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[внешний вид экспонатов (цвет, форма)], [внутреннее устройство экспонатов (механизм)], [практическое применение экспонатов]'

    # 8
    if row[7] == 'мужество, смелость, выносливость':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[7] == 'дружелюбие, чуткость, отзывчивость':
        dct_type['сфера работы с людьми'] += 1
    elif row[7] == 'ответственность, аккуратность':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[мужество, смелость, выносливость], [дружелюбие, чуткость, отзывчивость], [ответственность, аккуратность]'

    # 9
    if row[8] == 'писать стихи или музыку или рисовать':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[8] == 'ставить различные опыты':
        dct_type['сфера умственного труда'] += 1
    elif row[8] == 'тренироваться':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[писать стихи или музыку или рисовать], [ставить различные опыты], [тренироваться]'

    # 10
    if row[9] == 'экстремальный туризм (альпинизм, виндсерфинг, горные лыжи)':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[9] == 'деловое общение':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[9] == 'возможность знакомства с историей и культурой другой страны':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[экстремальный туризм (альпинизм, виндсерфинг, горные лыжи)], [деловое общение], [возможность знакомства с историей и культурой другой страны]'

    # 11
    if row[10] == 'о машине нового типа':
        dct_type['сфера технических интересов'] += 1
    elif row[10] == 'о новой научной теории':
        dct_type['сфера умственного труда'] += 1
    elif row[10] == 'о человеческих взаимоотношениях':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[о машине нового типа], [о новой научной теории], [о человеческих взаимоотношениях]'

    # 12
    if row[11] == 'технический':
        dct_type['сфера технических интересов'] += 1
    elif row[11] == 'музыкальный':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[11] == 'спортивный':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[технический], [музыкальный], [спортивный]'

    # 13
    if row[12] == 'улучшению взаимопонимания между учителями и учениками':
        dct_type['сфера работы с людьми'] += 1
    elif row[12] == 'поддержанию здоровья учащихся, занятиям спортом':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[12] == 'укреплению дисциплины':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[улучшению взаимопонимания между учителями и учениками], [поддержанию здоровья учащихся, занятиям спортом], [укреплению дисциплины]'

    # 14
    if row[13] == 'научно-популярные фильмы':
        dct_type['сфера умственного труда'] += 1
    elif row[13] == 'программы о культуре и спорте':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[13] == 'спортивные программы':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[научно-популярные фильмы], [программы о культуре и спорте], [спортивные программы]'

    # 15
    if row[14] == 'с машинами, механизмами':
        dct_type['сфера технических интересов'] += 1
    elif row[14] == 'с объектами природы':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[14] == 'с детьми или сверстниками':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[с машинами, механизмами], [с объектами природы], [с детьми или сверстниками]'

    # 16
    if row[15] == 'давать знания и умения':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[15] == 'учить общению с другими людьми':
        dct_type['сфера работы с людьми'] += 1
    elif row[15] == 'обучать навыкам работы':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[давать знания и умения], [учить общению с другими людьми], [обучать навыкам работы]'

    # 17
    if row[16] == 'вести здоровый образ жизни':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[16] == 'иметь возможность заниматься творчеством':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[16] == 'иметь удобные бытовые условия':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[вести здоровый образ жизни], [иметь возможность заниматься творчеством], [иметь удобные бытовые условия]'

    # 18
    if row[17] == 'защита интересов и прав граждан':
        dct_type['сфера работы с людьми'] += 1
    elif row[17] == 'забота о материальном благополучии людей':
        dct_type['сфера технических интересов'] += 1
    elif row[17] == 'наука и технический прогресс':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[защита интересов и прав граждан], [забота о материальном благополучии людей], [наука и технический прогресс]'

    # 19
    if row[18] == 'физкультуры':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[18] == 'математики':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[18] == 'труда':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[физкультуры], [математики], [труда]'

    # 20
    if row[19] == 'планировать производство продукции':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[19] == 'изготавливать изделия':
        dct_type['сфера технических интересов'] += 1
    elif row[19] == 'заниматься сбытом продукции':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[планировать производство продукции], [изготавливать изделия], [заниматься сбытом продукции]'

    # 21
    if row[20] == 'о выдающихся ученых и их открытиях':
        dct_type['сфера умственного труда'] += 1
    elif row[20] == 'о творчестве ученых и музыкантов':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[20] == 'об интересных изобретениях':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №21'] = f'Полученное значение-{row[20]} не совпадает с эталонными:[о выдающихся ученых и их открытиях], [о творчестве ученых и музыкантов], [об интересных изобретениях]'

    # 22
    if row[21] == 'делая что-то по хозяйству':
        dct_type['сфера технических интересов'] += 1
    elif row[21] == 'с книгой':
        dct_type['сфера умственного труда'] += 1
    elif row[21] == 'на выставках, концертах и пр.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №22'] = f'Полученное значение-{row[21]} не совпадает с эталонными:[делая что-то по хозяйству], [с книгой], [на выставках, концертах и пр.]'

    # 23
    if row[22] == 'о художественной выставке':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[22] == 'о ситуации на фондовой бирже':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[22] == 'о научном открытии':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №23'] = f'Полученное значение-{row[22]} не совпадает с эталонными:[о художественной выставке], [о ситуации на фондовой бирже], [о научном открытии]'

    # 24
    if row[23] == 'в помещении, где много людей':
        dct_type['сфера работы с людьми'] += 1
    elif row[23] == 'в необычных условиях':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[23] == 'в обычном кабинете':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №24'] = f'Полученное значение-{row[23]} не совпадает с эталонными:[в помещении, где много людей], [в необычных условиях], [в обычном кабинете]'

    # проверяем на ошибки
    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # сортируем по убыванию
        result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
        begin_str = '\n'
        # создаем строку с результатами
        for sphere, value in result_lst:
            begin_str += f'{sphere}: {value};\n'

        # добавляем описание
        return begin_str






def create_result_rezapkina_spp(base_df:pd.DataFrame, out_dct:dict, lst_svod_cols:list):
    """
    Функция для подсчета результата если указаны колонки по которым нужно провести свод
    :param df: датафрейм с результатами
    :param out_dct: словарь с уже подсчитанными базовыми данными
    :param lst_svod_cols: список сводных колонок
    :return: словарь
    """
    lst_level = ['профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
                 'средне выраженная профессиональная склонность',
                 'ярко выраженная профессиональная склонность'
                 ]

    lst_sphere = ['сфера работы с людьми', 'сфера умственного труда', 'сфера технических интересов',
                  'сфера эстетики и искусства',
                  'сфера физического труда, подвижной деятельности',
                  'сфера материальных интересов, планово-экономических видов работ'
                  ]

    lst_reindex_one_level_cols = lst_svod_cols.copy()
    lst_reindex_one_level_cols.extend( ['профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
             'средне выраженная профессиональная склонность',
             'ярко выраженная профессиональная склонность',
                                                      'Итого'])

    lst_reindex_one_sphere_cols = lst_svod_cols.copy()
    lst_reindex_one_sphere_cols.extend( ['сфера работы с людьми', 'сфера умственного труда', 'сфера технических интересов',
              'сфера эстетики и искусства',
              'сфера физического труда, подвижной деятельности',
              'сфера материальных интересов, планово-экономических видов работ','Итого'])

    svod_count_one_level_df = calc_count_scale(base_df, lst_svod_cols,
                                               'Значение_ведущей_склонности',
                                               'Уровень_выраженности',
                                               lst_reindex_one_level_cols,lst_level)

    svod_count_one_sphere_df = calc_count_scale(base_df, lst_svod_cols,
                                                 'Значение_ведущей_склонности',
                                                 'Ведущая_склонность',
                                                 lst_reindex_one_sphere_cols,lst_sphere)

    # Считаем среднее по субшкалам
    svod_mean_one_df = pd.pivot_table(base_df,
                                      index=lst_svod_cols,
                                      values=['Значение_ведущей_склонности',
                                              ],
                                      aggfunc=round_mean)
    svod_mean_one_df.reset_index(inplace=True)
    # упорядочиваем колонки
    new_order_cols = lst_svod_cols.copy()
    new_order_cols.extend((['Значение_ведущей_склонности',
                            ]))
    svod_mean_one_df = svod_mean_one_df.reindex(columns=new_order_cols)

    dct_rename_cols_mean = {'Значение_ведущей_склонности': 'Среднее значение ведущей склонности',
                            }
    svod_mean_one_df.rename(columns=dct_rename_cols_mean, inplace=True)

    # очищаем название колонки по которой делали свод
    out_name_lst = []

    for name_col in lst_svod_cols:
        name = re.sub(r'[\[\]\'+()<> :"?*|\\/]', '_', name_col)
        if len(lst_svod_cols) == 1:
            out_name_lst.append(name[:14])
        elif len(lst_svod_cols) == 2:
            out_name_lst.append(name[:7])
        else:
            out_name_lst.append(name[:4])

    out_name = ' '.join(out_name_lst)
    if len(out_name) > 14:
        out_name = out_name[:14]

    out_dct.update({f'Ср {out_name}': svod_mean_one_df,
                    f'Уровень {out_name}': svod_count_one_level_df,
                    f'Скл-ть {out_name}': svod_count_one_sphere_df,
                    })

    if len(lst_svod_cols) == 1:
        return out_dct
    else:
        for idx, name_column in enumerate(lst_svod_cols):
            lst_reindex_column_level_cols = [lst_svod_cols[idx], 'профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность',
             'средне выраженная профессиональная склонность',
             'ярко выраженная профессиональная склонность',
                                             'Итого']

            lst_reindex_column_sphere_cols = [lst_svod_cols[idx], 'сфера работы с людьми', 'сфера умственного труда', 'сфера технических интересов',
                  'сфера эстетики и искусства',
                  'сфера физического труда, подвижной деятельности',
                  'сфера материальных интересов, планово-экономических видов работ','Итого']

            svod_count_column_level_df = calc_count_scale(base_df, lst_svod_cols[idx],
                                                          'Значение_ведущей_склонности',
                                                          'Уровень_выраженности',
                                                          lst_reindex_column_level_cols, lst_level)

            svod_count_column_sphere_df = calc_count_scale(base_df, lst_svod_cols[idx],
                                                           'Значение_ведущей_склонности',
                                                           'Ведущая_склонность',
                                                           lst_reindex_column_sphere_cols, lst_sphere)

            # Считаем среднее по субшкалам
            svod_mean_column_df = pd.pivot_table(base_df,
                                                 index=[lst_svod_cols[idx]],
                                                 values=['Значение_ведущей_склонности',
                                                         ],
                                                 aggfunc=round_mean)
            svod_mean_column_df.reset_index(inplace=True)
            # упорядочиваем колонки
            new_order_cols = [lst_svod_cols[idx]].copy()
            new_order_cols.extend((['Значение_ведущей_склонности',
                                    ]))
            svod_mean_column_df = svod_mean_column_df.reindex(columns=new_order_cols)

            dct_rename_cols_mean = {'Значение_ведущей_склонности': 'Среднее значение ведущей склонности',
                                    }
            svod_mean_column_df.rename(columns=dct_rename_cols_mean, inplace=True)


            name_column = lst_svod_cols[idx]
            name_column = re.sub(r'[\[\]\'+()<> :"?*|\\/]', '_', name_column)
            name_column = name_column[:15]

            out_dct.update({f'Ср {name_column}': svod_mean_column_df,
                            f'Уровень {name_column}': svod_count_column_level_df,
                            f'Скл-ть {name_column}': svod_count_column_sphere_df,
                            })
        return out_dct





def processing_rezapkina_spp(base_df: pd.DataFrame, answers_df: pd.DataFrame,lst_svod_cols:list):
    """
    Функция для обработки
    :param base_df: часть датафрейма с описательными колонками
    :param answers_df: часть датафрейма с ответами
    :param lst_svod_cols:  список с колонками по которым нужно делать свод
    """
    try:
        out_answer_df = base_df.copy()  # делаем копию для последующего соединения с сырыми ответами
        if len(answers_df.columns) != 24:
            raise BadCountColumnsSPP

        lst_check_cols = ['Мне хотелось бы в своей профессиональной деятельности',
                          'В книге или кинофильме меня больше всего привлекает',
                          'Меня обрадует Нобелевская премия', 'Я скорее соглашусь стать',
                          'Будущее людей определяют', 'На месте директора школы я прежде всего займусь',
                          'На технической выставке меня больше всего привлечет', 'В людях я ценю прежде всего',
                          'В свободное от работы время я буду', 'В заграничных поездках меня больше всего привлечет',
                          'Мне интереснее беседовать', 'Если бы в моей школе было всего три кружка, я бы выбрал(а)',
                          'В школе больше внимания следует уделять', 'Я с большим интересом смотрю',
                          'Мне было бы интереснее работать', 'Школа в первую очередь должна',
                          'Каждый человек должен', 'Для благополучия общества в первую очередь необходима',
                          'Мне больше всего нравятся уроки', 'Мне интереснее было бы',
                          'Я предпочитаю читать статьи', 'Свободное время я охотнее провожу',
                          'Больший интерес у меня вызовет сообщение', 'Я предпочитаю работать',
                          ]

        # Проверяем порядок колонок
        order_main_columns = lst_check_cols  # порядок колонок и названий как должно быть
        order_temp_df_columns = list(answers_df.columns)  # порядок колонок проверяемого файла
        error_order_lst = []  # список для несовпадающих пар
        # Сравниваем попарно колонки
        for main, temp in zip(order_main_columns, order_temp_df_columns):
            if main != temp:
                error_order_lst.append(f'На месте колонки {main} находится колонка {temp}')
                error_order_message = ';'.join(error_order_lst)
        if len(error_order_lst) != 0:
            raise BadOrderSPP

        valid_values = [
            ['общаться с самыми разными людьми', 'что-нибудь делать своими руками – мебель, одежду, машины и т.д.',
             'снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.'],
            ['художественная форма, мастерство писателя или режиссера', 'сюжет, действие героев',
             'информация, которая может пригодиться в жизни'],
            ['в области науки', 'за общественную деятельность', 'в области искусства'],
            ['управляющим банка', 'главным инженером на производстве', 'начальником экспедиции'],
            ['достижения науки', 'развитие производства', 'взаимопонимание среди людей'],
            ['благоустройством школы (столовая, спортзал, компьютеры)', 'созданием дружного, сплоченного коллектива',
             'разработкой новых технологий обучения'],
            ['внешний вид экспонатов (цвет, форма)', 'внутреннее устройство экспонатов (механизм)',
             'практическое применение экспонатов'],
            ['мужество, смелость, выносливость', 'дружелюбие, чуткость, отзывчивость', 'ответственность, аккуратность'],
            ['писать стихи или музыку или рисовать', 'ставить различные опыты', 'тренироваться'],
            ['экстремальный туризм (альпинизм, виндсерфинг, горные лыжи)', 'деловое общение',
             'возможность знакомства с историей и культурой другой страны'],
            ['о машине нового типа', 'о новой научной теории', 'о человеческих взаимоотношениях'],
            ['технический', 'музыкальный', 'спортивный'],
            ['улучшению взаимопонимания между учителями и учениками', 'поддержанию здоровья учащихся, занятиям спортом',
             'укреплению дисциплины'],
            ['научно-популярные фильмы', 'программы о культуре и спорте', 'спортивные программы'],
            ['с машинами, механизмами', 'с объектами природы', 'с детьми или сверстниками'],
            ['давать знания и умения', 'учить общению с другими людьми', 'обучать навыкам работы'],
            ['вести здоровый образ жизни', 'иметь возможность заниматься творчеством', 'иметь удобные бытовые условия'],
            ['защита интересов и прав граждан', 'забота о материальном благополучии людей', 'наука и технический прогресс'],
            ['физкультуры', 'математики', 'труда'],
            ['планировать производство продукции', 'изготавливать изделия', 'заниматься сбытом продукции'],
            ['о выдающихся ученых и их открытиях', 'о творчестве ученых и музыкантов', 'об интересных изобретениях'],
            ['делая что-то по хозяйству', 'с книгой', 'на выставках, концертах и пр.'],
            ['о художественной выставке', 'о ситуации на фондовой бирже', 'о научном открытии'],
            ['в помещении, где много людей', 'в необычных условиях', 'в обычном кабинете'],
            ]

        lst_error_answers = []  # список для хранения строк где найдены неправильные ответы

        for idx, lst_values in enumerate(valid_values):
            mask = ~answers_df.iloc[:, idx].isin(lst_values)  # проверяем на допустимые значения
            # Получаем строки с отличающимися значениями
            result_check = answers_df.iloc[:, idx][mask]

            if len(result_check) != 0:
                error_row = list(map(lambda x: x + 2, result_check.index))
                error_row = list(map(str, error_row))
                error_row_lst = [f'В {idx + 1} вопросной колонке на строке {value}' for value in error_row]
                error_in_column = ','.join(error_row_lst)
                lst_error_answers.append(error_in_column)

        if len(lst_error_answers) != 0:
            error_message = ';'.join(lst_error_answers)
            raise BadValueSPP

        base_df[f'Распределение'] = answers_df.apply(processing_result_spp, axis=1)
        base_df[f'Ведущая_склонность'] = base_df[f'Распределение'].apply(
            extract_key_max_value)
        base_df[f'Значение_ведущей_склонности'] = base_df[f'Распределение'].apply(
            extract_max_value)
        base_df[f'Уровень_выраженности'] = base_df[f'Значение_ведущей_склонности'].apply(
            calc_level_spp)

        # Создаем датафрейм для создания части в общий датафрейм
        part_df = pd.DataFrame()
        part_df['СПП_Распределение'] = base_df['Распределение']
        part_df['СПП_Ведущая_склонность'] = base_df['Ведущая_склонность']
        part_df['СПП_Склонность_Значение'] = base_df['Значение_ведущей_склонности']
        part_df['СПП_Склонность_Уровень'] = base_df['Уровень_выраженности']

        base_df.sort_values(by='Значение_ведущей_склонности', ascending=False, inplace=True)  # сортируем
        out_answer_df = pd.concat([out_answer_df, answers_df], axis=1)  # Датафрейм для проверки

        # Создаем строку с описанием
        description_result = """
        Шкала оценки результатов
        10-12 баллов – ярко выраженная профессиональная склонность;
        7-9 баллов – средне выраженная профессиональная склонность;
        4-6 баллов – слабо выраженная профессиональная склонность;
        0-3 баллов – профессиональная склонность не выражена.
    
        Примеры профессий для каждой сферы
        Сфера работы с людьми: учитель, педагог, экскурсовод, воспитатель,  социолог, психолог, менеджер по персоналу, следователь.
        Сфера умственного труда: ученый-исследователь (математик, физик, химик, кибернетик, археолог, геолог),  инженер, юрист, врач, эколог, архитектор, продюсер.
        Сфера технических интересов:  программист, электротехник, радиотехник, Web-мастер, статистик, водитель, технолог, диспетчер, секретарь-машинистка, телефонист.
        Сфера эстетики и искусства: художник, дизайнер, писатель, поэт,  режиссер, артист, конструктор, косметолог, костюмер, гример, кондитер, портной-кутюрье, цветовод.
        Сфера физического труда,  подвижной деятельности: спортсмен, фотограф, экспедитор, парикмахер,  бармен, официант, стюардесса, продавец, закройщик, специалист по ремонту, кассир, медперсонал, бригадир, кладовщик,  почтальон,  фермер,  водитель-дальнобойщик, полицейский, военный.
        Сфера материальных интересов,  планово-экономических видов работ: экономист, администратор, менеджер, предприниматель, аудитор, специалист по рекламе, брокер, агент страховых компаний, коммерсант, завхоз.
                        """

        # создаем описание результата
        base_df[f'Описание_результата'] = 'Сфера профессиональных предпочтений.\n' + base_df[
            f'Распределение'] + description_result
        part_df['СПП_Описание_результата'] = base_df[f'Описание_результата']

        # Делаем свод по уровню
        dct_svod_level = {'Значение_ведущей_склонности': 'Уровень_выраженности',
                          }
        dct_rename_svod_level = {'Значение_ведущей_склонности': 'Количество',
                                 }
        # Списки для шкал
        lst_level = ['профессиональная склонность не выражена', 'слабо выраженная профессиональная склонность', 'средне выраженная профессиональная склонность',
                     'ярко выраженная профессиональная склонность'
                     ]
        base_svod_level_df = create_union_svod(base_df, dct_svod_level, dct_rename_svod_level, lst_level)

        # Делаем свод по сфере
        dct_svod_sphere = {'Значение_ведущей_склонности': 'Ведущая_склонность',
                           }

        dct_rename_svod_sphere = {'Значение_ведущей_склонности': 'Количество',
                                  }

        # Списки для шкал
        lst_sphere = ['сфера работы с людьми', 'сфера умственного труда', 'сфера технических интересов', 'сфера эстетики и искусства',
                      'сфера физического труда, подвижной деятельности', 'сфера материальных интересов, планово-экономических видов работ'
                      ]

        base_svod_sphere_df = create_union_svod(base_df, dct_svod_sphere, dct_rename_svod_sphere, lst_sphere)

        # считаем среднее значение
        avg_main = round(base_df['Значение_ведущей_склонности'].mean(), 2)

        avg_dct = {'Среднее значение Ведущая склонность': avg_main,
                   }

        avg_df = pd.DataFrame.from_dict(avg_dct, orient='index')
        avg_df = avg_df.reset_index()
        avg_df.columns = ['Показатель', 'Среднее значение']

        # формируем основной словарь
        out_dct = {'Списочный результат': base_df, 'Список для проверки': out_answer_df,
                   'Среднее': avg_df,
                   'Свод по уровням': base_svod_level_df,
                   }

        # Листы по уровням
        dct_level = dict()
        for level in lst_level:
            temp_df = base_df[base_df['Уровень_выраженности'] == level]
            if temp_df.shape[0] != 0:
                if level == 'профессиональная склонность не выражена':
                    level = 'не выражена'
                elif level == 'слабо выраженная профессиональная склонность':
                    level = 'слабо выражена'
                elif level == 'средне выраженная профессиональная склонность':
                    level = 'средне выражена'
                elif level == 'ярко выраженная профессиональная склонность':
                    level = 'ярко выражена'
                dct_level[level] = temp_df
        out_dct.update(dct_level)

        # Добавляем свод по сферам
        out_dct.update({
            'Свод по сферам': base_svod_sphere_df,
        })
        # Листы по сферам
        dct_sphere = dict()
        for sphere in lst_sphere:
            temp_df = base_df[base_df['Ведущая_склонность'] == sphere]
            if temp_df.shape[0] != 0:
                if sphere == 'сфера работы с людьми':
                    sphere = 'работа с людьми'
                elif sphere == 'сфера умственного труда':
                    sphere = 'умственный труд'
                elif sphere == 'сфера технических интересов':
                    sphere = 'технические интересы'
                elif sphere == 'сфера эстетики и искусства':
                    sphere = 'эстетика и искусство'
                elif sphere == 'сфера физического труда, подвижной деятельности':
                    sphere = 'физический труд'
                elif sphere == 'сфера материальных интересов, планово-экономических видов работ':
                    sphere = 'материальные интересы'

                dct_sphere[sphere] = temp_df
        out_dct.update(dct_sphere)

        """
                          Сохраняем в зависимости от необходимости делать своды по определенным колонкам
                          """
        if len(lst_svod_cols) == 0:
            return out_dct, part_df
        else:
            out_dct = create_result_rezapkina_spp(base_df, out_dct, lst_svod_cols)

            return out_dct, part_df

    except BadOrderSPP:
        messagebox.showerror('Лахеcис',
                             f'При обработке вопросов теста Сфера профессиональных предпочтений обнаружены неправильные вопросы. Проверьте названия колонок с вопросами:\n'
                             f'{error_order_message}\n'
                             f'Используйте при создании Яндекс-формы написание вопросов из руководства пользователя программы Лахесис.')
    except BadValueSPP:
        messagebox.showerror('Лахеcис',
                             f'При обработке вопросов теста Сфера профессиональных предпочтений обнаружены неправильные варианты ответов. Проверьте ответы на указанных строках:\n'
                             f'{error_message}\n'
                             f'Используйте при создании Яндекс-формы написание вариантов ответа из руководства пользователя программы Лахесис.')


    except BadCountColumnsSPP:
        messagebox.showerror('Лахеcис',
                             f'Проверьте количество колонок с ответами на тест Сфера профессиональных предпочтений\n'
                             f'Должно быть 24 колонки с ответами')






