"""
Скрипт для обработки теста Склонность к исполнительскому или творческому труду Азбель
"""

import pandas as pd
from tkinter import messagebox
from lachesis_support_functions import round_mean, sort_name_class



class BadValueSITT(Exception):
    """
    Исключение для неправильных значений в вариантах ответов
    """
    pass


class BadCountColumnsSITT(Exception):
    """
    Исключение для обработки случая если количество колонок не равно 12
    """
    pass

def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]



def processing_result_sitt(row):
    """
    Обработка результатов тестирования
    """

    # Создаем словарь для хранения данных
    dct_type = {'Исполнительский труд': 0,
                'Творческий труд': 0}

    # 1
    if row[0] == 'Моя работа такова, что умение хорошо выполнять её и чёткое соблюдение правил гарантированно приведут к предсказуемому результату':
        dct_type['Исполнительский труд'] += 1
    elif row[0] == 'Даже если я выполняю свою работу качественно, я не могу точно предсказать её результаты':
        dct_type['Творческий труд'] += 1

    # 2
    if row[1] == 'Способы выполнения моей работы более-менее стандартны, известны заранее':
        dct_type['Исполнительский труд'] += 1
    elif row[1] == 'Способы и методы выполнения моей работы очень многообразны, я сам ответственен за их выбор':
        dct_type['Творческий труд'] += 1

    # 3
    if row[2] == 'Что и как мне делать, определяет начальство, моя задача — пунктуально исполнять распоряжения':
        dct_type['Исполнительский труд'] += 1
    elif row[2] == 'Моя работа не подразумевает чётких инструкций, приходится постоянно размышлять о том, как действовать':
        dct_type['Творческий труд'] += 1

    # 4
    if row[3] == 'Я хотел бы выучиться какой-либо профессии, а потом спокойно зарабатывать деньги, больше не тратя времени и сил на дальнейшее обучение':
        dct_type['Исполнительский труд'] += 1
    elif row[3] == 'Я готов заниматься такой работой, которая требует постоянных затрат времени и сил для дальнейшего обучения, профессионального самосовершенствования':
        dct_type['Творческий труд'] += 1

    # 5
    if row[4] == 'Моё отношение к работе описывается пословицей «Лучше синица в руках, чем журавль в небе»':
        dct_type['Исполнительский труд'] += 1
    elif row[4] == 'Моё отношение к работе точнее передаёт фраза «Лучше охотиться за журавлём в небе, чем иметь синицу в руках»':
        dct_type['Творческий труд'] += 1

    # 6
    if row[5] == 'Главное, чтобы работа и заработки были стабильными; возможность развиваться в профессиональной сфере для меня не столь важна':
        dct_type['Исполнительский труд'] += 1
    elif row[5] == 'Мне важно, чтобы на работе была постоянная возможность для профессионального развития, пусть даже в ущерб стабильности':
        dct_type['Творческий труд'] += 1

    # 7
    if row[6] == 'Хотелось бы иметь гарантированную оплату труда, соответствующую времени и силам, которые я трачу на работу':
        dct_type['Исполнительский труд'] += 1
    elif row[6] == 'Оплачиваться должен исключительно результат работы, а не потраченное на его достижение время и усилия':
        dct_type['Творческий труд'] += 1

    # 8
    if row[7] == 'График моей работы подчинён чёткому расписанию: я всегда знаю, где и когда я должен находиться и что именно делать':
        dct_type['Исполнительский труд'] += 1
    elif row[7] == 'Далеко не все моё рабочее время подчинено чёткому расписанию, в значительной степени я сам определяю, когда и где выполнить те или иные дела':
        dct_type['Творческий труд'] += 1

    # 9
    if row[8] == 'Я отношусь к работе как к необходимому условию для того, чтобы обеспечить себе достойную жизнь в нерабочее время':
        dct_type['Исполнительский труд'] += 1
    elif row[8] == 'Я не склонен противопоставлять работу и другие жизненные сферы; для меня трудиться — это и значит жить':
        dct_type['Творческий труд'] += 1

    # 10
    if row[9] == 'Моя работа завершается в момент окончания рабочего дня, я больше не вспоминаю о ней, пока не настанет следующий рабочий день':
        dct_type['Исполнительский труд'] += 1
    elif row[9] == 'Даже когда мой трудовой день закончен, в мыслях я периодически возвращаюсь к рабочим проблемам':
        dct_type['Творческий труд'] += 1

    # 11
    if row[10] == 'Работа для меня — это средство достижения других жизненных целей (заработать на что-то, повысить свой статус в глазах других людей и т.п.)':
        dct_type['Исполнительский труд'] += 1
    elif row[10] == 'Работа ценна для меня именно сама по себе, а не только в связи с теми возможностями, которые она даёт (например, с заработками)':
        dct_type['Творческий труд'] += 1

    # 12
    if row[11] == 'Окажись в моём распоряжении достаточно денег (например, благодаря наследству), я не работал бы, а проводил время как-нибудь иначе':
        dct_type['Исполнительский труд'] += 1
    elif row[11] == 'Я всё равно продолжил бы трудиться, даже если бы в моём распоряжении оказалась крупная сумма денег, позволяющая обеспеченно жить, не работая':
        dct_type['Творческий труд'] += 1


    # сортируем по убыванию
    result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
    begin_str = '\n'
    # создаем строку с результатами
    for sphere, value in result_lst:
        begin_str += f'{sphere}: {value};\n'

    # добавляем описание
    return begin_str


def calc_level_sitt(row):
    """
    Функция для подсчета уровня склонности
    """
    if row[0] == 'Исполнительский труд':
        if 0 <= row[1] <= 1:
            return 'такая работа активно отвергается'
        elif 2 <=  row[1] <= 3:
            return 'склонность не выражена'
        elif 4 <=  row[1] <= 6:
            return 'склонность на среднем уровне'
        elif 7 <=  row[1] <= 9:
            return 'выраженная склонность'
        elif 10 <=  row[1] <= 12:
            return 'ярко выраженная склонность'

    elif row[0] == 'Творческий труд':
        if 0 <= row[1] <= 2:
            return 'такая работа активно отвергается'
        elif 3 <=  row[1] <= 5:
            return 'склонность не выражена'
        elif 6 <=  row[1] <= 8:
            return 'склонность на среднем уровне'
        elif 9 <=  row[1] <= 10:
            return 'выраженная склонность'
        elif 11 <=  row[1] <= 12:
            return 'ярко выраженная склонность'

def calc_mean(df:pd.DataFrame,type_calc:str,lst_cat:list,val_cat):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Класс или Номер_класса
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :return:датафрейм
    """
    if type_calc == 'Класс':
        calc_mean_df = pd.pivot_table(df, index=lst_cat,
                                           values=[val_cat],
                                           aggfunc=round_mean)
        calc_mean_df.reset_index(inplace=True)
        calc_mean_df.sort_values(by='Класс', key=lambda x: x.map(sort_name_class), inplace=True)  # сортируем
        calc_mean_df.rename(columns={val_cat: 'Среднее значение'}, inplace=True)

        return calc_mean_df
    else:
        calc_mean_df = pd.pivot_table(df, index=lst_cat,
                                           values=val_cat,
                                           aggfunc=round_mean)
        calc_mean_df.reset_index(inplace=True)
        calc_mean_df.rename(columns={val_cat:'Среднее значение'},inplace=True)
        return calc_mean_df



def calc_count_sphere_pia(df:pd.DataFrame, type_calc:str, lst_cat:list, val_cat, col_cat):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Класс или Номер_класса
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :param col_cat: колонка по которой будет формироваться свод
    :return:датафрейм
    """
    if type_calc == 'Класс':
        count_df = pd.pivot_table(df, index=lst_cat,
                                                 columns=col_cat,
                                                 values=val_cat,
                                                 aggfunc='count', margins=True, margins_name='Итого')

        lst_sphere = count_df.columns[:-1]
        count_df.reset_index(inplace=True)

        for sphere in lst_sphere:
            count_df[f'% {sphere} от общего'] = round(
            count_df[f'{sphere}'] / count_df['Итого'], 2) * 100


        part_svod_df = count_df.iloc[:-1:]
        part_svod_df.sort_values(by='Класс', key=lambda x: x.map(sort_name_class), inplace=True)  # сортируем
        itog_svod_df = count_df.iloc[-1:]
        count_df = pd.concat([part_svod_df, itog_svod_df])

        return count_df
    else:
        count_df = pd.pivot_table(df, index=lst_cat,
                                  columns=col_cat,
                                  values=val_cat,
                                  aggfunc='count', margins=True, margins_name='Итого')

        lst_sphere = count_df.columns[:-1]
        count_df.reset_index(inplace=True)

        for sphere in lst_sphere:
            count_df[f'% {sphere} от общего'] = round(
            count_df[f'{sphere}'] / count_df['Итого'], 2) * 100

        return count_df




def calc_count_level_pia(df:pd.DataFrame, type_calc:str, lst_cat:list, val_cat, col_cat, lst_cols:list):
    """
    Функция для создания сводных датафреймов

    :param df: датафрейм с данными
    :param type_calc:тип обработки Класс или Номер_класса
    :param lst_cat:список колонок по которым будет формироваться свод
    :param val_cat:значение по которому будет формиваться свод
    :param col_cat: колонка по которой будет формироваться свод
    :param lst_cols: список с колонками
    :return:датафрейм
    """
    if type_calc == 'Класс':
        count_df = pd.pivot_table(df, index=lst_cat,
                                                 columns=col_cat,
                                                 values=val_cat,
                                                 aggfunc='count', margins=True, margins_name='Итого')


        count_df.reset_index(inplace=True)
        count_df = count_df.reindex(columns=lst_cols)
        count_df['% такая работа активно отвергается от общего'] = round(
            count_df['такая работа активно отвергается'] / count_df['Итого'], 2) * 100
        count_df['% склонность не выражена от общего'] = round(
            count_df['склонность не выражена'] / count_df['Итого'], 2) * 100
        count_df['% склонность на среднем уровне от общего'] = round(
            count_df['склонность на среднем уровне'] / count_df['Итого'], 2) * 100
        count_df['% выраженная склонность от общего'] = round(
            count_df['выраженная склонность'] / count_df['Итого'], 2) * 100
        count_df['% ярко выраженная склонность от общего'] = round(
            count_df['ярко выраженная склонность'] / count_df['Итого'], 2) * 100


        part_svod_df = count_df.iloc[:-1:]
        part_svod_df.sort_values(by='Класс', key=lambda x: x.map(sort_name_class), inplace=True)  # сортируем
        itog_svod_df = count_df.iloc[-1:]
        count_df = pd.concat([part_svod_df, itog_svod_df])

        return count_df
    else:
        count_df = pd.pivot_table(df, index=lst_cat,
                                  columns=col_cat,
                                  values=val_cat,
                                  aggfunc='count', margins=True, margins_name='Итого')

        count_df.reset_index(inplace=True)
        count_df = count_df.reindex(columns=lst_cols)
        count_df['% такая работа активно отвергается от общего'] = round(
            count_df['такая работа активно отвергается'] / count_df['Итого'], 2) * 100
        count_df['% склонность не выражена от общего'] = round(
            count_df['склонность не выражена'] / count_df['Итого'], 2) * 100
        count_df['% склонность на среднем уровне от общего'] = round(
            count_df['склонность на среднем уровне'] / count_df['Итого'], 2) * 100
        count_df['% выраженная склонность от общего'] = round(
            count_df['выраженная склонность'] / count_df['Итого'], 2) * 100
        count_df['% ярко выраженная склонность от общего'] = round(
            count_df['ярко выраженная склонность'] / count_df['Итого'], 2) * 100

        return count_df








def processing_sitt(base_df: pd.DataFrame, answers_df: pd.DataFrame):
    """
        Фугкция для обработки данных Склонность к исполнительскому или творческому труду Азбель
        :return:
        """
    try:
        out_answer_df = base_df.copy()  # делаем копию для последующего соединения с сырыми ответами
        if answers_df.shape[1] != 12:
            raise BadCountColumnsSITT

        answers_df.columns = [f'Вопрос {i}' for i in range(1,13)]
        # делаем список списков
        valid_values = [['Моя работа такова, что умение хорошо выполнять её и чёткое соблюдение правил гарантированно приведут к предсказуемому результату','Даже если я выполняю свою работу качественно, я не могу точно предсказать её результаты'],
                        ['Способы и методы выполнения моей работы очень многообразны, я сам ответственен за их выбор','Способы выполнения моей работы более-менее стандартны, известны заранее'],
                        ['Что и как мне делать, определяет начальство, моя задача — пунктуально исполнять распоряжения','Моя работа не подразумевает чётких инструкций, приходится постоянно размышлять о том, как действовать'],
                        ['Я готов заниматься такой работой, которая требует постоянных затрат времени и сил для дальнейшего обучения, профессионального самосовершенствования','Я хотел бы выучиться какой-либо профессии, а потом спокойно зарабатывать деньги, больше не тратя времени и сил на дальнейшее обучение'],
                        ['Моё отношение к работе описывается пословицей «Лучше синица в руках, чем журавль в небе»','Моё отношение к работе точнее передаёт фраза «Лучше охотиться за журавлём в небе, чем иметь синицу в руках»'],
                        ['Мне важно, чтобы на работе была постоянная возможность для профессионального развития, пусть даже в ущерб стабильности','Главное, чтобы работа и заработки были стабильными; возможность развиваться в профессиональной сфере для меня не столь важна'],
                        ['Хотелось бы иметь гарантированную оплату труда, соответствующую времени и силам, которые я трачу на работу','Оплачиваться должен исключительно результат работы, а не потраченное на его достижение время и усилия'],
                        ['Далеко не все моё рабочее время подчинено чёткому расписанию, в значительной степени я сам определяю, когда и где выполнить те или иные дела','График моей работы подчинён чёткому расписанию: я всегда знаю, где и когда я должен находиться и что именно делать'],
                        ['Я отношусь к работе как к необходимому условию для того, чтобы обеспечить себе достойную жизнь в нерабочее время','Я не склонен противопоставлять работу и другие жизненные сферы; для меня трудиться — это и значит жить'],
                        ['Даже когда мой трудовой день закончен, в мыслях я периодически возвращаюсь к рабочим проблемам','Моя работа завершается в момент окончания рабочего дня, я больше не вспоминаю о ней, пока не настанет следующий рабочий день'],
                        ['Работа для меня — это средство достижения других жизненных целей (заработать на что-то, повысить свой статус в глазах других людей и т.п.)','Работа ценна для меня именно сама по себе, а не только в связи с теми возможностями, которые она даёт (например, с заработками)'],
                        ['Я всё равно продолжил бы трудиться, даже если бы в моём распоряжении оказалась крупная сумма денег, позволяющая обеспеченно жить, не работая','Окажись в моём распоряжении достаточно денег (например, благодаря наследству), я не работал бы, а проводил время как-нибудь иначе']
                        ]

        lst_error_answers = []  # список для хранения строк где найдены неправильные ответы

        for idx, lst_values in enumerate(valid_values):
            mask = ~answers_df.iloc[:, idx].isin(lst_values)  # проверяем на допустимые значения
            # Получаем строки с отличающимися значениями
            result_check = answers_df.iloc[:, idx][mask]

            if len(result_check) != 0:
                error_row = list(map(lambda x: x + 2, result_check.index))
                error_row = list(map(str, error_row))
                error_row_lst = [f'В {idx + 1} вопросной колонке на строке {value}' for value in error_row]
                error_in_column = ','.join(error_row_lst)
                lst_error_answers.append(error_in_column)

        if len(lst_error_answers) != 0:
            error_message = ';'.join(lst_error_answers)
            raise BadValueSITT

        base_df[f'Необработанное'] = answers_df.apply(processing_result_sitt, axis=1)
        base_df[f'Обработанное'] = base_df[f'Необработанное'].apply(
            extract_key_max_value)
        base_df[f'Максимум'] = base_df[f'Необработанное'].apply(
            extract_max_value)

        base_df[f'Уровень'] = base_df[['Обработанное', 'Максимум']].apply(lambda x: calc_level_sitt(x), axis=1)

        # Создаем датафрейм для создания части в общий датафрейм
        part_df = pd.DataFrame(columns=['СИТТ_Необработанное', 'СИТТ_Обработанное', 'СИТТ_Максимум', 'СИТТ_Уровень'])
        part_df['СИТТ_Необработанное'] = base_df['Необработанное']
        part_df['СИТТ_Обработанное'] = base_df['Обработанное']
        part_df['СИТТ_Максимум'] = base_df['Максимум']
        part_df['СИТТ_Уровень'] = base_df['Уровень']

        base_df.sort_values(by='Максимум', ascending=False, inplace=True)  # сортируем
        out_answer_df = pd.concat([out_answer_df, answers_df], axis=1)  # Датафрейм для проверки


           # Создаем строку с описанием
        description_result = """
    Шкала оценки результатов
    Исполнительский труд:
    10-12 баллов - ярко выраженная склонность;
    7-9 баллов – выраженная склонность;
    4-6 баллов – склонность на среднем уровне;
    2-3 балла – склонность не выражена;
    0-1 баллов – такая работа активно отвергается.
    
    Творческий труд:
    11-12 баллов - ярко выраженная склонность;
    9-10 баллов – выраженная склонность;
    6-8 баллов – склонность на среднем уровне;
    3-5 балла – склонность не выражена;
    0-2 балла – такая работа активно отвергается.
    
    Исполнительский труд подразумевает, что работник будет действовать в более или менее предсказуемых ситуациях по чётко заданным правилам, инструкциям. Типичные примеры таких профессий: кассир, бухгалтер, работник справочной службы. Когда человек занимается подобной работой, проявления творчества с его стороны оказываются нежелательными, а иногда даже опасными. Представь себе, к чему может привести ситуация, когда медсестра, вместо того чтобы чётко выполнять назначения врача и строго придерживаться инструкций по приготовлению препаратов для внутривенных инъекций, погрузится в творческий поиск и начнёт испытывать на больном новые способы приготовления лекарств.\n
    Творческие профессии подразумевают значительную свободу действий, так как работать приходится в ситуациях неопределённости. В них нет, да и не может быть чётких инструкций, которые однозначно предопределяли бы способы выполнения работы. Например, когда режиссёр работает над очередным фильмом, никто не даст ему точных «рецептов» для подбора актёров и не предоставит готовых ответов на все те бесчисленные вопросы, которые возникнут в ходе съёмок. Хотелось бы пояснить: большинство видов работ, в которых нуждается общество, не творческие, а исполнительские. По признаку востребованности именно они находятся на первом месте. Так что если хочешь, чтобы именно тебе досталась творческая работа, нужно уметь делать её очень хорошо и проявлять активность в её поиске.
    """
        # создаем описание результата
        base_df[f'Описание_результата'] = 'Склонность к исполнительскому или творческому труду.\nРезультат тестирования:\n' + base_df[
            f'Необработанное'] + description_result
        part_df['СИТТ_Описание_результата'] = base_df[f'Описание_результата']

        # Общий свод по уровням склонности всего в процентном соотношении
        base_svod_all_df = pd.DataFrame(
            index=['такая работа активно отвергается', 'склонность не выражена',
                   'склонность на среднем уровне',
                   'выраженная склонность', 'ярко выраженная склонность', 'Итого'])

        svod_level_df = pd.pivot_table(base_df, index='Уровень',
                                       values='Максимум',
                                       aggfunc='count')

        svod_level_df['% от общего'] = round(
            svod_level_df['Максимум'] / svod_level_df['Максимум'].sum(), 3) * 100

        base_svod_all_df = base_svod_all_df.join(svod_level_df)

        # # Создаем суммирующую строку
        base_svod_all_df.loc['Итого'] = svod_level_df.sum()
        base_svod_all_df.reset_index(inplace=True)
        base_svod_all_df.rename(columns={'index': 'Уровень склонности', 'Максимум': 'Количество'}, inplace=True)

        # формируем основной словарь
        out_dct = {'Списочный результат': base_df, 'Список для проверки': out_answer_df,
                   'Свод по уровням': base_svod_all_df,
                   }

        lst_level = ['такая работа активно отвергается', 'склонность не выражена',
                   'склонность на среднем уровне',
                   'выраженная склонность', 'ярко выраженная склонность']
        dct_level = dict()

        for level in lst_level:
            temp_df = base_df[base_df['Уровень'] == level]
            if temp_df.shape[0] != 0:
                if level == 'такая работа активно отвергается':
                    level = 'активно отвергается'
                elif level == 'склонность на среднем уровне':
                    level = 'средний уровень'
                elif level == 'ярко выраженная склонность':
                    level = 'ярко выраженная'
                dct_level[level] = temp_df

        out_dct.update(dct_level)

        # Общий свод по сферам всего в процентном соотношении
        svod_sphere_df = pd.pivot_table(base_df, index='Обработанное',
                                        values='Максимум',
                                        aggfunc='count')

        svod_sphere_df['% от общего'] = round(
            svod_sphere_df['Максимум'] / svod_sphere_df['Максимум'].sum(), 3) * 100

        svod_sphere_df.sort_index(inplace=True)

        # # Создаем суммирующую строку
        svod_sphere_df.loc['Итого'] = svod_sphere_df.sum()
        svod_sphere_df.reset_index(inplace=True)
        svod_sphere_df.rename(columns={'Обработанное': 'Состояние идентичности', 'Максимум': 'Количество'},
                              inplace=True)

        # формируем списки по сферам деятельности
        lst_sphere = base_df['Обработанное'].unique()
        lst_sphere.sort()  # сортируем
        dct_sphere = {'Предпочитаемый труд': svod_sphere_df}  # словарь для хранения списков

        for sphere in lst_sphere:
            temp_df = base_df[base_df['Обработанное'] == sphere]
            dct_sphere[sphere] = temp_df


        out_dct.update(dct_sphere)

        """
                       Своды 
                       """
        lst_reindex_group_cols = ['Класс', 'такая работа активно отвергается', 'склонность не выражена',
                   'склонность на среднем уровне',
                   'выраженная склонность', 'ярко выраженная склонность', 'Итого']
        lst_reindex_group_sex_cols = ['Класс', 'Пол', 'такая работа активно отвергается', 'склонность не выражена',
                   'склонность на среднем уровне',
                   'выраженная склонность', 'ярко выраженная склонность', 'Итого']

        lst_reindex_course_cols = ['Номер_класса', 'такая работа активно отвергается', 'склонность не выражена',
                   'склонность на среднем уровне',
                   'выраженная склонность', 'ярко выраженная склонность', 'Итого']
        lst_reindex_course_sex_cols = ['Номер_класса', 'Пол', 'такая работа активно отвергается', 'склонность не выражена',
                   'склонность на среднем уровне',
                   'выраженная склонность', 'ярко выраженная склонность', 'Итого']

        # Своды по уровням
        # Класс
        svod_group_level_df = calc_mean(base_df, 'Класс', ['Класс', 'Уровень'], 'Максимум')
        svod_count_group_level_df = calc_count_level_pia(base_df, 'Класс', ['Класс'], 'Максимум', 'Уровень',
                                                         lst_reindex_group_cols)

        # Класс Пол
        svod_group_level_sex_df = calc_mean(base_df, 'Класс', ['Класс', 'Уровень', 'Пол'], 'Максимум')
        svod_count_group_level_sex_df = calc_count_level_pia(base_df, 'Класс', ['Класс', 'Пол'], 'Максимум', 'Уровень',
                                                             lst_reindex_group_sex_cols)

        # Номер_класса
        svod_course_level_df = calc_mean(base_df, 'Номер_класса', ['Номер_класса', 'Уровень'], 'Максимум')
        svod_count_course_level_df = calc_count_level_pia(base_df, 'Номер_класса', ['Номер_класса'], 'Максимум',
                                                          'Уровень', lst_reindex_course_cols)

        # Номер_класса Пол
        svod_course_level_sex_df = calc_mean(base_df, 'Номер_класса', ['Номер_класса', 'Уровень', 'Пол'], 'Максимум')
        svod_count_course_level_sex_df = calc_count_level_pia(base_df, 'Номер_класса', ['Номер_класса', 'Пол'],
                                                              'Максимум',
                                                              'Уровень', lst_reindex_course_sex_cols)

        # Своды по сферам
        # Класс
        svod_group_sphere_df = calc_mean(base_df, 'Класс', ['Класс', 'Обработанное'], 'Максимум')
        svod_count_group_sphere_df = calc_count_sphere_pia(base_df, 'Класс', ['Класс'], 'Максимум', 'Обработанное')

        # Класс Пол
        svod_group_sphere_sex_df = calc_mean(base_df, 'Класс', ['Класс', 'Обработанное', 'Пол'], 'Максимум')
        svod_count_group_sphere_sex_df = calc_count_sphere_pia(base_df, 'Класс', ['Класс', 'Пол'], 'Максимум',
                                                               'Обработанное')

        # Номер_класса
        svod_course_sphere_df = calc_mean(base_df, 'Номер_класса', ['Номер_класса', 'Обработанное'], 'Максимум')
        svod_count_course_sphere_df = calc_count_sphere_pia(base_df, 'Номер_класса', ['Номер_класса'], 'Максимум',
                                                            'Обработанное')

        # Номер_класса Пол
        svod_course_sphere_sex_df = calc_mean(base_df, 'Номер_класса', ['Номер_класса', 'Обработанное', 'Пол'],
                                              'Максимум')
        svod_count_course_sphere_sex_df = calc_count_sphere_pia(base_df, 'Номер_класса', ['Номер_класса', 'Пол'],
                                                                'Максимум', 'Обработанное')

        svod_dct = {'Ср. Уровень Класс': svod_group_level_df, 'Кол. Уровень Класс': svod_count_group_level_df,
                    'Ср. Уровень Класс Пол': svod_group_level_sex_df,
                    'Кол. Уровень Класс Пол': svod_count_group_level_sex_df,
                    'Ср. Уровень Номер_класса': svod_course_level_df,
                    'Кол. Уровень Номер_класса': svod_count_course_level_df,
                    'Ср. Уровень Номер_класса Пол': svod_course_level_sex_df,
                    'Кол. Уровень Номер_класса Пол': svod_count_course_level_sex_df,

                    'Ср. Труд Класс': svod_group_sphere_df, 'Кол. Труд Класс': svod_count_group_sphere_df,
                    'Ср. Труд Класс Пол': svod_group_sphere_sex_df,
                    'Кол. Труд Класс Пол': svod_count_group_sphere_sex_df,
                    'Ср. Труд Номер_класса': svod_course_sphere_df,
                    'Кол. Труд Номер_класса': svod_count_course_sphere_df,
                    'Ср. Труд Номер_класса Пол': svod_course_sphere_sex_df,
                    'Кол. Труд Номер_класса Пол': svod_count_course_sphere_sex_df,

                    }
        out_dct.update(svod_dct)  # добавляем, чтобы сохранить порядок

        return out_dct, part_df

    except BadValueSITT:
        messagebox.showerror('Лахеcис',
                             f'При обработке вопросов теста Склонность к исполнительскому или творческому труду Азбель обнаружены неправильные варианты ответов. Проверьте ответы на указанных строках:\n'
                             f'{error_message}\n'
                             f'Используйте при создании Яндекс-формы написание вариантов ответа из руководства пользователя программы Лахесис.')


    except BadCountColumnsSITT:
        messagebox.showerror('Лахеcис',
                             f'Проверьте количество колонок с ответами на тест Склонность к исполнительскому или творческому труду Азбель\n'
                             f'Должно быть 12 колонок с ответами')


