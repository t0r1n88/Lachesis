"""
Скрипт для обработки теста Характер и профессия Резапкина
"""

import pandas as pd
from tkinter import messagebox
from lachesis_support_functions import round_mean, sort_name_class


class BadOrderHPR(Exception):
    """
    Исключение для обработки случая когда колонки не совпадают
    """
    pass




class BadValueHPR(Exception):
    """
    Исключение для неправильных значений в вариантах ответов
    """
    pass


class BadCountColumnsHPR(Exception):
    """
    Исключение для обработки случая если количество колонок не равно 24
    """
    pass

def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(': ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]



def processing_hpr(base_df: pd.DataFrame, answers_df: pd.DataFrame):
    """
        Фугкция для обработки данных Характер и профессия Резапкина
        :return:
        """
    out_answer_df = base_df.copy()  # делаем копию для последующего соединения с сырыми ответами
    if answers_df.shape[1] != 24:
        raise BadCountColumnsHPR

    lst_check_cols = ['Знакомясь с людьми, я ловлю себя на мысли, что тут же забываю их имена','Для меня очень важно, чтобы меня окружали люди',
                      'В большой веселой компании','Публичные выступления для меня – это',
                      'В любом коллективе важнее всего','Нового человека я обычно воспринимаю',
                      'Если мне нужно купить что-то из одежды, я выберу','Мой любимый жанр кино',
                      'Мне хотелось бы провести каникулы или отпуск','Мне кажется, что я трачу слишком много времени',
                      'Когда я прихожу в магазин, то я','Если бы я был миллионером, то',
                      'Я предпочитаю работу, на которой есть возможность','Меня привлекает работа, требующая',
                      'Мне ближе высказывание','Меня привлекает работа',
                      'Окружающие чаще считают меня','Моя главная черта — это',
                      'Главное в жизни','Меня часто',
                      'Мне трудно','День рождения для меня – это, прежде всего, возможность',
                      'В профессиональном плане меня больше привлекает','При выборе одежды я, скорее'
                      ]

    # Проверяем порядок колонок
    order_main_columns = lst_check_cols  # порядок колонок и названий как должно быть
    order_temp_df_columns = list(answers_df.columns)  # порядок колонок проверяемого файла
    error_order_lst = []  # список для несовпадающих пар
    # Сравниваем попарно колонки
    for main, temp in zip(order_main_columns, order_temp_df_columns):
        if main != temp:
            error_order_lst.append(f'На месте колонки {main} находится колонка {temp}')
            error_order_message = ';'.join(error_order_lst)
    if len(error_order_lst) != 0:
        raise BadOrderHPR

    # Делаем список списков
    valid_values = [['часто','редко','нет, потому что записываю их','я не думаю об этом'],
                    ['душевные','ответственные','жизнерадостные','дисциплинированные'],
                    ['я люблю быть в центре внимания','я чувствую себя неуютно','я обычно скучаю','я с трудом подыскиваю тему для разговора'],
                    ['возможность показать себя и свои способности','большой стресс','донести до слушателей свои идеи','форма общения'],
                    ['отсутствие конфликтов','работа на результат','дисциплина','возможность работать творчески'],
                    ['с доброжелательным интересом','как потенциального союзника','как потенциального соперника','нейтрально'],
                    ['самую модную вещь','что-нибудь неброское','классический костюм','удобную и практичную одежду'],
                    ['мелодрама','документальное кино','боевик','фэнтези'],
                    ['в какой-нибудь экзотической стране','в тихом, уединенном месте','вместе с близкими людьми','путешествуя в компании друзей'],
                    ['на себя','на других людей','на работу, учебу','на развлечения'],
                    ['долго не могу ничего выбрать из массы товаров','точно знаю, что должен купить','сравниваю и оцениваю товар, прежде чем сделать покупку','беру то, что попадается под руку'],
                    ['приумножал бы свое богатство','ни в чем бы себе не отказывал','не стал бы сорить деньгами','поддерживал бы проекты, связанные с наукой или искусством'],
                    ['общаться с известными людьми','ни за что не отвечать','принимать ответственные решения','решать творческие задачи'],
                    ['способности сопереживать людям','точности и аккуратности в ведении дел','навыков общения с разными людьми','силы и решительности'],
                    ['Лучшее – враг хорошего','Цель оправдывает средства','Доверяй, но проверяй','Хочешь жить – умей вертеться'],
                    ['аниматора','врача','военного','ученого'],
                    ['идеальным исполнителем','хорошим организатором','душой компании','генератором идей'],
                    ['стремление нравиться','сочувствие','пунктуальность','вспыльчивость'],
                    ['слава','любовь','власть','порядок'],
                    ['беспокоит завтрашний день','переполняет энергия','раздражают всякие мелочи','посещают интересные идеи'],
                    ['принимать решения','учитывать интересы других людей','отступать от инструкции','контролировать свои эмоции'],
                    ['напомнить о себе','задуматься о своей жизни','повеселиться с друзьями','получить подарки'],
                    ['медицина и образование','управление и бизнес','контроль и оценка','искусство и наука'],
                    ['выберу цвета, модные в этом сезоне','предпочту темные тона или оттенки серого','выберу яркие, насыщенные цвета','вообще не обращу внимания на ее цвет'],
                    ]

    lst_error_answers = []  # список для хранения строк где найдены неправильные ответы

    for idx, lst_values in enumerate(valid_values):
        mask = ~answers_df.iloc[:, idx].isin(lst_values)  # проверяем на допустимые значения
        # Получаем строки с отличающимися значениями
        result_check = answers_df.iloc[:, idx][mask]

        if len(result_check) != 0:
            error_row = list(map(lambda x: x + 2, result_check.index))
            error_row = list(map(str, error_row))
            error_row_lst = [f'В {idx + 1} вопросной колонке на строке {value}' for value in error_row]
            error_in_column = ','.join(error_row_lst)
            lst_error_answers.append(error_in_column)

    if len(lst_error_answers) != 0:
        error_message = ';'.join(lst_error_answers)
        raise BadValueHPR


