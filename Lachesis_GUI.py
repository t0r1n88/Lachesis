# -*- coding: UTF-8 -*-
"""
скрипт для обработки произвольных тестов
"""

import pandas as pd
import numpy as np
import os
from dateutil.parser import ParserError
from docxtpl import DocxTemplate
from docxcompose.composer import Composer
from docx import Document
from tkinter import *
from tkinter import filedialog
from tkinter import messagebox
from tkinter import ttk
import tkinter
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.styles import Font
from openpyxl.styles import Alignment
from openpyxl import load_workbook
import time
import datetime
import warnings
from collections import Counter
warnings.filterwarnings('ignore', category=UserWarning, module='openpyxl')
pd.options.mode.chained_assignment = None
import sys
import locale
import logging
import tempfile
import re
logging.basicConfig(
    level=logging.WARNING,
    filename="error.log",
    filemode='w',
    # чтобы файл лога перезаписывался  при каждом запуске.Чтобы избежать больших простыней. По умолчанию идет 'a'
    format="%(asctime)s - %(module)s - %(levelname)s - %(funcName)s: %(lineno)d - %(message)s",
    datefmt='%H:%M:%S',
)



def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller
    Функция чтобы логотип отображался"""
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

"""
Функции для создания контекстного меню(Копировать,вставить,вырезать)
"""
def make_textmenu(root):
    """
    Функции для контекстного меню( вырезать,копировать,вставить)
    взято отсюда https://gist.github.com/angeloped/91fb1bb00f1d9e0cd7a55307a801995f
    """
    # эта штука делает меню
    global the_menu
    the_menu = Menu(root, tearoff=0)
    the_menu.add_command(label="Вырезать")
    the_menu.add_command(label="Копировать")
    the_menu.add_command(label="Вставить")
    the_menu.add_separator()
    the_menu.add_command(label="Выбрать все")

def callback_select_all(event):
    """
    Функции для контекстного меню( вырезать,копировать,вставить)
    взято отсюда https://gist.github.com/angeloped/91fb1bb00f1d9e0cd7a55307a801995f
    """
    # select text after 50ms
    window.after(50, lambda: event.widget.select_range(0, 'end'))

def show_textmenu(event):
    """
    Функции для контекстного меню( вырезать,копировать,вставить)
    взято отсюда https://gist.github.com/angeloped/91fb1bb00f1d9e0cd7a55307a801995f
    """
    e_widget = event.widget
    the_menu.entryconfigure("Вырезать", command=lambda: e_widget.event_generate("<<Cut>>"))
    the_menu.entryconfigure("Копировать", command=lambda: e_widget.event_generate("<<Copy>>"))
    the_menu.entryconfigure("Вставить", command=lambda: e_widget.event_generate("<<Paste>>"))
    the_menu.entryconfigure("Выбрать все", command=lambda: e_widget.select_range(0, 'end'))
    the_menu.tk.call("tk_popup", the_menu, event.x_root, event.y_root)

# any name as accepted but not signature
def report_callback_exception(self, exc, val, tb):
    """
    Обработка исключений ткинтер
    https://stackoverflow.com/questions/15246523/handling-exception-in-python-tkinter
    """
    messagebox.showerror("Введите число !", message=str(val))


# # Классы для исключений

class WrongNumberColumn(Exception):
    """
    Класс для исключения проверяющего количество колонок в в таблице
    """
    pass


class CheckBoxException(Exception):
    """
    Класс для вызовы исключения в случае если неправильно выставлены чекбоксы
    """
    pass


class NotFoundValue(Exception):
    """
    Класс для обозначения того что значение не найдено
    """
    pass
def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(' - ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(' - ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]




def create_out_str_ddo(x):
    """
    Функция для создания выходной строки ДДО
    """
    return f'{dct_desciprion.get(x, "Проверьте правильность написания ответа в форме,в колонке ДДО_Обработанный_результат указаны несовпадающие значения")}\nРекомендуемые профессии:\n{dct_prof.get(x, "Проверьте правильность написания ответа в форме,в колонке ДДО_Обработанный_результат указаны несовпадающие значения")}'


def processing_finish_result_ddo(row):
    """
    Обработка результатов тестирования ДДО
    """
    # Создаем словарь для хранения данных
    dct_type = {'Человек-природа': 0, 'Человек-техника': 0, 'Человек-человек': 0, 'Человек-знаковые системы': 0,
                'Человек-художественный образ': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении
    # 1
    if row[0] == 'Ухаживать за животными.':
        dct_type['Человек-природа'] += 1
    elif row[0] == 'Обслуживать машины, приборы (следить, регулировать).':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[Ухаживать за животными.] или [Обслуживать машины, приборы (следить, регулировать).]'
    # 2
    if row[1] == 'Помогать больным.':
        dct_type['Человек-человек'] += 1
    elif row[1] == 'Составлять таблицы, схемы, компьютерные программы.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[Помогать больным.] или [Составлять таблицы, схемы, компьютерные программы.]'

    # 3
    if row[2] == 'Следить за качеством книжных иллюстраций, плакатов, художественных открыток, музыкальных записей.':
        dct_type['Человек-художественный образ'] += 1
    elif row[2] == 'Следить за состоянием и развитием растений.':
        dct_type['Человек-природа'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[Следить за качеством книжных иллюстраций, плакатов, художественных открыток, музыкальных записей.] или [Следить за состоянием и развитием растений.]'

    # 4
    if row[3] == 'Обрабатывать материалы (дерево, ткань, металл, пластмассу и т.п.).':
        dct_type['Человек-техника'] += 1
    elif row[3] == 'Доводить товары до потребителя, рекламировать, продавать.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[Обрабатывать материалы (дерево, ткань, металл, пластмассу и т.п.).] или [Доводить товары до потребителя, рекламировать, продавать.]'

    # 5
    if row[4] == 'Обсуждать научно-популярные книги, статьи.':
        dct_type['Человек-знаковые системы'] += 1
    elif row[4] == 'Обсуждать художественные книги (или пьесы, концерты).':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[Обсуждать научно-популярные книги, статьи.] или [Обсуждать художественные книги (или пьесы, концерты).]'

    # 6
    if row[5] == 'Выращивать молодняк (животных какой-либо породы).':
        dct_type['Человек-природа'] += 1
    elif row[
        5] == 'Тренировать товарищей (или младших) для выполнения и закрепления каких-либо навыков (трудовых, учебных, спортивных).':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[Выращивать молодняк (животных какой-либо породы).] или [Тренировать товарищей (или младших) для выполнения и закрепления каких-либо навыков (трудовых, учебных, спортивных).]'

    # 7
    if row[6] == 'Копировать рисунки, изображения (или настраивать музыкальные инструменты).':
        dct_type['Человек-художественный образ'] += 1
    elif row[
        6] == 'Управлять какой-либо машиной (грузовым, подъемным или транспортным средством) - подъемным краном, трактором, тепловозом и др.':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[Копировать рисунки, изображения (или настраивать музыкальные инструменты).] или [Управлять какой-либо машиной (грузовым, подъемным или транспортным средством) - подъемным краном, трактором, тепловозом и др.]'

    # 8
    if row[7] == 'Сообщать, разъяснять людям нужные им сведения (в справочном бюро, на экскурсии и т.д.).':
        dct_type['Человек-человек'] += 1
    elif row[7] == 'Оформлять выставки, витрины (или участвовать в подготовке пьес, концертов).':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[Сообщать, разъяснять людям нужные им сведения (в справочном бюро, на экскурсии и т.д.).] или [Оформлять выставки, витрины (или участвовать в подготовке пьес, концертов).]'

    # 9
    if row[8] == 'Ремонтировать вещи, изделия (одежду, технику), жилище.':
        dct_type['Человек-техника'] += 1
    elif row[8] == 'Искать и исправлять ошибки в текстах, таблицах, рисунках.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[Ремонтировать вещи, изделия (одежду, технику), жилище.] или [Искать и исправлять ошибки в текстах, таблицах, рисунках.]'

    # 10
    if row[9] == 'Лечить животных.':
        dct_type['Человек-природа'] += 1
    elif row[9] == 'Выполнять вычисления, расчёты.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[Лечить животных.] или [Выполнять вычисления, расчёты.]'

    # 11
    if row[10] == 'Выводить новые сорта растений.':
        dct_type['Человек-природа'] += 1
    elif row[10] == 'Конструировать, новые виды промышленных изделий (машины, одежду, дома, продукты питания и т.п.).':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[Выводить новые сорта растений.] или [Конструировать, новые виды промышленных изделий (машины, одежду, дома, продукты питания и т.п.).]'

    # 12
    if row[11] == 'Разбирать споры, ссоры между людьми, убеждать, разъяснять, наказывать, поощрять.':
        dct_type['Человек-человек'] += 1
    elif row[11] == 'Разбираться в чертежах, схемах, таблицах (проверять, уточнять, приводить в порядок).':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[Разбирать споры, ссоры между людьми, убеждать, разъяснять, наказывать, поощрять.] или [Разбираться в чертежах, схемах, таблицах (проверять, уточнять, приводить в порядок).]'

    # 13
    if row[12] == 'Наблюдать, изучать работу коллективов художественной самодеятельности.':
        dct_type['Человек-художественный образ'] += 1
    elif row[12] == 'Наблюдать, изучать жизнь микробов.':
        dct_type['Человек-природа'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[Наблюдать, изучать работу коллективов художественной самодеятельности.] или [Наблюдать, изучать жизнь микробов.]'

    # 14
    if row[13] == 'Обслуживать, налаживать медицинские приборы, аппараты.':
        dct_type['Человек-техника'] += 1
    elif row[13] == 'Оказывать людям медицинскую помощь при ранениях, ушибах, ожогах и т.п.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[Обслуживать, налаживать медицинские приборы, аппараты.] или [Оказывать людям медицинскую помощь при ранениях, ушибах, ожогах и т.п.]'

    # 15
    if row[14] == 'Художественно описывать, изображать события (наблюдаемые и представляемые).':
        dct_type['Человек-знаковые системы'] += 1
    elif row[14] == 'Составлять точные описания-отчеты о наблюдаемых явлениях, событиях, измеряемых объектах и др.':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[Художественно описывать, изображать события (наблюдаемые и представляемые).] или [Составлять точные описания-отчеты о наблюдаемых явлениях, событиях, измеряемых объектах и др.]'

    # 16
    if row[15] == 'Делать лабораторные анализы в больнице.':
        dct_type['Человек-природа'] += 1
    elif row[15] == 'Принимать, осматривать больных, беседовать с ними, назначать лечение.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[Делать лабораторные анализы в больнице.] или [Принимать, осматривать больных, беседовать с ними, назначать лечение.]'

    # 17
    if row[16] == 'Красить или расписывать стены помещений, поверхность изделий.':
        dct_type['Человек-техника'] += 1
    elif row[16] == 'Осуществлять монтаж или сборку машин, приборов.':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[Красить или расписывать стены помещений, поверхность изделий.] или [Осуществлять монтаж или сборку машин, приборов.]'

    # 18
    if row[
        17] == 'Организовывать культпоходы сверстников или младших в театры, музеи, экскурсии, туристические походы и т.п.':
        dct_type['Человек-человек'] += 1
    elif row[17] == 'Играть на сцене, принимать участие в концертах.':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[Организовывать культпоходы сверстников или младших в театры, музеи, экскурсии, туристические походы и т.п.] или [Играть на сцене, принимать участие в концертах.]'

    # 19
    if row[18] == 'Изготовлять по чертежам детали, изделия (машины, одежду), строить здания.':
        dct_type['Человек-техника'] += 1
    elif row[18] == 'Заниматься черчением, копировать чертежи, карты.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[Изготовлять по чертежам детали, изделия (машины, одежду), строить здания.] или [Заниматься черчением, копировать чертежи, карты.]'

    # 20
    if row[19] == 'Вести борьбу с болезнями растений, с вредителями леса, сада.':
        dct_type['Человек-природа'] += 1
    elif row[19] == 'Работать на устройствах с клавиатурой, ноутбуке и др.).':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[Вести борьбу с болезнями растений, с вредителями леса, сада.] или [Работать на устройствах с клавиатурой, ноутбуке и др.).]'

    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # возвращаем элемент с максимальным значением
        return max(dct_type, key=dct_type.get)


def processing_result_ddo(row):
    """
    Обработка результатов тестирования ДДО
    """
    # Создаем словарь для хранения данных
    # Создаем словарь для хранения данных
    dct_type = {'Человек-природа': 0, 'Человек-техника': 0, 'Человек-человек': 0, 'Человек-знаковые системы': 0,
                'Человек-художественный образ': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении
    # 1
    if row[0] == 'Ухаживать за животными.':
        dct_type['Человек-природа'] += 1
    elif row[0] == 'Обслуживать машины, приборы (следить, регулировать).':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[Ухаживать за животными.] или [Обслуживать машины, приборы (следить, регулировать).]'
    # 2
    if row[1] == 'Помогать больным.':
        dct_type['Человек-человек'] += 1
    elif row[1] == 'Составлять таблицы, схемы, компьютерные программы.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[Помогать больным.] или [Составлять таблицы, схемы, компьютерные программы.]'

    # 3
    if row[2] == 'Следить за качеством книжных иллюстраций, плакатов, художественных открыток, музыкальных записей.':
        dct_type['Человек-художественный образ'] += 1
    elif row[2] == 'Следить за состоянием и развитием растений.':
        dct_type['Человек-природа'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[Следить за качеством книжных иллюстраций, плакатов, художественных открыток, музыкальных записей.] или [Следить за состоянием и развитием растений.]'

    # 4
    if row[3] == 'Обрабатывать материалы (дерево, ткань, металл, пластмассу и т.п.).':
        dct_type['Человек-техника'] += 1
    elif row[3] == 'Доводить товары до потребителя, рекламировать, продавать.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[Обрабатывать материалы (дерево, ткань, металл, пластмассу и т.п.).] или [Доводить товары до потребителя, рекламировать, продавать.]'

    # 5
    if row[4] == 'Обсуждать научно-популярные книги, статьи.':
        dct_type['Человек-знаковые системы'] += 1
    elif row[4] == 'Обсуждать художественные книги (или пьесы, концерты).':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[Обсуждать научно-популярные книги, статьи.] или [Обсуждать художественные книги (или пьесы, концерты).]'

    # 6
    if row[5] == 'Выращивать молодняк (животных какой-либо породы).':
        dct_type['Человек-природа'] += 1
    elif row[
        5] == 'Тренировать товарищей (или младших) для выполнения и закрепления каких-либо навыков (трудовых, учебных, спортивных).':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[Выращивать молодняк (животных какой-либо породы).] или [Тренировать товарищей (или младших) для выполнения и закрепления каких-либо навыков (трудовых, учебных, спортивных).]'

    # 7
    if row[6] == 'Копировать рисунки, изображения (или настраивать музыкальные инструменты).':
        dct_type['Человек-художественный образ'] += 1
    elif row[
        6] == 'Управлять какой-либо машиной (грузовым, подъемным или транспортным средством) - подъемным краном, трактором, тепловозом и др.':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[Копировать рисунки, изображения (или настраивать музыкальные инструменты).] или [Управлять какой-либо машиной (грузовым, подъемным или транспортным средством) - подъемным краном, трактором, тепловозом и др.]'

    # 8
    if row[7] == 'Сообщать, разъяснять людям нужные им сведения (в справочном бюро, на экскурсии и т.д.).':
        dct_type['Человек-человек'] += 1
    elif row[7] == 'Оформлять выставки, витрины (или участвовать в подготовке пьес, концертов).':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[Сообщать, разъяснять людям нужные им сведения (в справочном бюро, на экскурсии и т.д.).] или [Оформлять выставки, витрины (или участвовать в подготовке пьес, концертов).]'

    # 9
    if row[8] == 'Ремонтировать вещи, изделия (одежду, технику), жилище.':
        dct_type['Человек-техника'] += 1
    elif row[8] == 'Искать и исправлять ошибки в текстах, таблицах, рисунках.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[Ремонтировать вещи, изделия (одежду, технику), жилище.] или [Искать и исправлять ошибки в текстах, таблицах, рисунках.]'

    # 10
    if row[9] == 'Лечить животных.':
        dct_type['Человек-природа'] += 1
    elif row[9] == 'Выполнять вычисления, расчёты.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[Лечить животных.] или [Выполнять вычисления, расчёты.]'

    # 11
    if row[10] == 'Выводить новые сорта растений.':
        dct_type['Человек-природа'] += 1
    elif row[10] == 'Конструировать, новые виды промышленных изделий (машины, одежду, дома, продукты питания и т.п.).':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[Выводить новые сорта растений.] или [Конструировать, новые виды промышленных изделий (машины, одежду, дома, продукты питания и т.п.).]'

    # 12
    if row[11] == 'Разбирать споры, ссоры между людьми, убеждать, разъяснять, наказывать, поощрять.':
        dct_type['Человек-человек'] += 1
    elif row[11] == 'Разбираться в чертежах, схемах, таблицах (проверять, уточнять, приводить в порядок).':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[Разбирать споры, ссоры между людьми, убеждать, разъяснять, наказывать, поощрять.] или [Разбираться в чертежах, схемах, таблицах (проверять, уточнять, приводить в порядок).]'

    # 13
    if row[12] == 'Наблюдать, изучать работу коллективов художественной самодеятельности.':
        dct_type['Человек-художественный образ'] += 1
    elif row[12] == 'Наблюдать, изучать жизнь микробов.':
        dct_type['Человек-природа'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[Наблюдать, изучать работу коллективов художественной самодеятельности.] или [Наблюдать, изучать жизнь микробов.]'

    # 14
    if row[13] == 'Обслуживать, налаживать медицинские приборы, аппараты.':
        dct_type['Человек-техника'] += 1
    elif row[13] == 'Оказывать людям медицинскую помощь при ранениях, ушибах, ожогах и т.п.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[Обслуживать, налаживать медицинские приборы, аппараты.] или [Оказывать людям медицинскую помощь при ранениях, ушибах, ожогах и т.п.]'

    # 15
    if row[14] == 'Художественно описывать, изображать события (наблюдаемые и представляемые).':
        dct_type['Человек-знаковые системы'] += 1
    elif row[14] == 'Составлять точные описания-отчеты о наблюдаемых явлениях, событиях, измеряемых объектах и др.':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[Художественно описывать, изображать события (наблюдаемые и представляемые).] или [Составлять точные описания-отчеты о наблюдаемых явлениях, событиях, измеряемых объектах и др.]'

    # 16
    if row[15] == 'Делать лабораторные анализы в больнице.':
        dct_type['Человек-природа'] += 1
    elif row[15] == 'Принимать, осматривать больных, беседовать с ними, назначать лечение.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[Делать лабораторные анализы в больнице.] или [Принимать, осматривать больных, беседовать с ними, назначать лечение.]'

    # 17
    if row[16] == 'Красить или расписывать стены помещений, поверхность изделий.':
        dct_type['Человек-техника'] += 1
    elif row[16] == 'Осуществлять монтаж или сборку машин, приборов.':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[Красить или расписывать стены помещений, поверхность изделий.] или [Осуществлять монтаж или сборку машин, приборов.]'

    # 18
    if row[
        17] == 'Организовывать культпоходы сверстников или младших в театры, музеи, экскурсии, туристические походы и т.п.':
        dct_type['Человек-человек'] += 1
    elif row[17] == 'Играть на сцене, принимать участие в концертах.':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[Организовывать культпоходы сверстников или младших в театры, музеи, экскурсии, туристические походы и т.п.] или [Играть на сцене, принимать участие в концертах.]'

    # 19
    if row[18] == 'Изготовлять по чертежам детали, изделия (машины, одежду), строить здания.':
        dct_type['Человек-техника'] += 1
    elif row[18] == 'Заниматься черчением, копировать чертежи, карты.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[Изготовлять по чертежам детали, изделия (машины, одежду), строить здания.] или [Заниматься черчением, копировать чертежи, карты.]'

    # 20
    if row[19] == 'Вести борьбу с болезнями растений, с вредителями леса, сада.':
        dct_type['Человек-природа'] += 1
    elif row[19] == 'Работать на устройствах с клавиатурой, ноутбуке и др.).':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[Вести борьбу с болезнями растений, с вредителями леса, сада.] или [Работать на устройствах с клавиатурой, ноутбуке и др.).]'

    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # сортируем по убыванию
        result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
        begin_str = ''
        # создаем строку с результатами
        for sphere, value in result_lst:
            begin_str += f'{sphere} - {value};\n'

        return begin_str


def processing_result_sppu(row):
    """
    Обработка результатов тестирования
    """

    # Создаем словарь для хранения данных
    dct_type = {'сфера работы с людьми': 0, 'сфера умственного труда': 0, 'сфера технических интересов': 0,
                'сфера эстетики и искусства': 0,
                'сфера физического труда, подвижной деятельности': 0,
                'сфера материальных интересов, планово-экономических видов работ': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении

    # 1
    if row[0] == 'общаться с самыми разными людьми;':
        dct_type['сфера работы с людьми'] += 1
    elif row[0] == 'что-нибудь делать своими руками – мебель, одежду, машины и т.д.;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[0] == 'снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[общаться с самыми разными людьми;], [что-нибудь делать своими руками – мебель, одежду, машины и т.д.;], [снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.]'

    # 2
    if row[1] == 'художественная форма, мастерство писателя или режиссера;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[1] == 'сюжет, действие героев;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[1] == 'информация, которая может пригодиться в жизни.':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[художественная форма, мастерство писателя или режиссера;], [сюжет, действие героев;], [информация, которая может пригодиться в жизни.]'

    # 3
    if row[2] == 'в области науки;':
        dct_type['сфера умственного труда'] += 1
    elif row[2] == 'за общественную деятельность;':
        dct_type['сфера работы с людьми'] += 1
    elif row[2] == 'в области искусства.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[в области науки;], [за общественную деятельность;], [в области искусства.]'

    # 4
    if row[3] == 'управляющим банка;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[3] == 'главным инженером на производстве;':
        dct_type['сфера технических интересов'] += 1
    elif row[3] == 'начальником экспедиции.':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[управляющим банка;], [главным инженером на производстве;], [начальником экспедиции.]'

    # 5
    if row[4] == 'достижения науки;':
        dct_type['сфера умственного труда'] += 1
    elif row[4] == 'развитие производства;':
        dct_type['сфера технических интересов'] += 1
    elif row[4] == 'взаимопонимание среди людей.':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[достижения науки;], [развитие производства;], [взаимопонимание среди людей.]'

    # 6
    if row[5] == 'благоустройством школы (столовая, спортзал, компьютеры);':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[5] == 'созданием дружного, сплоченного коллектива;':
        dct_type['сфера работы с людьми'] += 1
    elif row[5] == 'разработкой новых технологий обучения.':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[благоустройством школы (столовая, спортзал, компьютеры);], [созданием дружного, сплоченного коллектива;], [разработкой новых технологий обучения.]'

    # 7
    if row[6] == 'внешний вид экспонатов (цвет, форма);':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[6] == 'внутреннее устройство экспонатов (механизм);':
        dct_type['сфера умственного труда'] += 1
    elif row[6] == 'практическое применение экспонатов.':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[внешний вид экспонатов (цвет, форма);], [внутреннее устройство экспонатов (механизм);], [практическое применение экспонатов.]'

    # 8
    if row[7] == 'мужество, смелость, выносливость;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[7] == 'дружелюбие, чуткость, отзывчивость;':
        dct_type['сфера работы с людьми'] += 1
    elif row[7] == 'ответственность, аккуратность.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[мужество, смелость, выносливость;], [дружелюбие, чуткость, отзывчивость;], [ответственность, аккуратность.]'

    # 9
    if row[8] == 'писать стихи или музыку или рисовать;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[8] == 'ставить различные опыты;':
        dct_type['сфера умственного труда'] += 1
    elif row[8] == 'тренироваться.':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[писать стихи или музыку или рисовать;], [ставить различные опыты;], [тренироваться.]'

    # 10
    if row[9] == 'экстремальный туризм (альпинизм, виндсерфинг, горные лыжи);':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[9] == 'деловое общение;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[9] == 'возможность знакомства с историей и культурой другой страны.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[экстремальный туризм (альпинизм, виндсерфинг, горные лыжи);], [деловое общение;], [возможность знакомства с историей и культурой другой страны.]'

    # 11
    if row[10] == 'о машине нового типа;':
        dct_type['сфера технических интересов'] += 1
    elif row[10] == 'о новой научной теории;':
        dct_type['сфера умственного труда'] += 1
    elif row[10] == 'о человеческих взаимоотношениях.':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[о машине нового типа;], [о новой научной теории;], [о человеческих взаимоотношениях.]'

    # 12
    if row[11] == 'технический;':
        dct_type['сфера технических интересов'] += 1
    elif row[11] == 'музыкальный;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[11] == 'спортивный.':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[технический;], [музыкальный;], [спортивный.]'

    # 13
    if row[12] == 'улучшению взаимопонимания между учителями и учениками;':
        dct_type['сфера работы с людьми'] += 1
    elif row[12] == 'поддержанию здоровья учащихся, занятиям спортом;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[12] == 'укреплению дисциплины.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[улучшению взаимопонимания между учителями и учениками;], [поддержанию здоровья учащихся, занятиям спортом;], [укреплению дисциплины.]'

    # 14
    if row[13] == 'научно-популярные фильмы;':
        dct_type['сфера умственного труда'] += 1
    elif row[13] == 'программы о культуре и спорте;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[13] == 'спортивные программы.':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[научно-популярные фильмы;], [программы о культуре и спорте;], [спортивные программы.]'

    # 15
    if row[14] == 'с машинами, механизмами;':
        dct_type['сфера технических интересов'] += 1
    elif row[14] == 'с объектами природы;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[14] == 'с детьми или сверстниками.':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[с машинами, механизмами;], [с объектами природы;], [с детьми или сверстниками.]'

    # 16
    if row[15] == 'давать знания и умения;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[15] == 'учить общению с другими людьми;':
        dct_type['сфера работы с людьми'] += 1
    elif row[15] == 'обучать навыкам работы.':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[давать знания и умения;], [учить общению с другими людьми;], [обучать навыкам работы.]'

    # 17
    if row[16] == 'вести здоровый образ жизни;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[16] == 'иметь возможность заниматься творчеством;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[16] == 'иметь удобные бытовые условия.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[вести здоровый образ жизни;], [иметь возможность заниматься творчеством;], [иметь удобные бытовые условия.]'

    # 18
    if row[17] == 'защита интересов и прав граждан;':
        dct_type['сфера работы с людьми'] += 1
    elif row[17] == 'забота о материальном благополучии людей;':
        dct_type['сфера технических интересов'] += 1
    elif row[17] == 'наука и технический прогресс.':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[защита интересов и прав граждан;], [забота о материальном благополучии людей;], [наука и технический прогресс.]'

    # 19
    if row[18] == 'физкультуры;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[18] == 'математики;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[18] == 'труда.':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[физкультуры;], [математики;], [труда.]'

    # 20
    if row[19] == 'планировать производство продукции;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[19] == 'изготавливать изделия;':
        dct_type['сфера технических интересов'] += 1
    elif row[19] == 'заниматься сбытом продукции.':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[планировать производство продукции;], [изготавливать изделия;], [заниматься сбытом продукции.]'

    # 21
    if row[20] == 'о выдающихся ученых и их открытиях;':
        dct_type['сфера умственного труда'] += 1
    elif row[20] == 'о творчестве ученых и музыкантов;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[20] == 'об интересных изобретениях.':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №21'] = f'Полученное значение-{row[20]} не совпадает с эталонными:[о выдающихся ученых и их открытиях;], [о творчестве ученых и музыкантов;], [об интересных изобретениях.]'

    # 22
    if row[21] == 'делая что-то по хозяйству;':
        dct_type['сфера технических интересов'] += 1
    elif row[21] == 'с книгой;':
        dct_type['сфера умственного труда'] += 1
    elif row[21] == 'на выставках, концертах и пр.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №22'] = f'Полученное значение-{row[21]} не совпадает с эталонными:[делая что-то по хозяйству;], [с книгой;], [на выставках, концертах и пр.]'

    # 23
    if row[22] == 'о художественной выставке;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[22] == 'о ситуации на фондовой бирже;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[22] == 'о научном открытии.':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №23'] = f'Полученное значение-{row[22]} не совпадает с эталонными:[о художественной выставке;], [о ситуации на фондовой бирже;], [о научном открытии.]'

    # 24
    if row[23] == 'в помещении, где много людей;':
        dct_type['сфера работы с людьми'] += 1
    elif row[23] == 'в необычных условиях;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[23] == 'в обычном кабинете.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №24'] = f'Полученное значение-{row[23]} не совпадает с эталонными:[в помещении, где много людей;], [в необычных условиях;], [в обычном кабинете.]'

    # проверяем на ошибки
    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # сортируем по убыванию
        result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
        begin_str = ''
        # создаем строку с результатами
        for sphere, value in result_lst:
            begin_str += f'{sphere} - {value};\n'

        # добавляем описание
        return begin_str


def processing_result_optl(row):
    """
    Функция для подсчета результатов теста на определение профессионального типа личности
    :return:
    """
    # Создаем словарь для хранения данных
    dct_type = {'Реалистический': 0, 'Интеллектуальный': 0, 'Социальный': 0,
                'Офисный': 0,
                'Предпринимательский': 0,
                'Артистический': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении
    # 1
    if row[0] == 'Автомеханик':
        dct_type['Реалистический'] += 1
    elif row[0] == 'Физиотерапевт':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[Автомеханик] или [Физиотерапевт]'

    # 2
    if row[1] == 'Специалист по защите информации':
        dct_type['Интеллектуальный'] += 1
    elif row[1] == 'Логистик':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[Специалист по защите информации] или [Логистик]'

    # 3
    if row[2] == 'Оператор связи':
        dct_type['Офисный'] += 1
    elif row[2] == 'Кинооператор':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[Оператор связи] или [Кинооператор]'

    # 4
    if row[3] == 'Водитель':
        dct_type['Реалистический'] += 1
    elif row[3] == 'Продавец':
        dct_type['Социальный'] += 1
    else:
        dct_error['Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[Водитель] или [Продавец]'

    # 5
    if row[4] == 'Инженер-конструктор':
        dct_type['Интеллектуальный'] += 1
    elif row[4] == 'Менеджер по продажам':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[Инженер-конструктор] или [Менеджер по продажам]'

    # 6
    if row[5] == 'Диспетчер':
        dct_type['Офисный'] += 1
    elif row[5] == 'Дизайнер компьютерных программ':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[Диспетчер] или [Дизайнер компьютерных программ]'

    # 7
    if row[6] == 'Ветеринар':
        dct_type['Реалистический'] += 1
    elif row[6] == 'Эколог':
        dct_type['Социальный'] += 1
    else:
        dct_error['Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[Ветеринар] или [Эколог]'

    # 8
    if row[7] == 'Биолог-исследователь':
        dct_type['Интеллектуальный'] += 1
    elif row[7] == 'Фермер':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[Биолог-исследователь] или [Фермер]'

    # 9
    if row[8] == 'Лаборант':
        dct_type['Офисный'] += 1
    elif row[8] == 'Дрессировщик':
        dct_type['Артистический'] += 1
    else:
        dct_error['Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[Лаборант] или [Дрессировщик]'

    # 10
    if row[9] == 'Агроном':
        dct_type['Реалистический'] += 1
    elif row[9] == 'Санитарный врач':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[Агроном] или [Санитарный врач]'

    # 11
    if row[10] == 'Селекционер':
        dct_type['Интеллектуальный'] += 1
    elif row[10] == 'Заготовитель сельхозпродуктов':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[Селекционер] или [Заготовитель сельхозпродуктов]'

    # 12
    if row[11] == 'Микробиолог':
        dct_type['Офисный'] += 1
    elif row[11] == 'Ландшафтный дизайнер':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[Микробиолог] или [Ландшафтный дизайнер]'

    # 13
    if row[12] == 'Массажист':
        dct_type['Реалистический'] += 1
    elif row[12] == 'Воспитатель':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[Массажист] или [Воспитатель]'

    # 14
    if row[13] == 'Преподаватель':
        dct_type['Интеллектуальный'] += 1
    elif row[13] == 'Предприниматель':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[Преподаватель] или [Предприниматель]'

    # 15
    if row[14] == 'Администратор':
        dct_type['Офисный'] += 1
    elif row[14] == 'Режиссер театра и кино':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[Администратор] или [Режиссер театра и кино]'

    # 16
    if row[15] == 'Официант':
        dct_type['Реалистический'] += 1
    elif row[15] == 'Врач':
        dct_type['Социальный'] += 1
    else:
        dct_error['Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[Официант] или [Врач]'

    # 17
    if row[16] == 'Психолог':
        dct_type['Интеллектуальный'] += 1
    elif row[16] == 'Торговый агент':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[Психолог] или [Торговый агент]'

    # 18
    if row[17] == 'Страховой агент':
        dct_type['Офисный'] += 1
    elif row[17] == 'Хореограф':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[Страховой агент] или [Хореограф]'

    # 19
    if row[18] == 'Ювелир-гравер':
        dct_type['Реалистический'] += 1
    elif row[18] == 'Журналист':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[Ювелир-гравер] или [Журналист]'

    # 20
    if row[19] == 'Искусствовед':
        dct_type['Интеллектуальный'] += 1
    elif row[19] == 'Продюсер':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[Искусствовед] или [Продюсер]'

    # 21
    if row[20] == 'Редактор':
        dct_type['Офисный'] += 1
    elif row[20] == 'Музыкант':
        dct_type['Артистический'] += 1
    else:
        dct_error['Вопрос №21'] = f'Полученное значение-{row[20]} не совпадает с эталонными:[Редактор] или [Музыкант]'

    # 22
    if row[21] == 'Дизайнер интерьера':
        dct_type['Реалистический'] += 1
    elif row[21] == 'Экскурсовод':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №22'] = f'Полученное значение-{row[21]} не совпадает с эталонными:[Дизайнер интерьера] или [Экскурсовод]'

    # 23
    if row[22] == 'Композитор':
        dct_type['Интеллектуальный'] += 1
    elif row[22] == 'Арт-директор':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №23'] = f'Полученное значение-{row[22]} не совпадает с эталонными:[Композитор] или [Арт-директор]'

    # 24
    if row[23] == 'Музейный работник':
        dct_type['Офисный'] += 1
    elif row[23] == 'Актер театра и кино':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №24'] = f'Полученное значение-{row[23]} не совпадает с эталонными:[Музейный работник] или [Актер театра и кино]'

    # 25
    if row[24] == 'Верстальщик':
        dct_type['Реалистический'] += 1
    elif row[24] == 'Гид-переводчик':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №25'] = f'Полученное значение-{row[24]} не совпадает с эталонными:[Верстальщик] или [Гид-переводчик]'

    # 26
    if row[25] == 'Лингвист':
        dct_type['Интеллектуальный'] += 1
    elif row[25] == 'Антикризисный управляющий':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №26'] = f'Полученное значение-{row[25]} не совпадает с эталонными:[Лингвист] или [Антикризисный управляющий]'

    # 27
    if row[26] == 'Корректор':
        dct_type['Офисный'] += 1
    elif row[26] == 'Художественный редактор':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №27'] = f'Полученное значение-{row[26]} не совпадает с эталонными:[Корректор] или [Художественный редактор]'

    # 28
    if row[27] == 'Наборщик текстов':
        dct_type['Реалистический'] += 1
    elif row[27] == 'Юрисконсульт':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №28'] = f'Полученное значение-{row[27]} не совпадает с эталонными:[Наборщик текстов] или [Юрисконсульт]'

    # 29
    if row[28] == 'Программист':
        dct_type['Интеллектуальный'] += 1
    elif row[28] == 'Брокер':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error['Вопрос №29'] = f'Полученное значение-{row[28]} не совпадает с эталонными:[Программист] или [Брокер]'

    # 30
    if row[29] == 'Бухгалтер':
        dct_type['Офисный'] += 1
    elif row[29] == 'Литературный переводчик':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №30'] = f'Полученное значение-{row[29]} не совпадает с эталонными:[Бухгалтер] или [Литературный переводчик]'

        # проверяем на ошибки
    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # сортируем по убыванию
        result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
        begin_str = ''
        # создаем строку с результатами
        for sphere, value in result_lst:
            begin_str += f'{sphere} - {value};\n'

        return begin_str


def processing_result_dcok(row):
    """
Функция для вычисления итогового балла  результатов теста Диагностика ценностных ориентаций в карьере
"""

    # Создаем словарь для хранения данных
    dct_type = {'Профессиональная компетентность': 0, 'Менеджмент': 0, 'Автономия (независимость)': 0,
                'Стабильность работы': 0,
                'Стабильность места жительства': 0, 'Служение': 0, 'Вызов': 0,
                'Интеграция стилей жизни': 0, 'Предпринимательство': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении
    # 1
    dct_type['Профессиональная компетентность'] += row[0]

    # 2
    dct_type['Менеджмент'] += row[1]

    # 3
    dct_type['Автономия (независимость)'] += row[2]

    # 4
    dct_type['Стабильность работы'] += row[3]

    # 5
    dct_type['Служение'] += row[4]

    # 6
    dct_type['Вызов'] += row[5]

    # 7
    dct_type['Интеграция стилей жизни'] += row[6]

    # 8
    dct_type['Предпринимательство'] += row[7]

    # 9
    dct_type['Профессиональная компетентность'] += row[8]

    # 10
    dct_type['Менеджмент'] += row[9]

    # 11
    dct_type['Автономия (независимость)'] += row[10]

    # 12
    dct_type['Стабильность работы'] += row[11]

    # 13
    dct_type['Служение'] += row[12]

    # 14
    dct_type['Вызов'] += row[13]

    # 15
    dct_type['Интеграция стилей жизни'] += row[14]

    # 16
    dct_type['Предпринимательство'] += row[15]

    # 17
    dct_type['Профессиональная компетентность'] += row[16]

    # 18
    dct_type['Менеджмент'] += row[17]

    # 19
    dct_type['Автономия (независимость)'] += row[18]

    # 20
    dct_type['Стабильность места жительства'] += row[19]

    # 21
    dct_type['Служение'] += row[20]

    # 22
    dct_type['Вызов'] += row[21]

    # 23
    dct_type['Интеграция стилей жизни'] += row[22]

    # 24
    dct_type['Предпринимательство'] += row[23]

    # 25
    dct_type['Профессиональная компетентность'] += row[24]

    # 26
    dct_type['Менеджмент'] += row[25]

    # 27
    dct_type['Автономия (независимость)'] += row[26]

    # 28
    dct_type['Стабильность места жительства'] += row[27]

    # 29
    dct_type['Служение'] += row[28]

    # 30
    dct_type['Вызов'] += row[29]

    # 31
    dct_type['Интеграция стилей жизни'] += row[30]

    # 32
    dct_type['Предпринимательство'] += row[31]

    # 33
    dct_type['Профессиональная компетентность'] += row[32]

    # 34
    dct_type['Менеджмент'] += row[33]

    # 35
    dct_type['Автономия (независимость)'] += row[34]

    # 36
    dct_type['Стабильность работы'] += row[35]

    # 37
    dct_type['Служение'] += row[36]

    # 38
    dct_type['Вызов'] += row[37]

    # 39
    dct_type['Интеграция стилей жизни'] += row[38]

    # 40
    dct_type['Предпринимательство'] += row[39]

    # 41
    dct_type['Стабильность места жительства'] += row[40]

    # Делим на 5 результаты
    for key, value in dct_type.items():
        dct_type[key] = round(dct_type[key] / 5)
    # Сортируем
    result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)

    begin_str = ''
    # создаем строку с результатами
    for sphere, value in result_lst:
        begin_str += f'{sphere} - {value};\n'

    return begin_str

def processing_dcok(base_df: pd.DataFrame, answers_df: pd.DataFrame, size: int,name_test):
    """
    Фугкция для обработки данных ДЦОК
    :return:
    """
    if answers_df.shape[1] != size:
        raise WrongNumberColumn
    answers_df.columns = [f'{name_test}_Вопрос_ №_{i}' for i in range(1, answers_df.shape[1] + 1)]

    answers_df = answers_df.astype(int)

    # Создаем колонку для результов первичного подсчета
    answers_df[f'{name_test}_Необработанный_результат'] = answers_df.apply(processing_result_dcok, axis=1)
    answers_df[f'{name_test}_Обработанный_результат'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_key_max_value)
    answers_df[f'{name_test}_Числовое_значение_результата'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_max_value)

    # Создаем датафрейм для данных отчета
    report_df = answers_df.iloc[::, size + 1:]

    # Создаем датафрейм в который будем заносить итоговые результаты
    finish_report_df = report_df[f'{name_test}_Обработанный_результат'].value_counts().to_frame()

    # получаем процента
    finish_report_df['Доля_от_общего_количества'] = round(
        (finish_report_df[f'{name_test}_Обработанный_результат'] / report_df.shape[0]) * 100, 2)

    finish_report_df = finish_report_df.reset_index()

    finish_report_df.columns = ['Категория', 'Количество', 'Доля в % от общего количества']


    # соединяем после обработки
    df = pd.concat([base_df, answers_df], axis=1)
    description_result = """
По каждой из девяти карьерных ориентаций подсчитывается количество баллов. Таким образом определяется ведущая карьерная ориентация - количество набранных для этого баллов должно быть не менее пяти. Иногда ведущей не становится ни одна карьерная ориентация - в таком случае карьера не является центральной в жизни личности. 

1) Профессиональная компетентность -быть профессионалом, мастером в своем деле. 
Эта ориентация связана с наличием способностей и талантов в определенной области.
Люди с такой ориентацией хотят быть мастерами своего дела, они бывают особенно счастливы, когда достигают успеха в профессиональной сфере, но быстро теряют интерес к работе, которая не позволяет развивать их способности. Вряд ли их заинтересует даже значительно более высокая должность, если она не связана с их профессиональными компетенциями. Они ищут признания своих талантов, что должно выражаться в статусе, соответствующем их мастерству. Они готовы управлять другими в пределах своей компетенции, но управление не представляет для них особого интереса. Поэтому многие из этой категории отвергают работу руководителя, управление рассматривают как необходимое условие для продвижения в своей профессиональной сфере.
2) Менеджмент - Управлять – людьми, проектами, бизнес-процессами и т.п.
Для этих людей первостепенное значение имеет ориентация личности на интеграцию усилий других людей, полнота ответственности за конечный результат и соединение различных функций организации. С возрастом и опытом эта карьерная ориентация проявляется сильнее. Возможности для лидерства, высокого дохода, повышенных уровней ответственности и вклад в успех своей организации являются ключевыми ценностями и мотивами. Самое главное для них – управление: людьми, проектами, любыми бизнес-процессами – это в целом не имеет принципиального значения. Центральное понятие их профессионального развития – власть, осознание того, что от них зависит принятие ключевых решений. Причем для них не является принципиальным управление собственным проектом или целым бизнесом, скорее наоборот, они в большей степени ориентированы на построение карьеры в наемном менеджменте, но при условии, что им будут делегированы значительные полномочия. Человек с такой ориентацией будет считать, что не достиг цели своей карьеры, пока не займет должность, на которой будет управлять различными сторонами деятельности предприятия.
3) Автономия (независимость) – Главное в работе – это свобода и независимость. 
Первичная забота личности с такой ориентацией –освобождение от организационных правил, предписаний и ограничений. Они испытывают трудности, связанные с установленными правилами, процедурами, рабочим днем, дисциплиной, формой одежды и т.д. Они любят выполнять работу своим способом, темпом и по собственным стандартам. Они не любят, когда работа вмешивается в их частную жизнь, поэтому предпочитают делать независимую карьеру собственным путем. Они скорее выберут низкосортную работу, чем откажутся от автономии и независимости. Для них первоочередная задача развития карьеры – получить возможность работать самостоятельно, самому решать, как, когда и что делать для достижения тех или иных целей. Карьера для них – это, прежде всего, способ реализации их свободы, поэтому любые рамки и строгое подчинение оттолкнут их даже от внешне привлекательной вакансии. Такой человек может работать в организации, которая обеспечивает достаточную степень свободы.
4) Стабильность работы - стабильная, надежная работа на длительное время.
Эти люди испытывают потребность в безопасности, защите и возможности прогнозирования и будут искать постоянную работу с минимальной вероятностью увольнения. Эти люди отождествляют свою работу со своей карьерой. Их потребность в безопасности и стабильности ограничивает выбор вариантов	карьеры.
Авантюрные или краткосрочные проекты и только становящиеся на ноги компании их, скорее всего, не привлекают. Они очень ценят социальные гарантии, которые может предложить работодатель, и, как правило, их выбор места работы связан именно с длительным контрактом и стабильным положением компании на рынке. Такие люди ответственность за управление своей карьерой перекладывают на нанимателя. Часто данная ценностная ориентация сочетается с невысоким уровнем притязаний.
5) Стабильность места жительства - Главное – жить в своем городе (минимум переездов, командировок).
Важнее остаться на одном месте жительства, чем получить повышение или новую работу на новой местности. Переезд для таких людей неприемлем, и даже частые командировки являются для них негативным фактором при рассмотрении	предложения о работе.
6) Служение - Воплощать в работе свои идеалы и ценности.
Данная ценностная ориентация характерна для людей, занимающихся делом по причине желания реализовать в своей работе главные ценности. Они часто ориентированы больше на ценности, чем на требующиеся в данном виде работы способности. Они стремятся приносить пользу людям, обществу, для них очень важно видеть конкретные плоды своей работы, даже если они и не выражены в материальном эквиваленте. Основной тезис построения их карьеры – получить возможность максимально эффективно использовать их таланты и опыт для реализации общественно	важной цели. Люди, ориентированные на служение, общительны и часто консервативны. Человек с такой ориентацией не будет работать в организации, которая враждебна его целям и ценностям.
7) Вызов - Сделать   невозможное – возможным, решать   уникальные   задачи. 
Эти люди считают успехом преодоление непреодолимых препятствий, решение неразрешимых проблем или просто выигрыш. Они ориентированы на то, чтобы “бросать вызов”. Для одних людей вызов представляет более трудная работа, для других это — конкуренция и межличностные отношения. Они ориентированы на решение заведомо сложных задач, преодоление препятствий ради победы в конкурентной борьбе. Они чувствуют себя преуспевающими только тогда, когда постоянно вовлечены в решение трудных проблем или в ситуацию соревнования. Карьера для них – это постоянный вызов их профессионализму, и они всегда готовы его принять. Социальная ситуация чаще всего рассматривается с позиции “выигрыша – проигрыша”. Процесс борьбы и победа более важна для них, чем конкретная область деятельности или квалификация. Новизна, разнообразие и вызов имеют для них очень большую ценность, и, если все идет слишком просто, им становиться скучно.
8) Интеграция стилей жизни - Сохранение гармонии между сложившейся личной жизнью и карьерой.
Для людей этой категории карьера должна ассоциироваться с общим стилем жизни, уравновешивая потребности человека, семьи и карьеры. Они хотят, чтобы организационные отношения отражали бы уважение к их личным и семейным проблемам.
Выбирать и поддерживать определенный образ жизни для них важнее, чем добиваться успеха в карьере. Развитие карьеры их привлекает только в том случае, если она не нарушает привычный им стиль жизни и окружение. Для них важно, чтобы все было уравновешено – карьера, семья, личные интересы и т.п. Жертвовать   чем-то   одним   ради   другого   им    явно    не    свойственно. Такие люди обычно в своем поведении проявляют конформность (тенденция изменять свое поведение в зависимости от влияния других людей с тем, чтобы оно соответствовало мнению окружающих)
9) Предпринимательство – Создавать новые организации, товары, услуги.
Этим людям нравится создавать новые организации, товары или услуги, которые могут быть отождествлены с их усилиями. Работать на других – это не их, они – предприниматели по духу, и цель их карьеры – создать что-то новое, организовать свое дело, воплотить в жизнь идею, всецело принадлежащую только им. Вершина карьеры в их понимании – собственный бизнес.
"""
    # создаем описание результата
    if 'ФИО' in df.columns:
        df[f'{name_test}_Описание_результата'] = df['ФИО'] + '.' + ' \nДиагностика ценностных ориентаций в карьере.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result
    else:
        df[f'{name_test}_Описание_результата'] = 'Диагностика ценностных ориентаций в карьере.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result

    # генерируем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)



    # Создаем сокращенный вариант
    send_df = df.iloc[:, :threshold_base]
    # Добавляем колонки с результатами
    send_df[f'{name_test}_Необработанный_результат'] = df[f'{name_test}_Необработанный_результат']
    send_df[f'{name_test}_Обработанный_результат'] = df[f'{name_test}_Обработанный_результат']
    send_df[f'{name_test}_Числовое_значение_результата'] = df[f'{name_test}_Числовое_значение_результата']
    send_df[f'{name_test}_Описание_результата'] = df[f'{name_test}_Описание_результата']
    # создаем датафреймы для возврата в основную функцию
    out_full_df = df.iloc[:, threshold_base:]  # датафрейм с вопросами и результатами без анкетных данных
    out_result_df = send_df.iloc[:, threshold_base:]

    # Сортировка
    df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    send_df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    df.to_excel(f'{path_to_end_folder_complex}/Полная таблица с результатами {name_test} от {current_time}.xlsx', index=False,
                engine='xlsxwriter')
    send_df.to_excel(f'{path_to_end_folder_complex}/Краткая таблица с результатами {name_test}  от {current_time}.xlsx',
                     index=False, engine='xlsxwriter')
    finish_report_df.to_excel(f'{path_to_end_folder_complex}/Отчет {name_test}  от {current_time}.xlsx',
                              index=False, engine='xlsxwriter')



    return out_full_df, out_result_df


def processing_optl(base_df: pd.DataFrame, answers_df: pd.DataFrame, size: int,name_test):
    """
    Функция для обработки результатов на определение профессионального типа личности
    """
    if answers_df.shape[1] != size:
        raise WrongNumberColumn

    answers_df.columns = [f'{name_test}_Вопрос_ №_{i}' for i in range(1, answers_df.shape[1] + 1)]

    answers_df = answers_df.astype(str)

    answers_df = answers_df.applymap(lambda x: x.strip())
    answers_df[f'{name_test}_Необработанный_результат'] = answers_df.apply(processing_result_optl, axis=1)
    answers_df[f'{name_test}_Обработанный_результат'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_key_max_value)
    answers_df[f'{name_test}_Числовое_значение_результата'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_max_value)

    # Создаем датафрейм для данных отчета
    report_df = answers_df.iloc[::, size + 1:]

    # Создаем датафрейм в который будем заносить итоговые результаты
    finish_report_df = report_df[f'{name_test}_Обработанный_результат'].value_counts().to_frame()

    # получаем процента
    finish_report_df['Доля_от_общего_количества'] = round(
        (finish_report_df[f'{name_test}_Обработанный_результат'] / report_df.shape[0]) * 100, 2)

    finish_report_df = finish_report_df.reset_index()

    finish_report_df.columns = ['Категория', 'Количество', 'Доля в % от общего количества']

    # соединяем после обработки
    df = pd.concat([base_df, answers_df], axis=1)

    description_result = """
Обработка результатов теста 
8-10 баллов – ярко выраженный тип;  
5-7 баллов – средне выраженный тип;  
2-4 баллов – слабо выраженный тип.  
Наибольшее количество баллов указывает на доминирующий тип. В чистом виде эти профессиональные типы встречаются редко – обычно можно говорить только о преобладающем типе личности. Выбирая профессию, необходимо учитывать свой профессиональный тип. Если профессия не соответствует вашему типу личности, работа будет даваться вам ценой значительного нервно-психического напряжения.  
Интерпретация результатов теста 
1. Реалистический тип (Р) 
Люди, относящиеся к этому типу, предпочитают выполнять работу, требующую силы, ловкости, подвижности, хорошей координации движений, навыков практической работы. Результаты труда профессионалов этого типа ощутимы и реальны – их руками создан весь окружающий нас предметный мир. Люди реалистического типа охотнее делают, чем говорят, они настойчивы и уверены в себе, в работе предпочитают четкие и конкретные указания. Придерживаются традиционных ценностей, поэтому критически относятся к новым идеям.  
Близкие типы: интеллектуальный и офисный.  
Противоположный тип: социальный.  
Хороший продавец и хороший ремонтник никогда не будут голодать. Шенк 
2. Интеллектуальный (И) 
Людей, относящихся к этому типу, отличают аналитические способности, рационализм, независимость и оригинальность мышления, умение точно формулировать и излагать свои мысли, решать логические задачи, генерировать новые идеи. Они часто выбирают научную и исследовательскую работу. Им нужна свобода для творчества. Работа способна увлечь их настолько, что стирается грань между рабочим временем и досугом. Мир идей для них может быть важнее, чем общение с людьми. Материальное благополучие для них обычно не на первом месте.  
Близкие типы: реалистический и артистический.  
Противоположный тип: предпринимательский.  
Научная работа не подходит человеку, который обеими ногами стоит на земле и обеими руками тянется к долларам. М.Ларни 
3. Социальный (С) 
Люди, относящиеся к этому типу, предпочитают профессиональную деятельность, связанную с обучением, воспитанием, лечением, консультированием, обслуживанием. Люди этого типа гуманны, чувствительны, активны, ориентированы на социальные нормы, способны понять эмоциональное состояние другого человека. Для них характерно хорошее речевое развитие, живая мимика, интерес к людям, готовность прийти на помощь. Материальное благополучие для них обычно не на первом месте.  
Близкие типы: артистический и предпринимательский.  
Противоположный тип: реалистический.  
Если больному после разговора с врачом не стало легче, то это не врач. В.Бехтерев 
4. Офисный (О) 
Люди этого типа обычно проявляют склонность к работе, связанной с обработкой и систематизацией информации, предоставленной в виде условных знаков, цифр, формул, текстов (ведение документации, установление количественных соотношений между числами и условными знаками). Они отличаются аккуратностью, пунктуальностью, практичностью, ориентированы на социальные нормы, предпочитают четко регламентированную работу. Материальное благополучие для них более значимо, чем для других типов. Склонны к работе, не связанной с широкими контактами и принятием ответственных решений.  
Близкие типы: реалистический и предпринимательский.  
Противоположный тип: артистический.  
Офис может работать без шефа, но не без секретаря. Дж.Фонда 
5. Предпринимательский (П)  
Люди этого типа находчивы, практичны, быстро ориентируются в сложной обстановке, склонны к самостоятельному принятию решений, социально активны, готовы рисковать, ищут острые ощущения. Любят и умеют общаться. Имеют высокий уровень притязаний. Избегают занятий, требующих усидчивости, большой и длительной концентрации внимания. Для них значимо материальное благополучие. Предпочитают деятельность, требующую энергии, организаторских способностей, связанную с руководством, управлением и влиянием на людей.  
Близкие типы: офисный и социальный.  
Противоположный тип: исследовательский.  
Специальность налетчика куда менее заманчива, чем смежные с ней профессии политика или биржевого спекулянта. О.Генри  
6. Артистический (А)  
Люди этого типа оригинальны, независимы в принятии решений, редко ориентируются на социальные нормы и одобрение, обладают необычным взглядом на жизнь, гибкостью мышления, эмоциональной чувствительностью.
Отношения с людьми строят, опираясь на свои ощущения, эмоции, воображение, интуицию. Они не выносят жесткой регламентации, предпочитая свободный график работы. Часто выбирают профессии, связанные с литературой, театром, кино, музыкой, изобразительным искусством.  
Близкие типы: интеллектуальный и социальный.  
Противоположный тип: офисный.  
Только поэты и женщины умеют обращаться с деньгами так, как деньги того заслуживают. А.Боннар 
"""
    if 'ФИО' in df.columns:
        df[f'{name_test}_Описание_результата'] = df['ФИО'] + '.' + ' \nОпределение профессионального типа личности.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result
    else:
        df[f'{name_test}_Описание_результата'] = 'Определение профессионального типа личности.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result

    # генерируем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)



    # Создаем сокращенный вариант
    send_df = df.iloc[:, :threshold_base]
    # Добавляем колонки с результатами
    send_df[f'{name_test}_Необработанный_результат'] = df[f'{name_test}_Необработанный_результат']
    send_df[f'{name_test}_Обработанный_результат'] = df[f'{name_test}_Обработанный_результат']
    send_df[f'{name_test}_Числовое_значение_результата'] = df[f'{name_test}_Числовое_значение_результата']
    send_df[f'{name_test}_Описание_результата'] = df[f'{name_test}_Описание_результата']
    # создаем датафреймы для возврата в основную функцию
    out_full_df = df.iloc[:, threshold_base:]  # датафрейм с вопросами и результатами без анкетных данных
    out_result_df = send_df.iloc[:, threshold_base:]
    # Сортировка
    df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    send_df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    df.to_excel(f'{path_to_end_folder_complex}/Полная таблица с результатами {name_test} от {current_time}.xlsx', index=False,
                engine='xlsxwriter')
    send_df.to_excel(f'{path_to_end_folder_complex}/Краткая таблица с результатами {name_test}  от {current_time}.xlsx',
                     index=False, engine='xlsxwriter')
    finish_report_df.to_excel(f'{path_to_end_folder_complex}/Отчет {name_test}  от {current_time}.xlsx',
                              index=False, engine='xlsxwriter')



    return out_full_df, out_result_df


def processing_sppu(base_df: pd.DataFrame, answers_df: pd.DataFrame, size: int,name_test):
    """
    Функция для обработки результатов тестирования сферы профессиональных предпочтений учащихся
    :return:
    """
    if answers_df.shape[1] != size:
        raise WrongNumberColumn

    answers_df.columns = [f'{name_test}_Вопрос_ №_{i}' for i in range(1, answers_df.shape[1] + 1)]

    answers_df = answers_df.astype(str)

    answers_df = answers_df.applymap(lambda x: x.strip())

    answers_df[f'{name_test}_Необработанный_результат'] = answers_df.apply(processing_result_sppu, axis=1)
    answers_df[f'{name_test}_Обработанный_результат'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_key_max_value)
    answers_df[f'{name_test}_Числовое_значение_результата'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_max_value)

    # Создаем датафрейм для данных отчета
    report_df = answers_df.iloc[::, size + 1:]

    # Создаем датафрейм в который будем заносить итоговые результаты
    finish_report_df = report_df[f'{name_test}_Обработанный_результат'].value_counts().to_frame()

    # получаем процента
    finish_report_df['Доля_от_общего_количества'] = round(
        (finish_report_df[f'{name_test}_Обработанный_результат'] / report_df.shape[0]) * 100, 2)

    finish_report_df = finish_report_df.reset_index()

    finish_report_df.columns = ['Категория', 'Количество', 'Доля в % от общего количества']

    # соединяем после обработки
    df = pd.concat([base_df, answers_df], axis=1)

    # Создаем строку с описанием
    description_result = """
Шкала оценки результатов
10-12 баллов – ярко выраженная профессиональная склонность;
7-9 баллов – средне выраженная профессиональная склонность;
4-6 баллов – слабо выраженная профессиональная склонность;
0-3 баллов – профессиональная склонность не выражена.

Примеры профессий для каждой сферы
Сфера работы с людьми: учитель, педагог, экскурсовод, воспитатель,  социолог, психолог, менеджер по персоналу, следователь.
Сфера умственного труда: ученый-исследователь (математик, физик, химик, кибернетик, археолог, геолог),  инженер, юрист, врач, эколог, архитектор, продюсер.
Сфера технических интересов:  программист, электротехник, радиотехник, Web-мастер, статистик, водитель, технолог, диспетчер, секретарь-машинистка, телефонист.
Сфера эстетики и искусства: художник, дизайнер, писатель, поэт,  режиссер, артист, конструктор, косметолог, костюмер, гример, кондитер, портной-кутюрье, цветовод. 
Сфера физического труда,  подвижной деятельности: спортсмен, фотограф, экспедитор, парикмахер,  бармен, официант, стюардесса, продавец, закройщик, специалист по ремонту, кассир, медперсонал, бригадир, кладовщик,  почтальон,  фермер,  водитель-дальнобойщик, полицейский, военный.
Сфера материальных интересов,  планово-экономических видов работ: экономист, администратор, менеджер, предприниматель, аудитор, специалист по рекламе, брокер, агент страховых компаний, коммерсант, завхоз.
"""

    if 'ФИО' in df.columns:
        df[f'{name_test}_Описание_результата'] = df['ФИО'] + '.' + ' \nСфера профессиональных предпочтений учащихся.\n' + \
                                         df[f'{name_test}_Необработанный_результат'] + description_result
    else:
        df[f'{name_test}_Описание_результата'] = 'Сфера профессиональных предпочтений учащихся.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result

    # генерируем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)



    # Создаем сокращенный вариант
    send_df = df.iloc[:, :threshold_base]
    # Добавляем колонки с результатами
    send_df[f'{name_test}_Необработанный_результат'] = df[f'{name_test}_Необработанный_результат']
    send_df[f'{name_test}_Обработанный_результат'] = df[f'{name_test}_Обработанный_результат']
    send_df[f'{name_test}_Числовое_значение_результата'] = df[f'{name_test}_Числовое_значение_результата']
    send_df[f'{name_test}_Описание_результата'] = df[f'{name_test}_Описание_результата']
    # создаем датафреймы для возврата в основную функцию
    out_full_df = df.iloc[:, threshold_base:]  # датафрейм с вопросами и результатами без анкетных данных
    out_result_df = send_df.iloc[:, threshold_base:]
    # Сортируем по убыванию
    df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    send_df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)

    df.to_excel(f'{path_to_end_folder_complex}/Полная таблица с результатами {name_test} от {current_time}.xlsx', index=False,
                engine='xlsxwriter')
    send_df.to_excel(f'{path_to_end_folder_complex}/Краткая таблица с результатами {name_test}  от {current_time}.xlsx',
                     index=False, engine='xlsxwriter')

    finish_report_df.to_excel(f'{path_to_end_folder_complex}/Отчет {name_test}  от {current_time}.xlsx',
                              index=False, engine='xlsxwriter')
    return out_full_df, out_result_df


def processing_ddo(base_df: pd.DataFrame, answers_df: pd.DataFrame, size: int,name_test):
    """
    Фугкция для обработки данных ДДО
    :return:
    """
    # Создаем словари для создания текста письма
    global dct_prof
    dct_prof = {
        'Человек-природа': 'Тракторист, рыбовод, зоотехник, агроном, садовник, ветеринар, животновод, геолог, биолог, почвовед и т.д.',
        'Человек-техника': 'Водитель, токарь, инженер, слесарь, радиотехник, швея, электрик, механик, монтажник и т.п.',
        'Человек-человек': 'Продавец, медсестра, секретарь, бортпроводник, учитель, воспитатель, няня, преподаватель, врач, официант, администратор и т.п.',
        'Человек-знаковые системы': 'Наборщик, кассир, делопроизводитель, бухгалтер, программист, чертежник, корректор, экономист, радист, оператор ПЭВМ, машинистка, наборщик и т.п.',
        'Человек-художественный образ': 'Парикмахер, модельер, чеканщик, маляр, гравер, резчик по камню, фотограф, актер, художник, музыкант и т.п.'}

    global dct_desciprion
    dct_desciprion = \
        {'Человек-природа': """Человек-природа.\n
Представителей этих профессий объединяет одно очень важное качество — любовь к 
природе. Но любовь не созерцательная. Которой обладают практически все люди, 
считая природу наиболее благоприятной средой для отдыха, а деятельная связанная с
познанием ее законов и применением их. Одно дело — любить животных и растения,
играть с ними, радоваться им. И совсем другое — регулярно, день за днем ухаживать
за ними, наблюдать, лечить, выгуливать, не считаясь с личным временем и планами.
Специалист должен не просто все знать о живых организмах, но и прогнозировать
возможные изменения в них и принимать меры. От человека требуется инициатива и
самостоятельность в решении конкретных задач, заботливость, терпение и
дальновидность.\n 
Человек, работающий в сфере «человек-природа», должен быть спокойным и уравновешенным.""",
         'Человек-техника': """Человек-техника.\n
Особенность технических объектов в том, что они, как правило, могут быть точно
измерены по многим признакам. При их обработке, преобразовании, перемещении
или оценке от работника требуется точность, определенность действий. Техника как
предмет труда представляет широкие возможности для новаторства, выдумки,
творчества, поэтому важное значение приобретает такое качество, как практическое
мышление. Техническая фантазия, способность мысленно соединять и разъединять
технические объекты и их части — важные условия для успеха в данной области.
""", 'Человек-человек': """Человек-человек.\n
Главное содержание труда в профессиях типа «человек-человек» сводится к
взаимодействию между людьми. Если не наладится это взаимодействие, значит, не
наладится и работа. Качества, необходимые для работы с людьми: устойчивое,
хорошее настроение в процессе работы с людьми, потребность в общении,
способность мысленно ставить себя на место другого человека, быстро понимать
намерения, помыслы, настроение людей, умение разбираться в человеческих
взаимоотношениях, хорошая память (умение держать в уме имена и особенности
многих людей), терпение.
""", 'Человек-знаковые системы': """Человек-знаковая система.\n
Мы встречаемся со знаками значительно чаще, чем обычно представляем себе. Это 
цифры. Коды, условные знаки, естественные или искусственные языки, чертежи,
таблицы формулы. В любом случае человек воспринимает знак как символ реального
объекта или явления. Поэтому специалисту, который работает со знаками, важно
уметь, с одной стороны, абстрагироваться от реальных физических, химически,
механических свойств предметов, а с другой —представлять и воспринимать
характеристики реальных явлений или объектов, стоящих за знаками. Чтобы успешно
работать в какой-нибудь профессии данного типа, необходимо уметь мысленно
погружаться в мир, казалось бы, сухих обозначений и сосредотачиваться на
сведениях, которые они несут в себе. Особые требования профессии этого типа
предъявляют к вниманию.
""", 'Человек-художественный образ': """Человек-художественный образ.\n
Важнейшие требования, которые предъявляют профессии, связанные с изобразительной, музыкальной, литературно-художественной, актерско-сценической деятельностью человека—
Наличие способности к искусствам, творческое воображение, образное мышление, талант, трудолюбие.
"""}

    if answers_df.shape[1] != size:
        raise WrongNumberColumn

    answers_df.columns = [f'{name_test}_Вопрос_ №_{i}' for i in range(1, answers_df.shape[1] + 1)]

    answers_df = answers_df.astype(str)

    answers_df = answers_df.applymap(lambda x: x.strip())
    # получаем результаты
    answers_df[f'{name_test}_Необработанный_результат'] = answers_df.apply(processing_result_ddo, axis=1)
    # обрабатываем результаты и получаем ключ с максимальным значением
    answers_df[f'{name_test}_Обработанный_результат'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_key_max_value)
    answers_df[f'{name_test}_Числовое_значение_результата'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_max_value)
    answers_df[f'{name_test}_Описание_результата'] = answers_df[f'{name_test}_Обработанный_результат'].apply(create_out_str_ddo)

    # Создаем датафрейм для данных отчета
    report_df = answers_df.iloc[::, size + 1:]

    # Создаем датафрейм в который будем заносить итоговые результаты
    finish_report_df = report_df[f'{name_test}_Обработанный_результат'].value_counts().to_frame()

    # получаем процента
    finish_report_df['Доля_от_общего_количества'] = round(
        (finish_report_df[f'{name_test}_Обработанный_результат'] / report_df.shape[0]) * 100, 2)

    finish_report_df = finish_report_df.reset_index()

    finish_report_df.columns = ['Категория', 'Количество', 'Доля в % от общего количества']

    # соединяем после обработки
    df = pd.concat([base_df, answers_df], axis=1)

    # Проверяем наличие колонки ФИО, если она есть то добавляем ее значение, если нет не используем

    if 'ФИО' in df.columns:
        df[f'{name_test}_Описание_результата'] = df['ФИО'] + '.' + ' \nДифференциально-диагностический опросник.\n' + df[
            f'{name_test}_Описание_результата']
    else:
        df[f'{name_test}_Описание_результата'] = 'Дифференциально-диагностический опросник.\n' + df[
            f'{name_test}_Описание_результата']
    # генерируем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)



    # Создаем сокращенный вариант
    send_df = df.iloc[:, :threshold_base]
    # Добавляем колонки с результатами
    send_df[f'{name_test}_Необработанный_результат'] = df[f'{name_test}_Необработанный_результат']
    send_df[f'{name_test}_Обработанный_результат'] = df[f'{name_test}_Обработанный_результат']
    send_df[f'{name_test}_Числовое_значение_результата'] = df[f'{name_test}_Числовое_значение_результата']
    send_df[f'{name_test}_Описание_результата'] = df[f'{name_test}_Описание_результата']
    # создаем датафреймы для возврата в основную функцию, до сортировки
    out_full_df = df.iloc[:, threshold_base:]  # датафрейм с вопросами и результатами без анкетных данных
    out_result_df = send_df.iloc[:, threshold_base:]

    df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    send_df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    df.to_excel(f'{path_to_end_folder_complex}/Полная таблица с результатами {name_test} от {current_time}.xlsx', index=False,
                engine='xlsxwriter')
    send_df.to_excel(f'{path_to_end_folder_complex}/Краткая таблица с результатами {name_test}  от {current_time}.xlsx',
                     index=False, engine='xlsxwriter')
    finish_report_df.to_excel(f'{path_to_end_folder_complex}/Отчет {name_test}  от {current_time}.xlsx',
                              index=False, engine='xlsxwriter')

    return out_full_df, out_result_df




def select_end_folder_complex():
    """
    Функция для выбора конечной папки куда будут складываться итоговые файлы
    :return:
    """
    global path_to_end_folder_complex
    path_to_end_folder_complex = filedialog.askdirectory()


def select_file_data_xlsx_complex():
    """
    Функция для выбора файла с данными на основе которых будет генерироваться документ
    :return: Путь к файлу с данными
    """
    global file_data_xlsx_complex
    # Получаем путь к файлу
    file_data_xlsx_complex = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_file_params_complex():
    """
    Функция для выбора файла с данными на основе которых будет генерироваться документ
    :return: Путь к файлу с данными
    """
    global file_params_complex
    # Получаем путь к файлу
    file_params_complex = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def processing_complex():
    """
    Функция для обработки произвольных тестов в произвольном порядке
    """
    try:
        # потом в ооп когда нибудь перепишу
        # создаем словарь с параметрами скриптов формата {аббревиатура:(название функции для обработки, количество вопросов(колонок))}
        global DCT_PARAMS_SCRIPT
        DCT_PARAMS_SCRIPT = {'ДЦОК': (processing_dcok, 41), 'ОПТЛ': (processing_optl, 30),
                             'СППУ': (processing_sppu, 24), 'ДДО': (processing_ddo, 20)}

        global threshold_base
        threshold_base = var_entry_threshold_complex.get()
        # создаем счетчик обработанных колонок
        threshold_finshed = threshold_base

        # получаем базовый датафрейм
        df = pd.read_excel(file_data_xlsx_complex)

        base_df = df.iloc[:, :threshold_base]  # создаем датафрейм с данными не относящимися к тесту
        # делаем строковыми названия колонок
        base_df.columns = list(map(str, base_df.columns))

        # заменяем пробелы на нижнее подчеркивание и очищаем от пробельных символов в начале и конце
        base_df.columns = [column.strip().replace(' ', '_') for column in base_df.columns]

        # очищаем от всех символов кроме букв цифр
        base_df.columns = [re.sub(r'[^_\d\w]', '', column) for column in base_df.columns]

        params_df = pd.read_excel(file_params_complex, header=None)  # считываем файл с параметрами
        lst_tests = params_df[0].tolist()
        # Создаем копию датафрейма с анкетными данными для передачи в функцию
        base_df_for_func = base_df.copy()
        # создаем копию для датафрейма с результатами
        result_df = base_df.copy()

        # Перебираем полученные названия тестов
        for name_test in lst_tests:
            """
            запускаем функцию хранящуюся в словаре
            передаем туда датафрейм с анкетными данными, датафрейм с данными теста, количество колонок которое занимает данный тест
            получаем 2 датафрейма с результатами для данного теста которые добавляем в основные датафреймы
            """
            # получаем колонки относящиеся к тесту
            temp_df = df.iloc[:, threshold_finshed:threshold_finshed + DCT_PARAMS_SCRIPT[name_test][1]]
            # обрабатываем и получаем датафреймы для добавления в основные таблицы
            temp_full_df, temp_result_df = DCT_PARAMS_SCRIPT[name_test][0](base_df_for_func, temp_df,
                                                                           DCT_PARAMS_SCRIPT[name_test][1],name_test)
            base_df = pd.concat([base_df, temp_full_df],
                                axis=1)  # соединяем анкетные данные и вопросы вместе с результатами
            result_df = pd.concat([result_df, temp_result_df], axis=1)
            # увеличиваем предел обозначающий количество обработанных колонок
            threshold_finshed += DCT_PARAMS_SCRIPT[name_test][1]

        # генерируем текущее время
        t = time.localtime()
        current_time = time.strftime('%H_%M_%S', t)
        # Сохраняем результаты
        base_df.to_excel(
            f'{path_to_end_folder_complex}/Полная таблица с результатами комплексного теста от {current_time}.xlsx',
            index=False,
            engine='xlsxwriter')

        result_df.to_excel(
            f'{path_to_end_folder_complex}/Краткая таблица с результатами комплексного теста от {current_time}.xlsx',
            index=False,
            engine='xlsxwriter')


    except NameError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Выберите файлы с данными и папку куда будет генерироваться файл')
    except KeyError as e:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Название теста не найдено, проверьте правильность написания названия в таблице параметров {e.args}\n'
                             f'Проверьте правильность написания по руководству пользователя')
    except FileNotFoundError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Перенесите файлы которые вы хотите обработать в корень диска. Проблема может быть\n '
                             f'в слишком длинном пути к обрабатываемым файлам')
    except WrongNumberColumn:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Неправильное количество колонок в таблице!\n'
                             f'Проверьте количество вопросов в тестах!\n'
                             f'ДЦОК -41 колонка т.е.41 тестовый вопрос\n'
                             f'ОПТЛ - 30 колонок т.е. 30 тестовых вопросов\n'
                             f'СППУ - 24 колонки т.е. 24 тестовых вопроса\n'
                             f'ДДО - 20 колонок т.е. 20 тестовых вопросов')
    else:
        messagebox.showinfo('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                            'Данные успешно обработаны')


def select_file_template_doc():
    """
    Функция для выбора файла шаблона
    :return: Путь к файлу шаблона
    """
    global name_file_template_doc
    name_file_template_doc = filedialog.askopenfilename(
        filetypes=(('Word files', '*.docx'), ('all files', '*.*')))


def select_file_data_doc():
    """
    Функция для выбора файла с данными на основе которых будет генерироваться документ
    :return: Путь к файлу с данными
    """
    global name_file_data_doc
    # Получаем путь к файлу
    name_file_data_doc = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_end_folder_doc():
    """
    Функция для выбора папки куда будут генерироваться файлы
    :return:
    """
    global path_to_end_folder_doc
    path_to_end_folder_doc = filedialog.askdirectory()


def create_doc_convert_date(cell):
    """
    Функция для конвертации даты при создании документов
    :param cell:
    :return:
    """
    try:
        string_date = datetime.datetime.strftime(cell, '%d.%m.%Y')
        return string_date
    except ValueError:
        return 'Не удалось конвертировать дату.Проверьте значение ячейки!!!'
    except TypeError:
        return 'Не удалось конвертировать дату.Проверьте значение ячейки!!!'


def combine_all_docx(filename_master, files_lst):
    """
    Функция для объединения файлов Word взято отсюда
    https://stackoverflow.com/questions/24872527/combine-word-document-using-python-docx
    :param filename_master: базовый файл
    :param files_list: список с созданными файлами
    :return: итоговый файл
    """
    # Получаем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)

    number_of_sections = len(files_lst)
    # Открываем и обрабатываем базовый файл
    master = Document(filename_master)
    composer = Composer(master)
    # Перебираем и добавляем файлы к базовому
    for i in range(0, number_of_sections):
        doc_temp = Document(files_lst[i])
        composer.append(doc_temp)
    # Сохраняем файл
    composer.save(f"{path_to_end_folder_doc}/Объединеный файл от {current_time}.docx")


def generate_docs_other():
    """
    Функция для создания документов из произвольных таблиц(т.е. отличающихся от структуры базы данных Веста Обработка таблиц и создание документов ver 1.29)
    :return:
    """
    try:
        name_column = entry_name_column_data.get()
        name_type_file = entry_type_file.get()
        name_value_column = entry_value_column.get()

        # Считываем данные
        # Добавил параметр dtype =str чтобы данные не преобразовались а использовались так как в таблице
        df = pd.read_excel(name_file_data_doc, dtype=str)

        # Заполняем Nan
        df.fillna(' ', inplace=True)

        lst_date_columns = []
        # Перебираем

        for idx, column in enumerate(df.columns):
            if 'дата' in column.lower():
                lst_date_columns.append(idx)

        # Конвертируем в пригодный строковый формат
        for i in lst_date_columns:
            df.iloc[:, i] = pd.to_datetime(df.iloc[:, i], errors='coerce', dayfirst=True)
            df.iloc[:, i] = df.iloc[:, i].apply(create_doc_convert_date)

        # Конвертируем датафрейм в список словарей
        data = df.to_dict('records')
        # Получаем состояние  чекбокса объединения файлов в один

        mode_combine = mode_combine_value.get()
        # Получаем состояние чекбокса создания индвидуального файла
        mode_group = mode_group_doc.get()

        # В зависимости от состояния чекбоксов обрабатываем файлы
        if mode_combine == 'No':
            if mode_group == 'No':
                # Создаем в цикле документы
                for idx,row in enumerate(data):
                    doc = DocxTemplate(name_file_template_doc)
                    context = row
                    # print(context)
                    doc.render(context)
                    # Сохраняенм файл0
                    name_file = f'{name_type_file} {row[name_column]}'
                    name_file = re.sub(r'[<> :"?*|\\/]', ' ', name_file)
                    # проверяем файл на наличие, если файл с таким названием уже существует то добавляем окончание
                    if os.path.exists(f'{path_to_end_folder_doc}/{name_file}.docx'):
                        doc.save(f'{path_to_end_folder_doc}/{name_file}_{idx}.docx')
                    doc.save(f'{path_to_end_folder_doc}/{name_file}.docx')
            else:
                # Отбираем по значению строку

                single_df = df[df[name_column] == name_value_column]
                # Конвертируем датафрейм в список словарей
                single_data = single_df.to_dict('records')
                # Проверяем количество найденных совпадений
                # очищаем от запрещенных символов
                name_file = f'{name_type_file} {name_value_column}'
                name_file = re.sub(r'[<> :"?*|\\/]', ' ', name_file)
                if len(single_data) == 1:
                    for row in single_data:
                        doc = DocxTemplate(name_file_template_doc)
                        doc.render(row)
                        # Сохраняенм файл
                        doc.save(f'{path_to_end_folder_doc}/{name_file}.docx')
                elif len(single_data) > 1:
                    for idx, row in enumerate(single_data):
                        doc = DocxTemplate(name_file_template_doc)
                        doc.render(row)
                        # Сохраняенм файл
                        doc.save(f'{path_to_end_folder_doc}/{name_file}_{idx}.docx')
                else:
                    raise NotFoundValue



        else:
            if mode_group == 'No':
                # Список с созданными файлами
                files_lst = []
                # Создаем временную папку
                with tempfile.TemporaryDirectory() as tmpdirname:
                    print('created temporary directory', tmpdirname)
                    # Создаем и сохраняем во временную папку созданные документы Word
                    for row in data:
                        doc = DocxTemplate(name_file_template_doc)
                        context = row
                        doc.render(context)
                        # Сохраняем файл
                        #очищаем от запрещенных символов
                        name_file = f'{row[name_column]}'
                        name_file = re.sub(r'[<> :"?*|\\/]', ' ', name_file)

                        doc.save(f'{tmpdirname}/{name_file}.docx')
                        # Добавляем путь\ к файлу в список
                        files_lst.append(f'{tmpdirname}/{name_file}.docx')
                    # Получаем базовый файл
                    main_doc = files_lst.pop(0)
                    # Запускаем функцию
                    combine_all_docx(main_doc, files_lst)
            else:
                raise CheckBoxException


    except NameError as e:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Выберите шаблон,файл с данными и папку куда будут генерироваться файлы')
        logging.exception('AN ERROR HAS OCCURRED')
    except KeyError as e:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'В таблице не найдена указанная колонка {e.args}')
    except PermissionError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Закройте все файлы Word созданные Вестой')
        logging.exception('AN ERROR HAS OCCURRED')
    except FileNotFoundError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Перенесите файлы которые вы хотите обработать в корень диска. Проблема может быть\n '
                             f'в слишком длинном пути к обрабатываемым файлам')
    except CheckBoxException:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Уберите галочку из чекбокса Поставьте галочку, если вам нужно создать один документ\nдля конкретного значения (например для определенного ФИО)'
                             )
    except NotFoundValue:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Указанное значение не найдено в выбранной колонке\nПроверьте наличие такого значения в таблице'
                             )
    except:
        logging.exception('AN ERROR HAS OCCURRED')
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             'Возникла ошибка!!! Подробности ошибки в файле error.log')

    else:
        messagebox.showinfo('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                            'Создание документов завершено!')

def select_file_params_comparsion():
    """
    Функция для выбора файла с параметрами колонок т.е. кокие колонки нужно обрабатывать
    :return:
    """
    global file_params
    file_params = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_first_comparison():
    """
    Функция для выбора  первого файла с данными которые нужно сравнить
    :return: Путь к файлу с данными
    """
    global name_first_file_comparison
    # Получаем путь к файлу
    name_first_file_comparison = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_second_comparison():
    """
    Функция для выбора  второго файла с данными которые нужно сравнить
    :return: Путь к файлу с данными
    """
    global name_second_file_comparison
    # Получаем путь к файлу
    name_second_file_comparison = filedialog.askopenfilename(
        filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_end_folder_comparison():
    """
    Функция для выбора папки куда будет генерироваться итоговый файл
    :return:
    """
    global path_to_end_folder_comparison
    path_to_end_folder_comparison = filedialog.askdirectory()

def convert_columns_to_str(df, number_columns):
    """
    Функция для конвертации указанных столбцов в строковый тип и очистки от пробельных символов в начале и конце
    """

    for column in number_columns:  # Перебираем список нужных колонок
        try:
            df.iloc[:, column] = df.iloc[:, column].astype(str)
            # Очищаем колонку от пробельных символов с начала и конца
            df.iloc[:, column] = df.iloc[:, column].apply(lambda x: x.strip())
        except IndexError:
            messagebox.showerror('Веста Обработка таблиц и создание документов ver 1.29',
                                 'Проверьте порядковые номера колонок которые вы хотите обработать.')


def convert_params_columns_to_int(lst):
    """
    Функция для конвератации значений колонок которые нужно обработать.
    Очищает от пустых строк, чтобы в итоге остался список из чисел в формате int
    """
    out_lst = [] # Создаем список в который будем добавлять только числа
    for value in lst: # Перебираем список
        try:
            # Обрабатываем случай с нулем, для того чтобы после приведения к питоновскому отсчету от нуля не получилась колонка с номером -1
            number = int(value)
            if number != 0:
                out_lst.append(value) # Если конвертирования прошло без ошибок то добавляем
            else:
                continue
        except: # Иначе пропускаем
            continue
    return out_lst


def clean_ending_columns(lst_columns:list,name_first_df,name_second_df):
    """
    Функция для очистки колонок таблицы с совпадающими данными от окончаний _x _y

    :param lst_columns:
    :param time_generate
    :param name_first_df
    :param name_second_df
    :return:
    """
    out_columns = [] # список для очищенных названий
    for name_column in lst_columns:
        if '_x' in name_column:
            # если они есть то проводим очистку и добавление времени
            cut_name_column = name_column[:-2] # обрезаем
            temp_name = f'{cut_name_column}_{name_first_df}' # соединяем
            out_columns.append(temp_name) # добавляем
        elif '_y' in name_column:
            cut_name_column = name_column[:-2]  # обрезаем
            temp_name = f'{cut_name_column}_{name_second_df}'  # соединяем
            out_columns.append(temp_name)  # добавляем
        else:
            out_columns.append(name_column)
    return out_columns

def processing_comparison():
    """
    Функция для сравнения 2 колонок
    :return:
    """
    try:
        # Получаем значения текстовых полей
        first_sheet_name = str(entry_first_sheet_name.get())
        second_sheet_name = str(entry_second_sheet_name.get())
        # загружаем файлы
        first_df = pd.read_excel(name_first_file_comparison, sheet_name=first_sheet_name, dtype=str,
                                 keep_default_na=False)
        # получаем имя файла
        name_first_df = name_first_file_comparison.split('/')[-1]
        name_first_df = name_first_df.split('.xlsx')[0]

        second_df = pd.read_excel(name_second_file_comparison, sheet_name=second_sheet_name, dtype=str,
                                  keep_default_na=False)
        # получаем имя файла
        name_second_df = name_second_file_comparison.split('/')[-1]
        name_second_df = name_second_df.split('.xlsx')[0]

        params = pd.read_excel(file_params, header=None, keep_default_na=False)

        # Преврашаем каждую колонку в список
        params_first_columns = params[0].tolist()
        params_second_columns = params[1].tolist()

        # Конвертируем в инт заодно проверяя корректность введенных данных
        int_params_first_columns = convert_params_columns_to_int(params_first_columns)
        int_params_second_columns = convert_params_columns_to_int(params_second_columns)

        # Отнимаем 1 от каждого значения чтобы привести к питоновским индексам
        int_params_first_columns = list(map(lambda x: x - 1, int_params_first_columns))
        int_params_second_columns = list(map(lambda x: x - 1, int_params_second_columns))

        # Конвертируем нужные нам колонки в str
        convert_columns_to_str(first_df, int_params_first_columns)
        convert_columns_to_str(second_df, int_params_second_columns)

        # Проверяем наличие колонок с датами в списке колонок для объединения чтобы привести их в нормальный вид
        for number_column_params in int_params_first_columns:
            if 'дата' in first_df.columns[number_column_params].lower():
                first_df.iloc[:, number_column_params] = pd.to_datetime(first_df.iloc[:, number_column_params],
                                                                        errors='coerce', dayfirst=True)
                first_df.iloc[:, number_column_params] = first_df.iloc[:, number_column_params].apply(
                    create_doc_convert_date)

        for number_column_params in int_params_second_columns:
            if 'дата' in second_df.columns[number_column_params].lower():
                second_df.iloc[:, number_column_params] = pd.to_datetime(second_df.iloc[:, number_column_params],
                                                                         errors='coerce', dayfirst=True)
                second_df.iloc[:, number_column_params] = second_df.iloc[:, number_column_params].apply(
                    create_doc_convert_date)

        # в этом месте конвертируем даты в формат ДД.ММ.ГГГГ
        # processing_date_column(first_df, int_params_first_columns)
        # processing_date_column(second_df, int_params_second_columns)

        # Проверяем наличие колонки _merge
        if '_merge' in first_df.columns:
            first_df.drop(columns=['_merge'], inplace=True)
        if '_merge' in second_df.columns:
            second_df.drop(columns=['_merge'], inplace=True)
        # Проверяем наличие колонки ID
        if 'ID_объединения' in first_df.columns:
            first_df.drop(columns=['ID_объединения'], inplace=True)
        if 'ID_объединения' in second_df.columns:
            second_df.drop(columns=['ID_объединения'], inplace=True)

        # Создаем в каждом датафрейме колонку с айди путем склеивания всех нужных колонок в одну строку
        first_df['ID_объединения'] = first_df.iloc[:, int_params_first_columns].sum(axis=1)
        second_df['ID_объединения'] = second_df.iloc[:, int_params_second_columns].sum(axis=1)

        first_df['ID_объединения'] = first_df['ID_объединения'].apply(lambda x: x.replace(' ', ''))
        second_df['ID_объединения'] = second_df['ID_объединения'].apply(lambda x: x.replace(' ', ''))


        # В результат объединения попадают совпадающие по ключу записи обеих таблиц и все строки из этих двух таблиц, для которых пар не нашлось. Порядок таблиц в запросе не

        # Создаем документ
        wb = openpyxl.Workbook()
        # создаем листы
        ren_sheet = wb['Sheet']
        ren_sheet.title = 'Таблица 1'
        wb.create_sheet(title='Таблица 2', index=1)
        wb.create_sheet(title='Совпадающие данные', index=2)
        wb.create_sheet(title='Обновленная таблица', index=3)
        wb.create_sheet(title='Объединённая таблица', index=4)


        # Создаем переменные содержащие в себе количество колонок в базовых датареймах
        first_df_quantity_cols = len(first_df.columns)  # не забываем что там добавилась колонка ID

        # Проводим слияние
        itog_df = pd.merge(first_df, second_df, how='outer', left_on=['ID_объединения'], right_on=['ID_объединения'],
                           indicator=True)

        # копируем в отдельный датафрейм для создания таблицы с обновлениями
        update_df = itog_df.copy()

        # Записываем каждый датафрейм в соответсвующий лист
        # Левая таблица
        left_df = itog_df[itog_df['_merge'] == 'left_only']
        left_df.drop(['_merge'], axis=1, inplace=True)

        # Удаляем колонки второй таблицы чтобы не мешались
        left_df.drop(left_df.iloc[:, first_df_quantity_cols:], axis=1, inplace=True)

        # Переименовываем колонки у которых были совпадение во второй таблице, в таких колонках есть добавление _x
        clean_left_columns = list(map(lambda x: x[:-2] if '_x' in x else x, list(left_df.columns)))
        left_df.columns = clean_left_columns
        for r in dataframe_to_rows(left_df, index=False, header=True):
            wb['Таблица 1'].append(r)

        right_df = itog_df[itog_df['_merge'] == 'right_only']
        right_df.drop(['_merge'], axis=1, inplace=True)

        # Удаляем колонки первой таблицы таблицы чтобы не мешались
        right_df.drop(right_df.iloc[:, :first_df_quantity_cols - 1], axis=1, inplace=True)

        # Переименовываем колонки у которых были совпадение во второй таблице, в таких колонках есть добавление _x
        clean_right_columns = list(map(lambda x: x[:-2] if '_y' in x else x, list(right_df.columns)))
        right_df.columns = clean_right_columns

        for r in dataframe_to_rows(right_df, index=False, header=True):
            wb['Таблица 2'].append(r)

        both_df = itog_df[itog_df['_merge'] == 'both']
        both_df.drop(['_merge'], axis=1, inplace=True)
        # Очищаем от _x  и _y
        clean_both_columns = clean_ending_columns(list(both_df.columns), name_first_df, name_second_df)
        both_df.columns = clean_both_columns

        for r in dataframe_to_rows(both_df, index=False, header=True):
            wb['Совпадающие данные'].append(r)

        # Сохраняем общую таблицу
        # Заменяем названия индикаторов на более понятные
        itog_df['_merge'] = itog_df['_merge'].apply(lambda x: 'Данные из первой таблицы' if x == 'left_only' else
        ('Данные из второй таблицы' if x == 'right_only' else 'Совпадающие данные'))
        itog_df['_merge'] = itog_df['_merge'].astype(str)

        clean_itog_df = clean_ending_columns(list(itog_df.columns), name_first_df, name_second_df)
        itog_df.columns = clean_itog_df
        for r in dataframe_to_rows(itog_df, index=False, header=True):
            wb['Объединённая таблица'].append(r)

        # получаем список с совпадающими колонками первой таблицы
        first_df_columns = [column for column in list(update_df.columns) if str(column).endswith('_x')]
        # получаем список с совпадающими колонками второй таблицы
        second_df_columns = [column for column in list(update_df.columns) if str(column).endswith('_y')]
        # Создаем из списка совпадающих колонок второй таблицы словарь, чтобы было легче обрабатывать
        # да конечно можно было сделать в одном выражении но как я буду читать это через 2 недели?
        dct_second_columns = {column.split('_y')[0]: column for column in second_df_columns}

        for column in first_df_columns:
            # очищаем от _x
            name_column = column.split('_x')[0]
            # Обновляем значение в случае если в колонке _merge стоит both, иначе оставляем старое значение,
            # Чтобы обновить значение в ячейке, во второй таблице не должно быть пустого значения или пробела в аналогичной колонке

            update_df[column] = np.where(
                (update_df['_merge'] == 'both') & (update_df[dct_second_columns[name_column]]) & (
                            update_df[dct_second_columns[name_column]] != ' '),
                update_df[dct_second_columns[name_column]], update_df[column])

            # Удаляем колонки с _y
        update_df.drop(columns=[column for column in update_df.columns if column.endswith('_y')], inplace=True)

        # Переименовываем колонки с _x
        update_df.columns = list(map(lambda x: x[:-2] if x.endswith('_x') else x, update_df.columns))

        # удаляем строки с _merge == right_only
        update_df = update_df[update_df['_merge'] != 'right_only']

        # Удаляем служебные колонки
        update_df.drop(columns=['ID_объединения', '_merge'], inplace=True)

        # используем уже созданный датафрейм right_df Удаляем лишнюю колонку в right_df
        right_df.drop(columns=['ID_объединения'], inplace=True)

        # Добавляем нехватающие колонки
        new_right_df = right_df.reindex(columns=update_df.columns, fill_value=None)

        update_df = pd.concat([update_df, new_right_df])

        for r in dataframe_to_rows(update_df, index=False, header=True):
            wb['Обновленная таблица'].append(r)

        # генерируем текущее время
        t = time.localtime()
        current_time = time.strftime('%H_%M_%S', t)
        # Сохраняем итоговый файл
        wb.save(f'{path_to_end_folder_comparison}/Результат слияния 2 таблиц от {current_time}.xlsx')
        # Сохраняем отдельно обновленную таблицу
        update_df.to_excel(
            f'{path_to_end_folder_comparison}/Таблица с обновленными данными и колонками от {current_time}.xlsx',
            index=False)

    except NameError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Выберите файлы с данными и папку куда будет генерироваться файл')
        logging.exception('AN ERROR HAS OCCURRED')
    except KeyError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'В таблице нет такой колонки!\nПроверьте написание названия колонки')
        logging.exception('AN ERROR HAS OCCURRED')
    except ValueError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'В таблице нет листа с таким названием!\nПроверьте написание названия листа')
        logging.exception('AN ERROR HAS OCCURRED')
    except FileNotFoundError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Перенесите файлы которые вы хотите обработать в корень диска. Проблема может быть\n '
                             f'в слишком длинном пути к обрабатываемым файлам')
    except:
        logging.exception('AN ERROR HAS OCCURRED')
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             'Возникла ошибка!!! Подробности ошибки в файле error.log')
    else:
        messagebox.showinfo('Лахеcис Обработка результатов профориентационных тестов ver 5.0', 'Данные успешно обработаны')


"""
Подсчет данных
"""

def select_file_data_groupby():
    """
    Функция для выбора файла с данными
    :return:
    """
    global name_file_data_groupby
    # Получаем путь к файлу
    name_file_data_groupby = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_end_folder_groupby():
    """
    Функция для выбора папки куда будет генерироваться итоговый файл
    :return:
    """
    global path_to_end_folder_groupby
    path_to_end_folder_groupby = filedialog.askdirectory()


def groupby_category():
    """
    Функция для подсчета выбранной колонки по категориям
    :return:
    """
    try:
        df = pd.read_excel(name_file_data_groupby)
        df.columns = list(map(str, list(df.columns)))
        # Создаем шрифт которым будем выделять названия таблиц
        font_name_table = Font(name='Arial Black', size=15, italic=True)
        # Создаем файл excel
        wb = openpyxl.Workbook()

        # Проверяем наличие возможных дубликатов ,котороые могут получиться если обрезать по 30 символов
        lst_length_column = [column[:30] for column in df.columns]
        check_dupl_length = [k for k,v in Counter(lst_length_column).items() if v>1]

        # проверяем наличие объединенных ячеек
        check_merge = [column for column in df.columns if 'Unnamed' in column]
        # если есть хоть один Unnamed то просто заменяем названия колонок на Колонка №цифра
        if check_merge or check_dupl_length:
            df.columns = [f'Колонка №{i}' for i in range(1, df.shape[1] + 1)]
        # очищаем названия колонок от символов */\ []''
        # Создаем регулярное выражение
        pattern_symbols = re.compile(r"[/*'\[\]/\\]")
        clean_df_columns = [re.sub(pattern_symbols,'',column) for column in df.columns]
        df.columns = clean_df_columns

        # Добавляем столбец для облегчения подсчета по категориям
        df['Для подсчета'] = 1

        # Создаем листы
        for idx, name_column in enumerate(df.columns):
            # Делаем короткое название не более 30 символов
            wb.create_sheet(title=name_column[:30], index=idx)

        for idx, name_column in enumerate(df.columns):
            group_df = df.groupby([name_column]).agg({'Для подсчета': 'sum'})
            group_df.columns = ['Количество']

            # Сортируем по убыванию
            group_df.sort_values(by=['Количество'], inplace=True, ascending=False)

            for r in dataframe_to_rows(group_df, index=True, header=True):
                if len(r) != 1:
                    wb[name_column[:30]].append(r)
            wb[name_column[:30]].column_dimensions['A'].width = 50

        # генерируем текущее время
        t = time.localtime()
        current_time = time.strftime('%H_%M_%S', t)
        # Удаляем листы
        del wb['Sheet']
        del wb['Для подсчета']
        # Сохраняем итоговый файл
        wb.save(
            f'{path_to_end_folder_groupby}/Подсчет частоты значений для всех колонок таблицы от {current_time}.xlsx')

    except NameError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Выберите файл с данными и папку куда будет генерироваться файл')

    except FileNotFoundError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Перенесите файлы которые вы хотите обработать в корень диска. Проблема может быть\n '
                             f'в слишком длинном пути к обрабатываемым файлам')
    except:
        logging.exception('AN ERROR HAS OCCURRED')
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             'Возникла ошибка!!! Подробности ошибки в файле error.log')
    else:
        messagebox.showinfo('Лахеcис Обработка результатов профориентационных тестов ver 5.0', 'Данные успешно обработаны')


def groupby_stat():
    """
    Функция для подсчета выбранной колонки по количественным показателям(сумма,среднее,медиана,мин,макс)
    :return:
    """

    try:
        df = pd.read_excel(name_file_data_groupby)
        # Делаем названия колонок строковыми
        df.columns = list(map(str, list(df.columns)))

        # Создаем шрифт которым будем выделять названия таблиц
        font_name_table = Font(name='Arial Black', size=15, italic=True)
        # Создаем файл excel
        wb = openpyxl.Workbook()

        # Проверяем наличие возможных дубликатов ,котороые могут получиться если обрезать по 30 символов
        lst_length_column = [column[:30] for column in df.columns]
        check_dupl_length = [k for k,v in Counter(lst_length_column).items() if v>1]

        # проверяем наличие объединенных ячеек
        check_merge = [column for column in df.columns if 'Unnamed' in column]
        # если есть хоть один Unnamed или дубликат то просто заменяем названия колонок на Колонка №цифра
        if check_merge or check_dupl_length:
            df.columns = [f'Колонка №{i}' for i in range(1, df.shape[1] + 1)]

        # очищаем названия колонок от символов */\ []''
        # Создаем регулярное выражение
        pattern_symbols = re.compile(r"[/*'\[\]/\\]")
        clean_df_columns = [re.sub(pattern_symbols,'',column) for column in df.columns]
        df.columns = clean_df_columns


        # Добавляем столбец для облегчения подсчета по категориям
        df['Итого'] = 1

        # Создаем листы
        for idx, name_column in enumerate(df.columns):
            # Делаем короткое название не более 30 символов
            wb.create_sheet(title=name_column[:30], index=idx)

        for idx, name_column in enumerate(df.columns):
            group_df = df[name_column].describe().to_frame()
            if group_df.shape[0] == 8:
                # подсчитаем сумму
                all_sum = df[name_column].sum()
                dct_row = {name_column: all_sum}
                row = pd.DataFrame(data=dct_row, index=['Сумма'])
                # Добавим в датафрейм
                group_df = pd.concat([group_df, row], axis=0)

                # Обновим названия индексов
                group_df.index = ['Количество значений', 'Среднее', 'Стандартное отклонение', 'Минимальное значение',
                                  '25%(Первый квартиль)', 'Медиана', '75%(Третий квартиль)', 'Максимальное значение',
                                  'Сумма']

            elif group_df.shape[0] == 4:
                group_df.index = ['Количество значений', 'Количество уникальных значений', 'Самое частое значение',
                                  'Количество повторений самого частого значения', ]
            for r in dataframe_to_rows(group_df, index=True, header=True):
                if len(r) != 1:
                    wb[name_column[:30]].append(r)
            wb[name_column[:30]].column_dimensions['A'].width = 50

        # генерируем текущее время
        t = time.localtime()
        current_time = time.strftime('%H_%M_%S', t)
        # Удаляем лист
        del wb['Sheet']
        del wb['Итого']
        # Сохраняем итоговый файл
        wb.save(
            f'{path_to_end_folder_groupby}/Подсчет базовых статистик для всех колонок таблицы от {current_time}.xlsx')



    except NameError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Выберите файл с данными и папку куда будет генерироваться файл')
        logging.exception('AN ERROR HAS OCCURRED')

    except FileNotFoundError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Перенесите файлы которые вы хотите обработать в корень диска. Проблема может быть\n '
                             f'в слишком длинном пути к обрабатываемым файлам')
    except:
        logging.exception('AN ERROR HAS OCCURRED')
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             'Возникла ошибка!!! Подробности ошибки в файле error.log')

    else:
        messagebox.showinfo('Лахеcис Обработка результатов профориентационных тестов ver 5.0', 'Данные успешно обработаны')


"""
Обработка дат рождения
"""
def calculate_age(born):
    """
    Функция для расчета текущего возраста взято с https://stackoverflow.com/questions/2217488/age-from-birthdate-in-python/9754466#9754466
    :param born: дата рождения
    :return: возраст
    """

    try:

        # today = date.today()
        selected_date = pd.to_datetime(raw_selected_date, dayfirst=True)
        # return today.year - born.year - ((today.month, today.day) < (born.month, born.day))
        return selected_date.year - born.year - ((selected_date.month, selected_date.day) < (born.month, born.day))

    except ValueError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Введена некорректная дата относительно которой нужно провести обработку\nПример корректной даты 01.09.2022')
        logging.exception('AN ERROR HAS OCCURRED')
        quit()


def convert_date(cell):
    """
    Функция для конвертации даты в формате 1957-05-10 в формат 10.05.1957(строковый)
    """

    try:
        string_date = datetime.datetime.strftime(cell, '%d.%m.%Y')
        return string_date

    except TypeError:
        print(cell)
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             'Проверьте правильность заполнения ячеек с датой!!!')
        logging.exception('AN ERROR HAS OCCURRED')
        quit()

def select_end_folder_date():
    """
    Функция для выбора папки куда будет генерироваться итоговый файл
    :return:
    """
    global path_to_end_folder_date
    path_to_end_folder_date = filedialog.askdirectory()

def select_file_data_date():
    """
    Функция для выбора файла с данными для которого нужно разбить по категориям
    :return: Путь к файлу с данными
    """
    global name_file_data_date
    # Получаем путь к файлу
    name_file_data_date = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))

def check_date_columns(i, value):
    """
    Функция для проверки типа колонки. Необходимо найти колонки с датой
    :param i:
    :param value:
    :return:
    """
    try:
        itog = pd.to_datetime(str(value), infer_datetime_format=True)
    except:
        pass
    else:
        return i


def set_rus_locale():
    """
    Функция чтобы можно было извлечь русские названия месяцев
    """
    locale.setlocale(
        locale.LC_ALL,
        'rus_rus' if sys.platform == 'win32' else 'ru_RU.UTF-8')

def processing_date_column(df, lst_columns):
    """
    Функция для обработки столбцов с датами. конвертация в строку формата ДД.ММ.ГГГГ
    """
    # получаем первую строку
    first_row = df.iloc[0, lst_columns]

    lst_first_row = list(first_row)  # Превращаем строку в список
    lst_date_columns = []  # Создаем список куда будем сохранять колонки в которых находятся даты
    tupl_row = list(zip(lst_columns,
                        lst_first_row))  # Создаем список кортежей формата (номер колонки,значение строки в этой колонке)

    for idx, value in tupl_row:  # Перебираем кортеж
        result = check_date_columns(idx, value)  # проверяем является ли значение датой
        if result:  # если да то добавляем список порядковый номер колонки
            lst_date_columns.append(result)
        else:  # иначе проверяем следующее значение
            continue
    for i in lst_date_columns:  # Перебираем список с колонками дат, превращаем их в даты и конвертируем в нужный строковый формат
        df.iloc[:, i] = pd.to_datetime(df.iloc[:, i], errors='coerce', dayfirst=True)
        df.iloc[:, i] = df.iloc[:, i].apply(create_doc_convert_date)


def extract_number_month(cell):
    """
    Функция для извлечения номера месяца
    """
    return cell.month


def extract_name_month(cell):
    """
    Функция для извлечения названия месяца
    Взято отсюда https://ru.stackoverflow.com/questions/1045154/Вывод-русских-символов-из-pd-timestamp-month-name
    """
    return cell.month_name(locale='Russian')


def extract_year(cell):
    """
    Функция для извлечения года рождения
    """
    return cell.year


def calculate_date():
    """
    Функция для разбиения по категориям, подсчета текущего возраста и выделения месяца,года
    :return:
    """
    try:
        # делаем глобальным значение даты.Дада я знаю что это костыль
        global raw_selected_date
        raw_selected_date = entry_date.get()

        name_column = entry_name_column.get()
        # Устанавливаем русскую локаль
        set_rus_locale()

        # Считываем файл
        df = pd.read_excel(name_file_data_date)
        # Конвертируем его в формат даты
        # В случае ошибок заменяем значение NaN
        df[name_column] = pd.to_datetime(df[name_column], dayfirst=True, errors='coerce')
        # Создаем шрифт которым будем выделять названия таблиц
        font_name_table = Font(name='Arial Black', size=15, italic=True)

        # Создаем файл excel
        wb = openpyxl.Workbook()
        # Создаем листы
        # Переименовываем лист чтобы в итоговом файле не было пустого листа
        ren_sheet = wb['Sheet']
        ren_sheet.title = 'Итоговая таблица'

        # wb.create_sheet(title='Итоговая таблица', index=0)
        wb.create_sheet(title='Свод по возрастам', index=1)
        wb.create_sheet(title='Свод по месяцам', index=2)
        wb.create_sheet(title='Свод по годам', index=3)
        wb.create_sheet(title='Свод по 1-ПК', index=4)
        wb.create_sheet(title='Свод по 1-ПО', index=5)
        wb.create_sheet(title='Свод по СПО-1', index=6)
        wb.create_sheet(title='Свод по категориям Росстата', index=7)

        # Подсчитываем текущий возраст
        df['Текущий возраст'] = df[name_column].apply(calculate_age)

        # Получаем номер месяца
        df['Порядковый номер месяца рождения'] = df[name_column].apply(extract_number_month)

        # Получаем название месяца
        df['Название месяца рождения'] = df[name_column].apply(extract_name_month)

        # Получаем год рождения
        df['Год рождения'] = df[name_column].apply(extract_year)

        # Присваиваем категорию по 1-ПК
        df['1-ПК Категория'] = pd.cut(df['Текущий возраст'], [0, 24, 29, 34, 39, 44, 49, 54, 59, 64, 101, 10000],
                                      labels=['моложе 25 лет', '25-29', '30-34', '35-39',
                                              '40-44', '45-49', '50-54', '55-59', '60-64',
                                              '65 и более',
                                              'Возраст  больше 101'])
        # Приводим к строковому виду, иначе не запишется на лист
        df['1-ПК Категория'] = df['1-ПК Категория'].astype(str)

        # Присваиваем категорию по 1-ПО
        df['1-ПО Категория'] = pd.cut(df['Текущий возраст'],
                                      [0, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
                                       26, 27, 28,
                                       29, 34, 39, 44, 49, 54, 59, 64, 101],
                                      labels=['моложе 14 лет', '14 лет', '15 лет',
                                              '16 лет',
                                              '17 лет', '18 лет', '19 лет', '20 лет',
                                              '21 год', '22 года',
                                              '23 года', '24 года', '25 лет',
                                              '26 лет', '27 лет', '28 лет', '29 лет',
                                              '30-34 лет',
                                              '35-39 лет', '40-44 лет', '45-49 лет',
                                              '50-54 лет',
                                              '55-59 лет',
                                              '60-64 лет',
                                              '65 лет и старше'])
        # Приводим к строковому виду, иначе не запишется на лист
        df['1-ПО Категория'] = df['1-ПО Категория'].astype(str)

        # Присваиваем категорию по 1-СПО
        df['СПО-1 Категория'] = pd.cut(df['Текущий возраст'],
                                       [0, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 34,
                                        39,
                                        101],
                                       labels=['моложе 13 лет', '13 лет', '14 лет', '15 лет', '16 лет', '17 лет',
                                               '18 лет',
                                               '19 лет', '20 лет'
                                           , '21 год', '22 года', '23 года', '24 года', '25 лет', '26 лет', '27 лет',
                                               '28 лет',
                                               '29 лет',
                                               '30-34 лет', '35-39 лет', '40 лет и старше'])
        ## Приводим к строковому виду, иначе не запишется на лист
        df['СПО-1 Категория'] = df['СПО-1 Категория'].astype(str)

        # Присваиваем категорию по Росстату
        df['Росстат Категория'] = pd.cut(df['Текущий возраст'],
                                         [0, 4, 9, 14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64, 69, 200],
                                         labels=['0-4', '5-9', '10-14', '15-19', '20-24', '25-29', '30-34',
                                                 '35-39', '40-44', '45-49', '50-54', '55-59', '60-64', '65-69',
                                                 '70 лет и старше'])
        ## Приводим к строковому виду, иначе не запишется на лист
        df['Росстат Категория'] = df['Росстат Категория'].astype(str)

        # Заполняем пустые строки
        df.fillna('Не заполнено!!!', inplace=True)

        # заполняем сводные таблицы
        # Сводная по возрастам

        df_svod_by_age = df.groupby(['Текущий возраст']).agg({name_column: 'count'})
        df_svod_by_age.columns = ['Количество']

        for r in dataframe_to_rows(df_svod_by_age, index=True, header=True):
            wb['Свод по возрастам'].append(r)

        # Сводная по месяцам
        df_svod_by_month = df.groupby(['Название месяца рождения']).agg({name_column: 'count'})
        df_svod_by_month.columns = ['Количество']

        # Сортируем индекс чтобы месяцы шли в хоронологическом порядке
        # Взял отсюда https://stackoverflow.com/questions/40816144/pandas-series-sort-by-month-index
        df_svod_by_month.index = pd.CategoricalIndex(df_svod_by_month.index,
                                                     categories=['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
                                                                 'Июль',
                                                                 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
                                                     ordered=True)
        df_svod_by_month.sort_index(inplace=True)

        for r in dataframe_to_rows(df_svod_by_month, index=True, header=True):
            wb['Свод по месяцам'].append(r)

        # Сводная по годам
        df_svod_by_year = df.groupby(['Год рождения']).agg({name_column: 'count'})
        df_svod_by_year.columns = ['Количество']

        for r in dataframe_to_rows(df_svod_by_year, index=True, header=True):
            wb['Свод по годам'].append(r)

        # Сводная по 1-ПК
        df_svod_by_1PK = df.groupby(['1-ПК Категория']).agg({name_column: 'count'})
        df_svod_by_1PK.columns = ['Количество']

        for r in dataframe_to_rows(df_svod_by_1PK, index=True, header=True):
            wb['Свод по 1-ПК'].append(r)

        # Сводная по 1-ПО
        df_svod_by_1PO = df.groupby(['1-ПО Категория']).agg({name_column: 'count'})
        df_svod_by_1PO.columns = ['Количество']

        for r in dataframe_to_rows(df_svod_by_1PO, index=True, header=True):
            wb['Свод по 1-ПО'].append(r)

        # Сводная по СПО-1
        df_svod_by_SPO1 = df.groupby(['СПО-1 Категория']).agg({name_column: 'count'})
        df_svod_by_SPO1.columns = ['Количество']

        for r in dataframe_to_rows(df_svod_by_SPO1, index=True, header=True):
            wb['Свод по СПО-1'].append(r)

        # Сводная по Росстату
        df_svod_by_Ros = df.groupby(['Росстат Категория']).agg({name_column: 'count'})
        df_svod_by_Ros.columns = ['Количество']

        # Сортируем индекс
        df_svod_by_Ros.index = pd.CategoricalIndex(df_svod_by_Ros.index,
                                                   categories=['0-4', '5-9', '10-14', '15-19', '20-24', '25-29',
                                                               '30-34',
                                                               '35-39', '40-44', '45-49', '50-54', '55-59', '60-64',
                                                               '65-69',
                                                               '70 лет и старше', 'nan'],
                                                   ordered=True)
        df_svod_by_Ros.sort_index(inplace=True)

        for r in dataframe_to_rows(df_svod_by_Ros, index=True, header=True):
            wb['Свод по категориям Росстата'].append(r)

        for r in dataframe_to_rows(df, index=False, header=True):
            wb['Итоговая таблица'].append(r)

        t = time.localtime()
        current_time = time.strftime('%H_%M_%S', t)
        # Сохраняем итоговый файл
        wb.save(f'{path_to_end_folder_date}/Результат обработки колонки {name_column} от {current_time}.xlsx')
    except NameError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Выберите файл с данными и папку куда будет генерироваться файл')
        logging.exception('AN ERROR HAS OCCURRED')
    except KeyError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'В таблице нет такой колонки!\nПроверьте написание названия колонки')
        logging.exception('AN ERROR HAS OCCURRED')
    except FileNotFoundError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             f'Перенесите файлы которые вы хотите обработать в корень диска. Проблема может быть\n '
                             f'в слишком длинном пути к обрабатываемым файлам')

    except:
        logging.exception('AN ERROR HAS OCCURRED')
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             'Возникла ошибка!!! Подробности ошибки в файле error.log')
    else:
        messagebox.showinfo('Лахеcис Обработка результатов профориентационных тестов ver 5.0', 'Данные успешно обработаны')


"""
Слияние файлов
"""
# Функции для слияния таблиц

def select_end_folder_merger():
    """
    Функция для выбора папки куда будет генерироваться итоговый файл
    :return:
    """
    global path_to_end_folder_merger
    path_to_end_folder_merger = filedialog.askdirectory()


def select_folder_data_merger():
    """
    Функция для выбора папки где хранятся нужные файлы
    :return:
    """
    global dir_name
    dir_name = filedialog.askdirectory()

def select_params_file_merger():
    """
    Функция для выбора файла c ячейками которые нужно подсчитать
    :return: Путь к файлу
    """
    if group_rb_type_harvest.get() == 2:
        global params_harvest
        params_harvest = filedialog.askopenfilename(
            filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))
    else:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0','Выберите вариант слияния В и попробуйте снова ')



def select_standard_file_merger():
    """
    Функция для выбора файла c ячейками которые нужно подсчитать
    :return: Путь к файлу
    """
    global file_standard_merger
    file_standard_merger = filedialog.askopenfilename(
        filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def merge_tables():
    """
    Функция для слияния таблиц с одинаковой структурой в одну большую таблицу
    """
    # Получаем значения из полей ввода и проверяем их на тип
    try:
        checkbox_harvest = group_rb_type_harvest.get()
        if checkbox_harvest != 2:
            skip_rows = int(merger_entry_skip_rows.get())
    except ValueError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                             'Введите целое число в поле для ввода количества пропускаемых строк!!!')
    else:
        # Оборачиваем в try
        try:
            # Создаем датафрейм куда будем сохранять ошибочные файлы
            err_df = pd.DataFrame(columns=['Название файла', 'Наименование листа', 'Тип ошибки', 'Описание ошибки'])

            name_file_standard_merger = file_standard_merger.split('/')[-1]  # получаем имя файла

            standard_wb = load_workbook(filename=file_standard_merger)  # Загружаем эталонный файл

            standard_sheets = sorted(
                standard_wb.sheetnames)  # отсортрованный список листов по которому будет вестись сравнение
            set_standard_sheets = set(standard_sheets)  # создаем множество из листов эталонного файла
            standard_size_sheets = len(standard_sheets)

            "Удаляем пустые и строки с заливкой которые могут тянуться вниз и из этого данные из других файлов начина" \
            "ются с тысячных строк"
            for sheet in standard_wb.sheetnames:
                del_cols_df = pd.read_excel(file_standard_merger,
                                            sheet_name=sheet)  # загружаем датафрейм чтобы узнать сколько есть заполненны строк

                temp_sheet_max_row = standard_wb[sheet].max_row  # получаем последнюю строку
                standard_wb[sheet].delete_rows(del_cols_df.shape[0] + 2, temp_sheet_max_row)  # удаляем все лишнее

            dct_df = dict()  # создаем словарь в котором будем хранить да

            for sheet in standard_wb.sheetnames:  # Добавляем в словарь датафреймы
                temp_df = pd.read_excel(file_standard_merger, sheet_name=sheet, dtype=str)
                dct_df[sheet] = temp_df

            if checkbox_harvest == 0:  # Вариант объединения по названию листов
                for dirpath, dirnames, filenames in os.walk(dir_name):
                    for filename in filenames:
                        if (filename.endswith('.xlsx') and not filename.startswith(
                                '~$')) and filename != name_file_standard_merger:  # не обрабатываем эталонный файл
                            # Получаем название файла без расширения
                            name_file = filename.split('.xlsx')[0]
                            print(name_file)
                            temb_wb = load_workbook(
                                filename=f'{dirpath}/{filename}')  # загружаем файл, для проверки листов
                            """
                            Проверяем наличие листов из эталонного файла в проверяемом файле, если они есть то начинаем 
                            дальнейшую проверку
                            """
                            if set_standard_sheets.issubset(set(temb_wb.sheetnames)):
                                count_errors = 0
                                # проверяем наличие листов указанных в файле параметров
                                for name_sheet, df in dct_df.items():  # Проводим проверку на совпадение
                                    lst_df = pd.read_excel(f'{dirpath}/{filename}', sheet_name=name_sheet)
                                    if lst_df.shape[1] != df.shape[1]:
                                        # если количество колонок не совпадает то записываем как ошибку
                                        temp_error_df = pd.DataFrame(
                                            columns=['Название файла', 'Наименование листа', 'Тип ошибки',
                                                     'Описание ошибки'],
                                            data=[[name_file, name_sheet, 'Количество колонок отличается от эталонного',
                                                   f'Ожидалось {df.shape[1]} колонок, а в листе {lst_df.shape[1]}']])  # создаем временный датафрейм. потом надо подумать над словарем

                                        err_df = pd.concat([err_df, temp_error_df],
                                                           ignore_index=True)  # добавляем в датафрейм ошибок
                                        count_errors += 1

                                # если хоть одна ошибка то проверяем следующий файл
                                if count_errors != 0:
                                    continue
                                # если нет то начинаем обрабатывать листы
                                for name_sheet, df in dct_df.items():
                                    temp_df = pd.read_excel(f'{dirpath}/{filename}', sheet_name=name_sheet,
                                                            dtype=str, skiprows=skip_rows,header=None)  # загружаем датафрейм
                                    if temp_df.shape[1] > 3:
                                        temp_df = temp_df.dropna(axis=0,thresh=2)

                                    temp_df['Номер строки'] = range(1, temp_df.shape[0] + 1)
                                    temp_df['Откуда взяты данные'] = name_file
                                    for row in dataframe_to_rows(temp_df, index=False, header=False):
                                        standard_wb[name_sheet].append(row)  # добавляем данные

                            elif len(
                                    temb_wb.sheetnames) == standard_size_sheets:  # сравниваем количество листов в файле
                                diff_name_sheets = set(temb_wb.sheetnames).difference(
                                    set(standard_sheets))  # проверяем разницу в названиях листов
                                print(diff_name_sheets)
                                if len(diff_name_sheets) != 0:  # если разница в названиях есть то записываем в ошибки и обрабатываем следующий файл
                                    temp_error_df = pd.DataFrame(
                                        columns=['Название файла', 'Наименование листа', 'Тип ошибки',
                                                 'Описание ошибки'], data=[
                                            [name_file, '', 'Названия листов отличаются от эталонных',
                                             f'Отличаются следующие названия листов {diff_name_sheets}']])  # создаем временный датафрейм. потом надо подумать над словарем

                                    err_df = pd.concat([err_df, temp_error_df],
                                                       ignore_index=True)  # добавляем в датафрейм ошибок

                                    continue

                            else:
                                temp_error_df = pd.DataFrame(
                                    columns=['Название файла', 'Наименование листа', 'Тип ошибки', 'Описание ошибки'],
                                    data=[[name_file, '', 'Не совпадает количество или название листов в файле',
                                           f'Листы, которые есть в файле: {",".join(temb_wb.sheetnames)}']])  # создаем временный датафрейм. потом надо подумать над словарем

                                err_df = pd.concat([err_df, temp_error_df],
                                                   ignore_index=True)  # добавляем в датафрейм ошибок

                # Получаем текущую дату
                current_time = time.strftime('%H_%M_%S %d.%m.%Y')
                standard_wb.save(
                    f'{path_to_end_folder_merger}/Слияние по варианту А Общая таблица от {current_time}.xlsx')  # сохраняем
                err_out_wb = openpyxl.Workbook()  # создаем объект openpyxl для сохранения датафрейма
                for row in dataframe_to_rows(err_df, index=False, header=True):
                    err_out_wb['Sheet'].append(row)  # добавляем данные
                # устанавливаем размер колонок
                err_out_wb['Sheet'].column_dimensions['A'].width = 40
                err_out_wb['Sheet'].column_dimensions['B'].width = 30
                err_out_wb['Sheet'].column_dimensions['C'].width = 55
                err_out_wb['Sheet'].column_dimensions['D'].width = 100
                err_out_wb.save(f'{path_to_end_folder_merger}/Слияние по варианту А Ошибки от {current_time}.xlsx')

            elif checkbox_harvest == 1:  # Вариант объединения по порядку
                for dirpath, dirnames, filenames in os.walk(dir_name):
                    for filename in filenames:
                        if (filename.endswith('.xlsx') and not filename.startswith(
                                '~$')) and filename != name_file_standard_merger:  # не обрабатываем эталонный файл
                            # Получаем название файла без расширения
                            name_file = filename.split('.xlsx')[0]
                            print(name_file)
                            temb_wb = load_workbook(filename=f'{dirpath}/{filename}')  # загружаем файл

                            if standard_size_sheets == len(
                                    temb_wb.sheetnames):  # если количество листов одинаково то обрабатываем
                                count_errors = 0  # счетчик ошибок
                                dct_name_sheet = {}  # создаем словарь где ключ это название листа в эталонном файле а значение это название листа в обрабатываемом файле
                                for idx, data in enumerate(dct_df.items()):  # Проводим проверку на совпадение
                                    name_sheet = data[0]  # получаем название листа
                                    df = data[1]  # получаем датафрейм
                                    temp_name_sheet = temb_wb.sheetnames[idx]  #
                                    lst_df = pd.read_excel(f'{dirpath}/{filename}', sheet_name=temp_name_sheet)
                                    if lst_df.shape[1] != df.shape[1]:
                                        # если количество колонок не совпадает то записываем как ошибку
                                        temp_error_df = pd.DataFrame(
                                            columns=['Название файла', 'Наименование листа', 'Тип ошибки',
                                                     'Описание ошибки'],
                                            data=[
                                                [name_file, name_sheet, 'Количество колонок отличается от эталонного',
                                                 f'Ожидалось {df.shape[1]} колонок, а в листе {lst_df.shape[1]}']])  # создаем временный датафрейм. потом надо подумать над словарем

                                        err_df = pd.concat([err_df, temp_error_df],
                                                           ignore_index=True)  # добавляем в датафрейм ошибок
                                        count_errors += 1

                                    else:
                                        dct_name_sheet[name_sheet] = temp_name_sheet
                                # если хоть одна ошибка то проверяем следующий файл
                                if count_errors != 0:
                                    continue
                                    # если нет то начинаем обрабатывать листы
                                for name_sheet, df in dct_df.items():
                                    temp_df = pd.read_excel(f'{dirpath}/{filename}',
                                                            sheet_name=dct_name_sheet[name_sheet],
                                                            dtype=str, skiprows=skip_rows,header=None)  # загружаем датафрейм
                                    if temp_df.shape[1] > 3:
                                        temp_df = temp_df.dropna(axis=0, thresh=2)
                                    temp_df['Номер строки'] = range(1, temp_df.shape[0] + 1)
                                    temp_df['Откуда взяты данные'] = name_file
                                    for row in dataframe_to_rows(temp_df, index=False, header=False):
                                        standard_wb[name_sheet].append(row)  # добавляем данные
                            else:
                                temp_error_df = pd.DataFrame(
                                    columns=['Название файла', 'Наименование листа', 'Тип ошибки', 'Описание ошибки'],
                                    data=[[name_file, '', 'Не совпадает количество или название листов в файле',
                                           f'Листы, которые есть в файле: {",".join(temb_wb.sheetnames)}']])  # создаем временный датафрейм. потом надо подумать над словарем

                                err_df = pd.concat([err_df, temp_error_df],
                                                   ignore_index=True)  # добавляем в датафрейм ошибок

                # Получаем текущую дату
                current_time = time.strftime('%H_%M_%S %d.%m.%Y')
                standard_wb.save(
                    f'{path_to_end_folder_merger}/Слияние по варианту Б Общая таблица от {current_time}.xlsx')  # сохраняем

                err_out_wb = openpyxl.Workbook()  # создаем объект openpyxl для сохранения датафрейма
                for row in dataframe_to_rows(err_df, index=False, header=True):
                    err_out_wb['Sheet'].append(row)  # добавляем данные
                # устанавливаем размер колонок
                err_out_wb['Sheet'].column_dimensions['A'].width = 40
                err_out_wb['Sheet'].column_dimensions['B'].width = 30
                err_out_wb['Sheet'].column_dimensions['C'].width = 55
                err_out_wb['Sheet'].column_dimensions['D'].width = 100
                err_out_wb.save(f'{path_to_end_folder_merger}/Слияние по варианту Б Ошибки от {current_time}.xlsx')

            # Если выбран управляемый сбор данных
            elif checkbox_harvest == 2:
                df_params = pd.read_excel(params_harvest, header=None)  # загружаем параметры
                df_params[0] = df_params[0].astype(
                    str)  # делаем данные строковыми чтобы корректно работало обращение по названию листов

                tmp_name_sheets = df_params[0].tolist()  # создаем списки чтобы потом из них сделать словарь
                tmp_skip_rows = df_params[1].tolist()
                dct_manage_harvest = dict(zip(tmp_name_sheets,
                                              tmp_skip_rows))  # создаем словарь где ключ это название листа а значение это сколько строк нужно пропустить
                set_params_sheets = set(
                    dct_manage_harvest.keys())  # создаем множество из ключей(листов) которые нужно обработать
                if not set_params_sheets.issubset(
                        set_standard_sheets):  # проверяем совпадение названий в эталонном файле и в файле параметров
                    diff_value = set(dct_manage_harvest.keys()).difference(set(standard_sheets))  # получаем разницу

                    messagebox.showerror('',
                                         f'Не совпадают следующие названия листов в файле параметров и в эталонном файле\n'
                                         f'{diff_value}!')
                # начинаем обработку
                for dirpath, dirnames, filenames in os.walk(dir_name):
                    for filename in filenames:
                        if (filename.endswith('.xlsx') and not filename.startswith(
                                '~$')) and filename != name_file_standard_merger:  # не обрабатываем эталонный файл
                            # Получаем название файла без расширения
                            name_file = filename.split('.xlsx')[0]
                            print(name_file)
                            temb_wb = load_workbook(filename=f'{dirpath}/{filename}')  # загружаем файл
                            if set_params_sheets.issubset(set(temb_wb.sheetnames)):
                                count_errors = 0
                                # проверяем наличие листов указанных в файле параметров
                                for name_sheet, skip_r in dct_manage_harvest.items():  # Проводим проверку на совпадение количества колонок
                                    lst_df = pd.read_excel(f'{dirpath}/{filename}', sheet_name=name_sheet)
                                    if lst_df.shape[1] != dct_df[name_sheet].shape[1]:
                                        # если количество колонок не совпадает то записываем как ошибку
                                        temp_error_df = pd.DataFrame(
                                            columns=['Название файла', 'Наименование листа', 'Тип ошибки',
                                                     'Описание ошибки'],
                                            data=[[name_file, name_sheet, 'Количество колонок отличается от эталонного',
                                                   f'Ожидалось {dct_df[name_sheet].shape[1]} колонок, а в листе {lst_df.shape[1]}']])  # создаем временный датафрейм. потом надо подумать над словарем
                                        err_df = pd.concat([err_df, temp_error_df],
                                                           ignore_index=True)  # добавляем в датафрейм ошибок
                                        count_errors += 1
                                #
                                # если хоть одна ошибка то проверяем следующий файл
                                if count_errors != 0:
                                    continue
                                # если нет то начинаем обрабатывать листы
                                for name_sheet, skip_r in dct_manage_harvest.items():
                                    temp_df = pd.read_excel(f'{dirpath}/{filename}', sheet_name=name_sheet,
                                                            skiprows=skip_r,
                                                            dtype=str, header=None)  # загружаем датафрейм

                                    if temp_df.shape[1] > 3:
                                        temp_df = temp_df.dropna(axis=0,thresh=2)
                                    temp_df['Номер строки'] = range(1, temp_df.shape[0] + 1)
                                    temp_df['Откуда взяты данные'] = name_file
                                    for row in dataframe_to_rows(temp_df, index=False, header=False):
                                        standard_wb[name_sheet].append(row)  # добавляем данные
                            else:
                                temp_error_df = pd.DataFrame(
                                    columns=['Название файла', 'Наименование листа', 'Тип ошибки', 'Описание ошибки'],
                                    data=[[name_file, '', 'Не совпадает количество или название листов в файле',
                                           f'Листы, которые есть в файле: {",".join(temb_wb.sheetnames)}']])  # создаем временный датафрейм. потом надо подумать над словарем

                                err_df = pd.concat([err_df, temp_error_df],
                                                   ignore_index=True)  # добавляем в датафрейм ошибок

                # # Получаем текущую дату
                current_time = time.strftime('%H_%M_%S %d.%m.%Y')
                standard_wb.save(
                    f'{path_to_end_folder_merger}/Слияние по варианту В Общая таблица от {current_time}.xlsx')  # сохраняем
                err_out_wb = openpyxl.Workbook()  # создаем объект openpyxl для сохранения датафрейма
                for row in dataframe_to_rows(err_df, index=False, header=True):
                    err_out_wb['Sheet'].append(row)  # добавляем данные
                # устанавливаем размер колонок
                err_out_wb['Sheet'].column_dimensions['A'].width = 40
                err_out_wb['Sheet'].column_dimensions['B'].width = 30
                err_out_wb['Sheet'].column_dimensions['C'].width = 55
                err_out_wb['Sheet'].column_dimensions['D'].width = 100
                err_out_wb.save(f'{path_to_end_folder_merger}/Слияние по варианту В Ошибки от {current_time}.xlsx')

        except NameError:
            messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                                 f'Выберите папку с файлами,эталонный файл и папку куда будут генерироваться файлы')
        except PermissionError:
            messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                                 f'Закройте файл выбранный эталонным или файлы из обрабатываемой папки')
        except FileNotFoundError:
            messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                                 f'Выберите файл с параметрами!\n'
                                 f'Если вы выбрали файл с параметрами, а ошибка повторяется,то перенесите папку \n'
                                 f'с файлами которые вы хотите обработать в корень диска. Проблема может быть в \n '
                                 f'в слишком длинном пути к обрабатываемым файлам')
        except:
            logging.exception('AN ERROR HAS OCCURRED')
            messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                                 'Возникла ошибка!!! Подробности ошибки в файле error.log')
        else:
            messagebox.showinfo('Лахеcис Обработка результатов профориентационных тестов ver 5.0',
                                'Создание общей таблицы успешно завершено!!!')





if __name__ == '__main__':
    window = Tk()
    window.title('Лахеcис Обработка результатов профориентационных тестов ver 5.0')
    window.geometry('750x860')
    window.resizable(False, False)
    make_textmenu(window)
    tkinter.Tk.report_callback_exception = report_callback_exception

    # Создаем объект вкладок

    tab_control = ttk.Notebook(window)
    """
    Обработка комплексных результатов
    """
    # Создаем вкладку обработки данных complex
    tab_report_complex = ttk.Frame(tab_control)
    tab_control.add(tab_report_complex, text='Обработка результатов')
    tab_control.pack(expand=1, fill='both')
    # Добавляем виджеты на вкладку
    # Создаем метку для описания назначения программы
    lbl_hello_complex = Label(tab_report_complex,
                              text='Центр опережающей профессиональной подготовки Республики Бурятия\nКомплексный тест \n'
                                   'Все колонки таблицы не относящиеся к тестовым вопросам\n должны быть в начале и в конце таблицы.'
                                   )
    lbl_hello_complex.grid(column=0, row=0, padx=10, pady=25)

    # Картинка
    path_to_img_complex = resource_path('logo.png')

    img_complex = PhotoImage(file=path_to_img_complex)
    Label(tab_report_complex,
          image=img_complex
          ).grid(column=1, row=0, padx=10, pady=25)

    # Создаем кнопку Выбрать файл с параметрами
    btn_choose_data_complex = Button(tab_report_complex, text='1) Выберите файл с параметрами',
                                     font=('Arial Bold', 20),
                                     command=select_file_params_complex
                                     )
    btn_choose_data_complex.grid(column=0, row=2, padx=10, pady=10)

    # Создаем кнопку Выбрать файл с данными
    btn_choose_data_complex = Button(tab_report_complex, text='2) Выберите файл с результатами',
                                     font=('Arial Bold', 20),
                                     command=select_file_data_xlsx_complex
                                     )
    btn_choose_data_complex.grid(column=0, row=3, padx=10, pady=10)

    # Создаем кнопку для выбора папки куда будут генерироваться файлы

    btn_choose_end_folder_complex = Button(tab_report_complex, text='3) Выберите конечную папку',
                                           font=('Arial Bold', 20),
                                           command=select_end_folder_complex
                                           )
    btn_choose_end_folder_complex.grid(column=0, row=4, padx=10, pady=10)

    # Создаем поле для ввода количества колонок без вопросов(анкетные данные)
    # Определяем переменную
    var_entry_threshold_complex = IntVar()
    # Описание поля
    label_name_threshold_complex = Label(tab_report_complex,
                                         text='4) Введите количество колонок в начале таблицы\n не относящихся к вопросам теста')
    label_name_threshold_complex.grid(column=0, row=5, padx=10, pady=5)
    # поле ввода
    entry_threshold_complex = Entry(tab_report_complex, textvariable=var_entry_threshold_complex, width=30)
    entry_threshold_complex.grid(column=0, row=6, padx=5, pady=5, ipadx=30, ipady=4)

    # Создаем кнопку обработки данных

    btn_proccessing_data_complex = Button(tab_report_complex, text='5) Обработать данные', font=('Arial Bold', 20),
                                          command=processing_complex
                                          )
    btn_proccessing_data_complex.grid(column=0, row=7, padx=10, pady=10)
    """
    Создание отчетов
    """

    tab_create_doc = ttk.Frame(tab_control)
    tab_control.add(tab_create_doc, text='Создание документов')
    tab_control.pack(expand=1, fill='both')

    # Добавляем виджеты на вкладку Создание документов
    # Создаем метку для описания назначения программы
    lbl_hello = Label(tab_create_doc,
                      text='Центр опережающей профессиональной подготовки Республики Бурятия\nГенерация документов по шаблону'
                           '\nДля корректной работы программмы уберите из таблицы объединенные ячейки'
                           '\nДанные обрабатываются только с первого листа файла Excel!!!')
    lbl_hello.grid(column=0, row=0, padx=10, pady=25)

    # Картинка
    path_to_img = resource_path('logo.png')
    img = PhotoImage(file=path_to_img)
    Label(tab_create_doc,
          image=img
          ).grid(column=1, row=0, padx=10, pady=25)

    # Создаем область для того чтобы поместить туда подготовительные кнопки(выбрать файл,выбрать папку и т.п.)
    frame_data_for_doc = LabelFrame(tab_create_doc, text='Подготовка')
    frame_data_for_doc.grid(column=0, row=2, padx=10)

    # Создаем кнопку Выбрать шаблон
    btn_template_doc = Button(frame_data_for_doc, text='1) Выберите шаблон документа', font=('Arial Bold', 15),
                              command=select_file_template_doc
                              )
    btn_template_doc.grid(column=0, row=3, padx=10, pady=10)
    #
    # Создаем кнопку Выбрать файл с данными
    btn_data_doc = Button(frame_data_for_doc, text='2) Выберите файл с данными', font=('Arial Bold', 15),
                          command=select_file_data_doc
                          )
    btn_data_doc.grid(column=0, row=4, padx=10, pady=10)
    #
    # Создаем кнопку для выбора папки куда будут генерироваться файлы

    # Определяем текстовую переменную
    entry_name_column_data = StringVar()
    # Описание поля
    label_name_column_data = Label(frame_data_for_doc,
                                   text='3) Введите название колонки в таблице\n по которой будут создаваться имена файлов')
    label_name_column_data.grid(column=0, row=5, padx=10, pady=5)
    # поле ввода
    data_column_entry = Entry(frame_data_for_doc, textvariable=entry_name_column_data, width=30)
    data_column_entry.grid(column=0, row=6, padx=5, pady=5, ipadx=30, ipady=4)

    # Поле для ввода названия генериуемых документов
    # Определяем текстовую переменную
    entry_type_file = StringVar()
    # Описание поля
    label_name_column_type_file = Label(frame_data_for_doc, text='4) Введите название создаваемых документов')
    label_name_column_type_file.grid(column=0, row=7, padx=10, pady=5)
    # поле ввода
    type_file_column_entry = Entry(frame_data_for_doc, textvariable=entry_type_file, width=30)
    type_file_column_entry.grid(column=0, row=8, padx=5, pady=5, ipadx=30, ipady=4)

    btn_choose_end_folder_doc = Button(frame_data_for_doc, text='5) Выберите конечную папку', font=('Arial Bold', 15),
                                       command=select_end_folder_doc
                                       )
    btn_choose_end_folder_doc.grid(column=0, row=9, padx=10, pady=10)

    # Создаем область для того чтобы поместить туда опции
    frame_data_for_options = LabelFrame(tab_create_doc, text='Дополнительные опции')
    frame_data_for_options.grid(column=0, row=10, padx=10)

    # Создаем переменную для хранения результа переключения чекбокса
    mode_combine_value = StringVar()

    # Устанавливаем значение по умолчанию для этой переменной. По умолчанию будет вестись подсчет числовых данных
    mode_combine_value.set('No')
    # Создаем чекбокс для выбора режима подсчета

    chbox_mode_calculate = Checkbutton(frame_data_for_options,
                                       text='Поставьте галочку, если вам нужно чтобы все файлы были объединены в один',
                                       variable=mode_combine_value,
                                       offvalue='No',
                                       onvalue='Yes')
    chbox_mode_calculate.grid(column=0, row=11, padx=10, pady=5)

    # создаем чекбокс для единичного документа

    # Создаем переменную для хранения результа переключения чекбокса
    mode_group_doc = StringVar()

    # Устанавливаем значение по умолчанию для этой переменной. По умолчанию будет вестись подсчет числовых данных
    mode_group_doc.set('No')
    # Создаем чекбокс для выбора режима подсчета
    chbox_mode_group = Checkbutton(frame_data_for_options,
                                   text='Поставьте галочку, если вам нужно создать один документ\nдля конкретного значения (например для определенного ФИО)',
                                   variable=mode_group_doc,
                                   offvalue='No',
                                   onvalue='Yes')
    chbox_mode_group.grid(column=0, row=12, padx=10, pady=5)
    # Создаем поле для ввода значения по которому будет создаваться единичный документ
    # Определяем текстовую переменную
    entry_value_column = StringVar()
    # Описание поля
    label_name_column_group = Label(frame_data_for_options,
                                    text='Введите значение из колонки\nуказанной на шаге 3 для которого нужно создать один документ,\nнапример конкретное ФИО')
    label_name_column_group.grid(column=0, row=13, padx=10, pady=5)
    # поле ввода
    type_file_group_entry = Entry(frame_data_for_options, textvariable=entry_value_column, width=30)
    type_file_group_entry.grid(column=0, row=14, padx=5, pady=5, ipadx=30, ipady=4)

    # Создаем кнопку для создания документов из таблиц с произвольной структурой
    btn_create_files_other = Button(tab_create_doc, text='6) Создать документ(ы)',
                                    font=('Arial Bold', 15),
                                    command=generate_docs_other
                                    )
    btn_create_files_other.grid(column=0, row=14, padx=10, pady=10)


    """
    Объединение таблиц
    """
    tab_comparison = ttk.Frame(tab_control)
    tab_control.add(tab_comparison, text='Слияние 2 таблиц')
    tab_control.pack(expand=1, fill='both')

    # Добавляем виджеты на вкладку Создание документов
    # Создаем метку для описания назначения программы
    lbl_hello = Label(tab_comparison,
                      text='Центр опережающей профессиональной подготовки Республики Бурятия\n'
                           '\nДля корректной работы программмы уберите из таблицы объединенные ячейки')
    lbl_hello.grid(column=0, row=0, padx=10, pady=25)

    # Картинка
    path_com = resource_path('logo.png')
    img_comparison = PhotoImage(file=path_com)
    Label(tab_comparison,
          image=img
          ).grid(column=1, row=0, padx=10, pady=25)

    # Создаем область для того чтобы поместить туда подготовительные кнопки(выбрать файл,выбрать папку и т.п.)
    frame_data_for_comparison = LabelFrame(tab_comparison, text='Подготовка')
    frame_data_for_comparison.grid(column=0, row=2, padx=10)

    # Создаем кнопку выбрать файл с параметрами
    btn_columns_params = Button(frame_data_for_comparison, text='1) Выберите файл с параметрами слияния',
                                font=('Arial Bold', 10),
                                command=select_file_params_comparsion)
    btn_columns_params.grid(column=0, row=3, padx=10, pady=10)

    # Создаем кнопку Выбрать  первый файл с данными
    btn_data_first_comparison = Button(frame_data_for_comparison, text='2) Выберите первый файл с данными',
                                       font=('Arial Bold', 10),
                                       command=select_first_comparison
                                       )
    btn_data_first_comparison.grid(column=0, row=4, padx=10, pady=10)

    # Определяем текстовую переменную
    entry_first_sheet_name = StringVar()
    # Описание поля
    label_first_sheet_name = Label(frame_data_for_comparison,
                                   text='3) Введите название листа в первом файле')
    label_first_sheet_name.grid(column=0, row=5, padx=10, pady=10)
    # поле ввода имени листа
    first_sheet_name_entry = Entry(frame_data_for_comparison, textvariable=entry_first_sheet_name, width=30)
    first_sheet_name_entry.grid(column=0, row=6, padx=5, pady=5, ipadx=15, ipady=10)

    # Создаем кнопку Выбрать  второй файл с данными
    btn_data_second_comparison = Button(frame_data_for_comparison, text='4) Выберите второй файл с данными',
                                        font=('Arial Bold', 10),
                                        command=select_second_comparison
                                        )
    btn_data_second_comparison.grid(column=0, row=7, padx=10, pady=10)

    # Определяем текстовую переменную
    entry_second_sheet_name = StringVar()
    # Описание поля
    label_second_sheet_name = Label(frame_data_for_comparison,
                                    text='5) Введите название листа во втором файле')
    label_second_sheet_name.grid(column=0, row=8, padx=10, pady=10)
    # поле ввода
    second__sheet_name_entry = Entry(frame_data_for_comparison, textvariable=entry_second_sheet_name, width=30)
    second__sheet_name_entry.grid(column=0, row=9, padx=5, pady=5, ipadx=15, ipady=10)

    # Создаем кнопку выбора папки куда будет генерироваьться файл
    btn_select_end_comparison = Button(frame_data_for_comparison, text='6) Выберите конечную папку',
                                       font=('Arial Bold', 10),
                                       command=select_end_folder_comparison
                                       )
    btn_select_end_comparison.grid(column=0, row=10, padx=10, pady=10)

    # Создаем кнопку Обработать данные
    btn_data_do_comparison = Button(tab_comparison, text='7) Произвести слияние\nтаблиц', font=('Arial Bold', 20),
                                    command=processing_comparison
                                    )
    btn_data_do_comparison.grid(column=0, row=11, padx=10, pady=10)


    # Создаем вкладку для подсчета данных по категориям
    tab_groupby_data = ttk.Frame(tab_control)
    tab_control.add(tab_groupby_data, text='Подсчет данных')
    tab_control.pack(expand=1, fill='both')

    # Добавляем виджеты на вкладку Подсчет данных  по категориям
    # Создаем метку для описания назначения программы
    lbl_hello = Label(tab_groupby_data,
                      text='Центр опережающей профессиональной подготовки Республики Бурятия\nПодсчет данных'
                           '\nДанные обрабатываются только с первого листа файла Excel!!!')
    lbl_hello.grid(column=0, row=0, padx=10, pady=25)

    # Картинка
    path_to_img = resource_path('logo.png')
    img_groupby = PhotoImage(file=path_to_img)
    Label(tab_groupby_data,
          image=img_groupby
          ).grid(column=1, row=0, padx=10, pady=25)

    # Создаем область для того чтобы поместить туда подготовительные кнопки(выбрать файл,выбрать папку и т.п.)
    frame_data_for_groupby = LabelFrame(tab_groupby_data, text='Подготовка')
    frame_data_for_groupby.grid(column=0, row=2, padx=10)

    # Создаем кнопку Выбрать файл с данными
    btn_data_groupby = Button(frame_data_for_groupby, text='1) Выберите файл с данными', font=('Arial Bold', 20),
                              command=select_file_data_groupby
                              )
    btn_data_groupby.grid(column=0, row=3, padx=10, pady=10)

    btn_choose_end_folder_groupby = Button(frame_data_for_groupby, text='2) Выберите конечную папку',
                                           font=('Arial Bold', 20),
                                           command=select_end_folder_groupby
                                           )
    btn_choose_end_folder_groupby.grid(column=0, row=4, padx=10, pady=10)

       # Создаем кнопки подсчета

    btn_groupby_category = Button(tab_groupby_data, text='Подсчитать количество по категориям\nдля всех колонок',
                                  font=('Arial Bold', 20),
                                  command=groupby_category)
    btn_groupby_category.grid(column=0, row=5, padx=10, pady=10)

    btn_groupby_stat = Button(tab_groupby_data, text='Подсчитать базовую статистику\nдля всех колонок',
                              font=('Arial Bold', 20),
                              command=groupby_stat)
    btn_groupby_stat.grid(column=0, row=6, padx=10, pady=10)


    # Создаем вклдаку для обработки дат рождения

    tab_calculate_date = ttk.Frame(tab_control)
    tab_control.add(tab_calculate_date, text='Обработка дат рождения')
    tab_control.pack(expand=1, fill='both')

    # Добавляем виджеты на вкладку Обработка дат рождения
    # Создаем метку для описания назначения программы
    lbl_hello = Label(tab_calculate_date,
                      text='Центр опережающей профессиональной подготовки Республики Бурятия\nПодсчет по категориям,выделение месяца,года,подсчет текущего возраста'
                           '\nДля корректной работы программмы уберите из таблицы объединенные ячейки'
                           '\nДанные обрабатываются только с первого листа файла Excel!!!')
    lbl_hello.grid(column=0, row=0, padx=10, pady=25)

    # Картинка
    path_to_img = resource_path('logo.png')
    img_date = PhotoImage(file=path_to_img)
    Label(tab_calculate_date,
          image=img_date
          ).grid(column=1, row=0, padx=10, pady=25)

    # Определяем текстовую переменную которая будет хранить дату
    entry_date = StringVar()
    # Описание поля
    label_name_date_field = Label(tab_calculate_date,
                                  text='Введите  дату в формате XX.XX.XXXX\n относительно, которой нужно подсчитать текущий возраст')
    label_name_date_field.grid(column=0, row=2, padx=10, pady=10)
    # поле ввода
    date_field = Entry(tab_calculate_date, textvariable=entry_date, width=30)
    date_field.grid(column=0, row=3, padx=5, pady=5, ipadx=30, ipady=15)

    # Создаем кнопку Выбрать файл с данными
    btn_data_date = Button(tab_calculate_date, text='1) Выберите файл с данными', font=('Arial Bold', 20),
                           command=select_file_data_date)
    btn_data_date.grid(column=0, row=4, padx=10, pady=10)

    btn_choose_end_folder_date = Button(tab_calculate_date, text='2) Выберите конечную папку', font=('Arial Bold', 20),
                                        command=select_end_folder_date
                                        )
    btn_choose_end_folder_date.grid(column=0, row=5, padx=10, pady=10)

    # Определяем текстовую переменную
    entry_name_column = StringVar()
    # Описание поля
    label_name_column = Label(tab_calculate_date,
                              text='3) Введите название колонки с датами рождения,\nкоторые нужно обработать ')
    label_name_column.grid(column=0, row=6, padx=10, pady=10)
    # поле ввода
    column_entry = Entry(tab_calculate_date, textvariable=entry_name_column, width=30)
    column_entry.grid(column=0, row=7, padx=7, pady=5, ipadx=30, ipady=15)

    btn_calculate_date = Button(tab_calculate_date, text='4) Обработать', font=('Arial Bold', 20),
                                command=calculate_date)
    btn_calculate_date.grid(column=0, row=8, padx=10, pady=10)


    """
    Создание вкладки для объединения таблиц в одну большую
    """
    # Создаем вкладку для подсчета данных по категориям
    tab_merger_tables = ttk.Frame(tab_control)
    tab_control.add(tab_merger_tables, text='Слияние файлов')
    tab_control.pack(expand=1, fill='both')

    # Добавляем виджеты на вкладку Подсчет данных  по категориям
    # Создаем метку для описания назначения программы
    lbl_hello = Label(tab_merger_tables,
                      text='Центр опережающей профессиональной подготовки Республики Бурятия\nСлияние файлов Excel с одинаковой структурой'
                           '\nДля корректной работы программмы уберите из таблицы объединенные ячейки'
                      )
    lbl_hello.grid(column=0, row=0, padx=10, pady=25)

    # Картинка
    path_to_img = resource_path('logo.png')
    img_merger = PhotoImage(file=path_to_img)
    Label(tab_merger_tables,
          image=img_merger
          ).grid(column=1, row=0, padx=10, pady=25)

    # Переключатель:вариант слияния файлов
    # Создаем переключатель
    group_rb_type_harvest = IntVar()
    # Создаем фрейм для размещения переключателей(pack и грид не используются в одном контейнере)
    frame_rb_type_harvest = LabelFrame(tab_merger_tables, text='1) Выберите вариант слияния')
    frame_rb_type_harvest.grid(column=0, row=1, padx=10)
    #
    Radiobutton(frame_rb_type_harvest, text='А) Простое слияние по названию листов', variable=group_rb_type_harvest, value=0).pack()
    Radiobutton(frame_rb_type_harvest, text='Б) Слияние по порядку листов', variable=group_rb_type_harvest, value=1).pack()
    Radiobutton(frame_rb_type_harvest, text='В) Сложное слияние по названию листов', variable=group_rb_type_harvest, value=2).pack()

    # Создаем область для того чтобы поместить туда подготовительные кнопки(выбрать файл,выбрать папку и т.п.)
    frame_data_for_merger = LabelFrame(tab_merger_tables, text='Подготовка')
    frame_data_for_merger.grid(column=0, row=2, padx=10)

    #Создаем кнопку Выбрать папку с данными

    btn_data_merger = Button(frame_data_for_merger, text='2) Выберите папку с данными', font=('Arial Bold', 14),
                             command=select_folder_data_merger
                             )
    btn_data_merger.grid(column=0, row=3, padx=5, pady=5)

    # Создаем кнопку Выбрать эталонный файл

    btn_example_merger = Button(frame_data_for_merger, text='3) Выберите эталонный файл', font=('Arial Bold', 14),
                                command=select_standard_file_merger)
    btn_example_merger.grid(column=0, row=4, padx=5, pady=5)

    btn_choose_end_folder_merger = Button(frame_data_for_merger, text='4) Выберите конечную папку',
                                          font=('Arial Bold', 14),
                                          command=select_end_folder_merger
                                          )
    btn_choose_end_folder_merger.grid(column=0, row=5, padx=5, pady=5)


    # Определяем переменную в которой будем хранить количество пропускаемых строк
    merger_entry_skip_rows = StringVar()
    # Описание поля
    merger_label_skip_rows = Label(frame_data_for_merger,
                                   text='5) Введите количество строк\nв листах,чтобы пропустить\nзаголовок\n'
                                        'ТОЛЬКО для вариантов слияния А и Б ')
    merger_label_skip_rows.grid(column=0, row=8, padx=10, pady=10)
    # поле ввода
    merger_number_skip_rows = Entry(frame_data_for_merger, textvariable=merger_entry_skip_rows, width=5)
    merger_number_skip_rows.grid(column=0, row=9, padx=5, pady=5, ipadx=10, ipady=7)

    # Создаем кнопку выбора файла с параметрами
    btn_params_merger = Button(frame_data_for_merger, text='Выберите файл с параметрами слияния\n'
                                                           'ТОЛЬКО для варианта В', font=('Arial Bold', 14),
                                command=select_params_file_merger)
    btn_params_merger.grid(column=0, row=10, padx=5, pady=5)
     # Создаем кнопку слияния

    btn_merger_process = Button(tab_merger_tables, text='6) Произвести слияние \nфайлов',
                                font=('Arial Bold', 20),
                                command=merge_tables)
    btn_merger_process.grid(column=0, row=11, padx=10, pady=10)




    window.bind_class("Entry", "<Button-3><ButtonRelease-3>", show_textmenu)
    window.bind_class("Entry", "<Control-a>", callback_select_all)

    window.mainloop()
