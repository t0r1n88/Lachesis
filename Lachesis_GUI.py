# -*- coding: UTF-8 -*-
"""
скрипт для обработки произвольных тестов
"""
from create_result_docs import generate_result_docs # импортируем функцию по созданию документов

import pandas as pd
import numpy as np
import os
from dateutil.parser import ParserError
from docxtpl import DocxTemplate
from docxcompose.composer import Composer
from docx import Document
from docx2pdf import convert
from tkinter import *
from tkinter import filedialog
from tkinter import messagebox
from tkinter import ttk
import tkinter
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.styles import Font
from openpyxl.styles import Alignment
from openpyxl import load_workbook
import time
import datetime
import warnings
from collections import Counter
warnings.filterwarnings('ignore', category=UserWarning, module='openpyxl')
pd.options.mode.chained_assignment = None
import sys
import locale
import logging
import tempfile
import re
logging.basicConfig(
    level=logging.WARNING,
    filename="error.log",
    filemode='w',
    # чтобы файл лога перезаписывался  при каждом запуске.Чтобы избежать больших простыней. По умолчанию идет 'a'
    format="%(asctime)s - %(module)s - %(levelname)s - %(funcName)s: %(lineno)d - %(message)s",
    datefmt='%H:%M:%S',
)






# # Классы для исключений

class WrongNumberColumn(Exception):
    """
    Класс для исключения проверяющего количество колонок в в таблице
    """
    pass


class CheckBoxException(Exception):
    """
    Класс для вызовы исключения в случае если неправильно выставлены чекбоксы
    """
    pass


class NotFoundValue(Exception):
    """
    Класс для обозначения того что значение не найдено
    """
    pass
def extract_key_max_value(cell:str) ->str:
    """
    Функция для извлечения ключа с максимальным значением
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return cell
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(' - ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return max(dct_result, key=dct_result.get)

def extract_max_value(cell:str):
    """
    Функция для извлечения значения ключа с максимальным значением , ха звучит странно
    :param cell: строка формата ключ - значение;
    :return: ключ словаря в формате строки
    """
    # проверяем если некорректное значение
    if 'Скопируйте правильные значения для указанных вопросов из квадратных скобок' in cell:
        return 0
    dct_result = {}
    cell = cell.replace('\n','') # убираем переносы
    lst_temp = cell.split(';') # сплитим по точке с запятой
    for result in lst_temp:
        # отбрасываем пустую строку
        if result:
            key,value = result.split(' - ') # извлекаем ключ и значение
            dct_result[key] = int(value)

    # возвращаем элемент с максимальным значением
    return dct_result[max(dct_result, key=dct_result.get)]




def create_out_str_ddo(x):
    """
    Функция для создания выходной строки ДДО
    """
    return f'{dct_desciprion.get(x, "Проверьте правильность написания ответа в форме,в колонке ДДО_Обработанный_результат указаны несовпадающие значения")}\nРекомендуемые профессии:\n{dct_prof.get(x, "Проверьте правильность написания ответа в форме,в колонке ДДО_Обработанный_результат указаны несовпадающие значения")}'


def processing_finish_result_ddo(row):
    """
    Обработка результатов тестирования ДДО
    """
    # Создаем словарь для хранения данных
    dct_type = {'Человек-природа': 0, 'Человек-техника': 0, 'Человек-человек': 0, 'Человек-знаковые системы': 0,
                'Человек-художественный образ': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении
    # 1
    if row[0] == 'Ухаживать за животными.':
        dct_type['Человек-природа'] += 1
    elif row[0] == 'Обслуживать машины, приборы (следить, регулировать).':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[Ухаживать за животными.] или [Обслуживать машины, приборы (следить, регулировать).]'
    # 2
    if row[1] == 'Помогать больным.':
        dct_type['Человек-человек'] += 1
    elif row[1] == 'Составлять таблицы, схемы, компьютерные программы.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[Помогать больным.] или [Составлять таблицы, схемы, компьютерные программы.]'

    # 3
    if row[2] == 'Следить за качеством книжных иллюстраций, плакатов, художественных открыток, музыкальных записей.':
        dct_type['Человек-художественный образ'] += 1
    elif row[2] == 'Следить за состоянием и развитием растений.':
        dct_type['Человек-природа'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[Следить за качеством книжных иллюстраций, плакатов, художественных открыток, музыкальных записей.] или [Следить за состоянием и развитием растений.]'

    # 4
    if row[3] == 'Обрабатывать материалы (дерево, ткань, металл, пластмассу и т.п.).':
        dct_type['Человек-техника'] += 1
    elif row[3] == 'Доводить товары до потребителя, рекламировать, продавать.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[Обрабатывать материалы (дерево, ткань, металл, пластмассу и т.п.).] или [Доводить товары до потребителя, рекламировать, продавать.]'

    # 5
    if row[4] == 'Обсуждать научно-популярные книги, статьи.':
        dct_type['Человек-знаковые системы'] += 1
    elif row[4] == 'Обсуждать художественные книги (или пьесы, концерты).':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[Обсуждать научно-популярные книги, статьи.] или [Обсуждать художественные книги (или пьесы, концерты).]'

    # 6
    if row[5] == 'Выращивать молодняк (животных какой-либо породы).':
        dct_type['Человек-природа'] += 1
    elif row[
        5] == 'Тренировать товарищей (или младших) для выполнения и закрепления каких-либо навыков (трудовых, учебных, спортивных).':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[Выращивать молодняк (животных какой-либо породы).] или [Тренировать товарищей (или младших) для выполнения и закрепления каких-либо навыков (трудовых, учебных, спортивных).]'

    # 7
    if row[6] == 'Копировать рисунки, изображения (или настраивать музыкальные инструменты).':
        dct_type['Человек-художественный образ'] += 1
    elif row[
        6] == 'Управлять какой-либо машиной (грузовым, подъемным или транспортным средством) - подъемным краном, трактором, тепловозом и др.':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[Копировать рисунки, изображения (или настраивать музыкальные инструменты).] или [Управлять какой-либо машиной (грузовым, подъемным или транспортным средством) - подъемным краном, трактором, тепловозом и др.]'

    # 8
    if row[7] == 'Сообщать, разъяснять людям нужные им сведения (в справочном бюро, на экскурсии и т.д.).':
        dct_type['Человек-человек'] += 1
    elif row[7] == 'Оформлять выставки, витрины (или участвовать в подготовке пьес, концертов).':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[Сообщать, разъяснять людям нужные им сведения (в справочном бюро, на экскурсии и т.д.).] или [Оформлять выставки, витрины (или участвовать в подготовке пьес, концертов).]'

    # 9
    if row[8] == 'Ремонтировать вещи, изделия (одежду, технику), жилище.':
        dct_type['Человек-техника'] += 1
    elif row[8] == 'Искать и исправлять ошибки в текстах, таблицах, рисунках.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[Ремонтировать вещи, изделия (одежду, технику), жилище.] или [Искать и исправлять ошибки в текстах, таблицах, рисунках.]'

    # 10
    if row[9] == 'Лечить животных.':
        dct_type['Человек-природа'] += 1
    elif row[9] == 'Выполнять вычисления, расчёты.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[Лечить животных.] или [Выполнять вычисления, расчёты.]'

    # 11
    if row[10] == 'Выводить новые сорта растений.':
        dct_type['Человек-природа'] += 1
    elif row[10] == 'Конструировать, новые виды промышленных изделий (машины, одежду, дома, продукты питания и т.п.).':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[Выводить новые сорта растений.] или [Конструировать, новые виды промышленных изделий (машины, одежду, дома, продукты питания и т.п.).]'

    # 12
    if row[11] == 'Разбирать споры, ссоры между людьми, убеждать, разъяснять, наказывать, поощрять.':
        dct_type['Человек-человек'] += 1
    elif row[11] == 'Разбираться в чертежах, схемах, таблицах (проверять, уточнять, приводить в порядок).':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[Разбирать споры, ссоры между людьми, убеждать, разъяснять, наказывать, поощрять.] или [Разбираться в чертежах, схемах, таблицах (проверять, уточнять, приводить в порядок).]'

    # 13
    if row[12] == 'Наблюдать, изучать работу коллективов художественной самодеятельности.':
        dct_type['Человек-художественный образ'] += 1
    elif row[12] == 'Наблюдать, изучать жизнь микробов.':
        dct_type['Человек-природа'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[Наблюдать, изучать работу коллективов художественной самодеятельности.] или [Наблюдать, изучать жизнь микробов.]'

    # 14
    if row[13] == 'Обслуживать, налаживать медицинские приборы, аппараты.':
        dct_type['Человек-техника'] += 1
    elif row[13] == 'Оказывать людям медицинскую помощь при ранениях, ушибах, ожогах и т.п.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[Обслуживать, налаживать медицинские приборы, аппараты.] или [Оказывать людям медицинскую помощь при ранениях, ушибах, ожогах и т.п.]'

    # 15
    if row[14] == 'Художественно описывать, изображать события (наблюдаемые и представляемые).':
        dct_type['Человек-знаковые системы'] += 1
    elif row[14] == 'Составлять точные описания-отчеты о наблюдаемых явлениях, событиях, измеряемых объектах и др.':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[Художественно описывать, изображать события (наблюдаемые и представляемые).] или [Составлять точные описания-отчеты о наблюдаемых явлениях, событиях, измеряемых объектах и др.]'

    # 16
    if row[15] == 'Делать лабораторные анализы в больнице.':
        dct_type['Человек-природа'] += 1
    elif row[15] == 'Принимать, осматривать больных, беседовать с ними, назначать лечение.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[Делать лабораторные анализы в больнице.] или [Принимать, осматривать больных, беседовать с ними, назначать лечение.]'

    # 17
    if row[16] == 'Красить или расписывать стены помещений, поверхность изделий.':
        dct_type['Человек-техника'] += 1
    elif row[16] == 'Осуществлять монтаж или сборку машин, приборов.':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[Красить или расписывать стены помещений, поверхность изделий.] или [Осуществлять монтаж или сборку машин, приборов.]'

    # 18
    if row[
        17] == 'Организовывать культпоходы сверстников или младших в театры, музеи, экскурсии, туристические походы и т.п.':
        dct_type['Человек-человек'] += 1
    elif row[17] == 'Играть на сцене, принимать участие в концертах.':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[Организовывать культпоходы сверстников или младших в театры, музеи, экскурсии, туристические походы и т.п.] или [Играть на сцене, принимать участие в концертах.]'

    # 19
    if row[18] == 'Изготовлять по чертежам детали, изделия (машины, одежду), строить здания.':
        dct_type['Человек-техника'] += 1
    elif row[18] == 'Заниматься черчением, копировать чертежи, карты.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[Изготовлять по чертежам детали, изделия (машины, одежду), строить здания.] или [Заниматься черчением, копировать чертежи, карты.]'

    # 20
    if row[19] == 'Вести борьбу с болезнями растений, с вредителями леса, сада.':
        dct_type['Человек-природа'] += 1
    elif row[19] == 'Работать на устройствах с клавиатурой, ноутбуке и др.).':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[Вести борьбу с болезнями растений, с вредителями леса, сада.] или [Работать на устройствах с клавиатурой, ноутбуке и др.).]'

    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # возвращаем элемент с максимальным значением
        return max(dct_type, key=dct_type.get)


def processing_result_ddo(row):
    """
    Обработка результатов тестирования ДДО
    """
    # Создаем словарь для хранения данных
    # Создаем словарь для хранения данных
    dct_type = {'Человек-природа': 0, 'Человек-техника': 0, 'Человек-человек': 0, 'Человек-знаковые системы': 0,
                'Человек-художественный образ': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении
    # 1
    if row[0] == 'Ухаживать за животными.':
        dct_type['Человек-природа'] += 1
    elif row[0] == 'Обслуживать машины, приборы (следить, регулировать).':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[Ухаживать за животными.] или [Обслуживать машины, приборы (следить, регулировать).]'
    # 2
    if row[1] == 'Помогать больным.':
        dct_type['Человек-человек'] += 1
    elif row[1] == 'Составлять таблицы, схемы, компьютерные программы.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[Помогать больным.] или [Составлять таблицы, схемы, компьютерные программы.]'

    # 3
    if row[2] == 'Следить за качеством книжных иллюстраций, плакатов, художественных открыток, музыкальных записей.':
        dct_type['Человек-художественный образ'] += 1
    elif row[2] == 'Следить за состоянием и развитием растений.':
        dct_type['Человек-природа'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[Следить за качеством книжных иллюстраций, плакатов, художественных открыток, музыкальных записей.] или [Следить за состоянием и развитием растений.]'

    # 4
    if row[3] == 'Обрабатывать материалы (дерево, ткань, металл, пластмассу и т.п.).':
        dct_type['Человек-техника'] += 1
    elif row[3] == 'Доводить товары до потребителя, рекламировать, продавать.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[Обрабатывать материалы (дерево, ткань, металл, пластмассу и т.п.).] или [Доводить товары до потребителя, рекламировать, продавать.]'

    # 5
    if row[4] == 'Обсуждать научно-популярные книги, статьи.':
        dct_type['Человек-знаковые системы'] += 1
    elif row[4] == 'Обсуждать художественные книги (или пьесы, концерты).':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[Обсуждать научно-популярные книги, статьи.] или [Обсуждать художественные книги (или пьесы, концерты).]'

    # 6
    if row[5] == 'Выращивать молодняк (животных какой-либо породы).':
        dct_type['Человек-природа'] += 1
    elif row[
        5] == 'Тренировать товарищей (или младших) для выполнения и закрепления каких-либо навыков (трудовых, учебных, спортивных).':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[Выращивать молодняк (животных какой-либо породы).] или [Тренировать товарищей (или младших) для выполнения и закрепления каких-либо навыков (трудовых, учебных, спортивных).]'

    # 7
    if row[6] == 'Копировать рисунки, изображения (или настраивать музыкальные инструменты).':
        dct_type['Человек-художественный образ'] += 1
    elif row[
        6] == 'Управлять какой-либо машиной (грузовым, подъемным или транспортным средством) - подъемным краном, трактором, тепловозом и др.':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[Копировать рисунки, изображения (или настраивать музыкальные инструменты).] или [Управлять какой-либо машиной (грузовым, подъемным или транспортным средством) - подъемным краном, трактором, тепловозом и др.]'

    # 8
    if row[7] == 'Сообщать, разъяснять людям нужные им сведения (в справочном бюро, на экскурсии и т.д.).':
        dct_type['Человек-человек'] += 1
    elif row[7] == 'Оформлять выставки, витрины (или участвовать в подготовке пьес, концертов).':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[Сообщать, разъяснять людям нужные им сведения (в справочном бюро, на экскурсии и т.д.).] или [Оформлять выставки, витрины (или участвовать в подготовке пьес, концертов).]'

    # 9
    if row[8] == 'Ремонтировать вещи, изделия (одежду, технику), жилище.':
        dct_type['Человек-техника'] += 1
    elif row[8] == 'Искать и исправлять ошибки в текстах, таблицах, рисунках.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[Ремонтировать вещи, изделия (одежду, технику), жилище.] или [Искать и исправлять ошибки в текстах, таблицах, рисунках.]'

    # 10
    if row[9] == 'Лечить животных.':
        dct_type['Человек-природа'] += 1
    elif row[9] == 'Выполнять вычисления, расчёты.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[Лечить животных.] или [Выполнять вычисления, расчёты.]'

    # 11
    if row[10] == 'Выводить новые сорта растений.':
        dct_type['Человек-природа'] += 1
    elif row[10] == 'Конструировать, новые виды промышленных изделий (машины, одежду, дома, продукты питания и т.п.).':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[Выводить новые сорта растений.] или [Конструировать, новые виды промышленных изделий (машины, одежду, дома, продукты питания и т.п.).]'

    # 12
    if row[11] == 'Разбирать споры, ссоры между людьми, убеждать, разъяснять, наказывать, поощрять.':
        dct_type['Человек-человек'] += 1
    elif row[11] == 'Разбираться в чертежах, схемах, таблицах (проверять, уточнять, приводить в порядок).':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[Разбирать споры, ссоры между людьми, убеждать, разъяснять, наказывать, поощрять.] или [Разбираться в чертежах, схемах, таблицах (проверять, уточнять, приводить в порядок).]'

    # 13
    if row[12] == 'Наблюдать, изучать работу коллективов художественной самодеятельности.':
        dct_type['Человек-художественный образ'] += 1
    elif row[12] == 'Наблюдать, изучать жизнь микробов.':
        dct_type['Человек-природа'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[Наблюдать, изучать работу коллективов художественной самодеятельности.] или [Наблюдать, изучать жизнь микробов.]'

    # 14
    if row[13] == 'Обслуживать, налаживать медицинские приборы, аппараты.':
        dct_type['Человек-техника'] += 1
    elif row[13] == 'Оказывать людям медицинскую помощь при ранениях, ушибах, ожогах и т.п.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[Обслуживать, налаживать медицинские приборы, аппараты.] или [Оказывать людям медицинскую помощь при ранениях, ушибах, ожогах и т.п.]'

    # 15
    if row[14] == 'Художественно описывать, изображать события (наблюдаемые и представляемые).':
        dct_type['Человек-знаковые системы'] += 1
    elif row[14] == 'Составлять точные описания-отчеты о наблюдаемых явлениях, событиях, измеряемых объектах и др.':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[Художественно описывать, изображать события (наблюдаемые и представляемые).] или [Составлять точные описания-отчеты о наблюдаемых явлениях, событиях, измеряемых объектах и др.]'

    # 16
    if row[15] == 'Делать лабораторные анализы в больнице.':
        dct_type['Человек-природа'] += 1
    elif row[15] == 'Принимать, осматривать больных, беседовать с ними, назначать лечение.':
        dct_type['Человек-человек'] += 1
    else:
        dct_error[
            'Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[Делать лабораторные анализы в больнице.] или [Принимать, осматривать больных, беседовать с ними, назначать лечение.]'

    # 17
    if row[16] == 'Красить или расписывать стены помещений, поверхность изделий.':
        dct_type['Человек-техника'] += 1
    elif row[16] == 'Осуществлять монтаж или сборку машин, приборов.':
        dct_type['Человек-техника'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[Красить или расписывать стены помещений, поверхность изделий.] или [Осуществлять монтаж или сборку машин, приборов.]'

    # 18
    if row[
        17] == 'Организовывать культпоходы сверстников или младших в театры, музеи, экскурсии, туристические походы и т.п.':
        dct_type['Человек-человек'] += 1
    elif row[17] == 'Играть на сцене, принимать участие в концертах.':
        dct_type['Человек-художественный образ'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[Организовывать культпоходы сверстников или младших в театры, музеи, экскурсии, туристические походы и т.п.] или [Играть на сцене, принимать участие в концертах.]'

    # 19
    if row[18] == 'Изготовлять по чертежам детали, изделия (машины, одежду), строить здания.':
        dct_type['Человек-техника'] += 1
    elif row[18] == 'Заниматься черчением, копировать чертежи, карты.':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[Изготовлять по чертежам детали, изделия (машины, одежду), строить здания.] или [Заниматься черчением, копировать чертежи, карты.]'

    # 20
    if row[19] == 'Вести борьбу с болезнями растений, с вредителями леса, сада.':
        dct_type['Человек-природа'] += 1
    elif row[19] == 'Работать на устройствах с клавиатурой, ноутбуке и др.).':
        dct_type['Человек-знаковые системы'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[Вести борьбу с болезнями растений, с вредителями леса, сада.] или [Работать на устройствах с клавиатурой, ноутбуке и др.).]'

    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # сортируем по убыванию
        result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
        begin_str = ''
        # создаем строку с результатами
        for sphere, value in result_lst:
            begin_str += f'{sphere} - {value};\n'

        return begin_str


def processing_result_sppu(row):
    """
    Обработка результатов тестирования
    """

    # Создаем словарь для хранения данных
    dct_type = {'сфера работы с людьми': 0, 'сфера умственного труда': 0, 'сфера технических интересов': 0,
                'сфера эстетики и искусства': 0,
                'сфера физического труда, подвижной деятельности': 0,
                'сфера материальных интересов, планово-экономических видов работ': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении

    # 1
    if row[0] == 'общаться с самыми разными людьми;':
        dct_type['сфера работы с людьми'] += 1
    elif row[0] == 'что-нибудь делать своими руками – мебель, одежду, машины и т.д.;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[0] == 'снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[общаться с самыми разными людьми;], [что-нибудь делать своими руками – мебель, одежду, машины и т.д.;], [снимать фильмы, рисовать, писать книги, выступать на сцене и т.д.]'

    # 2
    if row[1] == 'художественная форма, мастерство писателя или режиссера;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[1] == 'сюжет, действие героев;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[1] == 'информация, которая может пригодиться в жизни.':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[художественная форма, мастерство писателя или режиссера;], [сюжет, действие героев;], [информация, которая может пригодиться в жизни.]'

    # 3
    if row[2] == 'в области науки;':
        dct_type['сфера умственного труда'] += 1
    elif row[2] == 'за общественную деятельность;':
        dct_type['сфера работы с людьми'] += 1
    elif row[2] == 'в области искусства.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[в области науки;], [за общественную деятельность;], [в области искусства.]'

    # 4
    if row[3] == 'управляющим банка;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[3] == 'главным инженером на производстве;':
        dct_type['сфера технических интересов'] += 1
    elif row[3] == 'начальником экспедиции.':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[управляющим банка;], [главным инженером на производстве;], [начальником экспедиции.]'

    # 5
    if row[4] == 'достижения науки;':
        dct_type['сфера умственного труда'] += 1
    elif row[4] == 'развитие производства;':
        dct_type['сфера технических интересов'] += 1
    elif row[4] == 'взаимопонимание среди людей.':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[достижения науки;], [развитие производства;], [взаимопонимание среди людей.]'

    # 6
    if row[5] == 'благоустройством школы (столовая, спортзал, компьютеры);':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[5] == 'созданием дружного, сплоченного коллектива;':
        dct_type['сфера работы с людьми'] += 1
    elif row[5] == 'разработкой новых технологий обучения.':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[благоустройством школы (столовая, спортзал, компьютеры);], [созданием дружного, сплоченного коллектива;], [разработкой новых технологий обучения.]'

    # 7
    if row[6] == 'внешний вид экспонатов (цвет, форма);':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[6] == 'внутреннее устройство экспонатов (механизм);':
        dct_type['сфера умственного труда'] += 1
    elif row[6] == 'практическое применение экспонатов.':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[внешний вид экспонатов (цвет, форма);], [внутреннее устройство экспонатов (механизм);], [практическое применение экспонатов.]'

    # 8
    if row[7] == 'мужество, смелость, выносливость;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[7] == 'дружелюбие, чуткость, отзывчивость;':
        dct_type['сфера работы с людьми'] += 1
    elif row[7] == 'ответственность, аккуратность.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[мужество, смелость, выносливость;], [дружелюбие, чуткость, отзывчивость;], [ответственность, аккуратность.]'

    # 9
    if row[8] == 'писать стихи или музыку или рисовать;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[8] == 'ставить различные опыты;':
        dct_type['сфера умственного труда'] += 1
    elif row[8] == 'тренироваться.':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[писать стихи или музыку или рисовать;], [ставить различные опыты;], [тренироваться.]'

    # 10
    if row[9] == 'экстремальный туризм (альпинизм, виндсерфинг, горные лыжи);':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[9] == 'деловое общение;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[9] == 'возможность знакомства с историей и культурой другой страны.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[экстремальный туризм (альпинизм, виндсерфинг, горные лыжи);], [деловое общение;], [возможность знакомства с историей и культурой другой страны.]'

    # 11
    if row[10] == 'о машине нового типа;':
        dct_type['сфера технических интересов'] += 1
    elif row[10] == 'о новой научной теории;':
        dct_type['сфера умственного труда'] += 1
    elif row[10] == 'о человеческих взаимоотношениях.':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[о машине нового типа;], [о новой научной теории;], [о человеческих взаимоотношениях.]'

    # 12
    if row[11] == 'технический;':
        dct_type['сфера технических интересов'] += 1
    elif row[11] == 'музыкальный;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[11] == 'спортивный.':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[технический;], [музыкальный;], [спортивный.]'

    # 13
    if row[12] == 'улучшению взаимопонимания между учителями и учениками;':
        dct_type['сфера работы с людьми'] += 1
    elif row[12] == 'поддержанию здоровья учащихся, занятиям спортом;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[12] == 'укреплению дисциплины.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[улучшению взаимопонимания между учителями и учениками;], [поддержанию здоровья учащихся, занятиям спортом;], [укреплению дисциплины.]'

    # 14
    if row[13] == 'научно-популярные фильмы;':
        dct_type['сфера умственного труда'] += 1
    elif row[13] == 'программы о культуре и спорте;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[13] == 'спортивные программы.':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[научно-популярные фильмы;], [программы о культуре и спорте;], [спортивные программы.]'

    # 15
    if row[14] == 'с машинами, механизмами;':
        dct_type['сфера технических интересов'] += 1
    elif row[14] == 'с объектами природы;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[14] == 'с детьми или сверстниками.':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[с машинами, механизмами;], [с объектами природы;], [с детьми или сверстниками.]'

    # 16
    if row[15] == 'давать знания и умения;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[15] == 'учить общению с другими людьми;':
        dct_type['сфера работы с людьми'] += 1
    elif row[15] == 'обучать навыкам работы.':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[давать знания и умения;], [учить общению с другими людьми;], [обучать навыкам работы.]'

    # 17
    if row[16] == 'вести здоровый образ жизни;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[16] == 'иметь возможность заниматься творчеством;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[16] == 'иметь удобные бытовые условия.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[вести здоровый образ жизни;], [иметь возможность заниматься творчеством;], [иметь удобные бытовые условия.]'

    # 18
    if row[17] == 'защита интересов и прав граждан;':
        dct_type['сфера работы с людьми'] += 1
    elif row[17] == 'забота о материальном благополучии людей;':
        dct_type['сфера технических интересов'] += 1
    elif row[17] == 'наука и технический прогресс.':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[защита интересов и прав граждан;], [забота о материальном благополучии людей;], [наука и технический прогресс.]'

    # 19
    if row[18] == 'физкультуры;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[18] == 'математики;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[18] == 'труда.':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[физкультуры;], [математики;], [труда.]'

    # 20
    if row[19] == 'планировать производство продукции;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[19] == 'изготавливать изделия;':
        dct_type['сфера технических интересов'] += 1
    elif row[19] == 'заниматься сбытом продукции.':
        dct_type['сфера работы с людьми'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[планировать производство продукции;], [изготавливать изделия;], [заниматься сбытом продукции.]'

    # 21
    if row[20] == 'о выдающихся ученых и их открытиях;':
        dct_type['сфера умственного труда'] += 1
    elif row[20] == 'о творчестве ученых и музыкантов;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[20] == 'об интересных изобретениях.':
        dct_type['сфера технических интересов'] += 1
    else:
        dct_error[
            'Вопрос №21'] = f'Полученное значение-{row[20]} не совпадает с эталонными:[о выдающихся ученых и их открытиях;], [о творчестве ученых и музыкантов;], [об интересных изобретениях.]'

    # 22
    if row[21] == 'делая что-то по хозяйству;':
        dct_type['сфера технических интересов'] += 1
    elif row[21] == 'с книгой;':
        dct_type['сфера умственного труда'] += 1
    elif row[21] == 'на выставках, концертах и пр.':
        dct_type['сфера эстетики и искусства'] += 1
    else:
        dct_error[
            'Вопрос №22'] = f'Полученное значение-{row[21]} не совпадает с эталонными:[делая что-то по хозяйству;], [с книгой;], [на выставках, концертах и пр.]'

    # 23
    if row[22] == 'о художественной выставке;':
        dct_type['сфера эстетики и искусства'] += 1
    elif row[22] == 'о ситуации на фондовой бирже;':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    elif row[22] == 'о научном открытии.':
        dct_type['сфера умственного труда'] += 1
    else:
        dct_error[
            'Вопрос №23'] = f'Полученное значение-{row[22]} не совпадает с эталонными:[о художественной выставке;], [о ситуации на фондовой бирже;], [о научном открытии.]'

    # 24
    if row[23] == 'в помещении, где много людей;':
        dct_type['сфера работы с людьми'] += 1
    elif row[23] == 'в необычных условиях;':
        dct_type['сфера физического труда, подвижной деятельности'] += 1
    elif row[23] == 'в обычном кабинете.':
        dct_type['сфера материальных интересов, планово-экономических видов работ'] += 1
    else:
        dct_error[
            'Вопрос №24'] = f'Полученное значение-{row[23]} не совпадает с эталонными:[в помещении, где много людей;], [в необычных условиях;], [в обычном кабинете.]'

    # проверяем на ошибки
    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # сортируем по убыванию
        result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
        begin_str = ''
        # создаем строку с результатами
        for sphere, value in result_lst:
            begin_str += f'{sphere} - {value};\n'

        # добавляем описание
        return begin_str


def processing_result_optl(row):
    """
    Функция для подсчета результатов теста на определение профессионального типа личности
    :return:
    """
    # Создаем словарь для хранения данных
    dct_type = {'Реалистический': 0, 'Интеллектуальный': 0, 'Социальный': 0,
                'Офисный': 0,
                'Предпринимательский': 0,
                'Артистический': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении
    # 1
    if row[0] == 'Автомеханик':
        dct_type['Реалистический'] += 1
    elif row[0] == 'Физиотерапевт':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №1'] = f'Полученное значение-{row[0]} не совпадает с эталонными:[Автомеханик] или [Физиотерапевт]'

    # 2
    if row[1] == 'Специалист по защите информации':
        dct_type['Интеллектуальный'] += 1
    elif row[1] == 'Логистик':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №2'] = f'Полученное значение-{row[1]} не совпадает с эталонными:[Специалист по защите информации] или [Логистик]'

    # 3
    if row[2] == 'Оператор связи':
        dct_type['Офисный'] += 1
    elif row[2] == 'Кинооператор':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №3'] = f'Полученное значение-{row[2]} не совпадает с эталонными:[Оператор связи] или [Кинооператор]'

    # 4
    if row[3] == 'Водитель':
        dct_type['Реалистический'] += 1
    elif row[3] == 'Продавец':
        dct_type['Социальный'] += 1
    else:
        dct_error['Вопрос №4'] = f'Полученное значение-{row[3]} не совпадает с эталонными:[Водитель] или [Продавец]'

    # 5
    if row[4] == 'Инженер-конструктор':
        dct_type['Интеллектуальный'] += 1
    elif row[4] == 'Менеджер по продажам':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №5'] = f'Полученное значение-{row[4]} не совпадает с эталонными:[Инженер-конструктор] или [Менеджер по продажам]'

    # 6
    if row[5] == 'Диспетчер':
        dct_type['Офисный'] += 1
    elif row[5] == 'Дизайнер компьютерных программ':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №6'] = f'Полученное значение-{row[5]} не совпадает с эталонными:[Диспетчер] или [Дизайнер компьютерных программ]'

    # 7
    if row[6] == 'Ветеринар':
        dct_type['Реалистический'] += 1
    elif row[6] == 'Эколог':
        dct_type['Социальный'] += 1
    else:
        dct_error['Вопрос №7'] = f'Полученное значение-{row[6]} не совпадает с эталонными:[Ветеринар] или [Эколог]'

    # 8
    if row[7] == 'Биолог-исследователь':
        dct_type['Интеллектуальный'] += 1
    elif row[7] == 'Фермер':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №8'] = f'Полученное значение-{row[7]} не совпадает с эталонными:[Биолог-исследователь] или [Фермер]'

    # 9
    if row[8] == 'Лаборант':
        dct_type['Офисный'] += 1
    elif row[8] == 'Дрессировщик':
        dct_type['Артистический'] += 1
    else:
        dct_error['Вопрос №9'] = f'Полученное значение-{row[8]} не совпадает с эталонными:[Лаборант] или [Дрессировщик]'

    # 10
    if row[9] == 'Агроном':
        dct_type['Реалистический'] += 1
    elif row[9] == 'Санитарный врач':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №10'] = f'Полученное значение-{row[9]} не совпадает с эталонными:[Агроном] или [Санитарный врач]'

    # 11
    if row[10] == 'Селекционер':
        dct_type['Интеллектуальный'] += 1
    elif row[10] == 'Заготовитель сельхозпродуктов':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №11'] = f'Полученное значение-{row[10]} не совпадает с эталонными:[Селекционер] или [Заготовитель сельхозпродуктов]'

    # 12
    if row[11] == 'Микробиолог':
        dct_type['Офисный'] += 1
    elif row[11] == 'Ландшафтный дизайнер':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №12'] = f'Полученное значение-{row[11]} не совпадает с эталонными:[Микробиолог] или [Ландшафтный дизайнер]'

    # 13
    if row[12] == 'Массажист':
        dct_type['Реалистический'] += 1
    elif row[12] == 'Воспитатель':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №13'] = f'Полученное значение-{row[12]} не совпадает с эталонными:[Массажист] или [Воспитатель]'

    # 14
    if row[13] == 'Преподаватель':
        dct_type['Интеллектуальный'] += 1
    elif row[13] == 'Предприниматель':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №14'] = f'Полученное значение-{row[13]} не совпадает с эталонными:[Преподаватель] или [Предприниматель]'

    # 15
    if row[14] == 'Администратор':
        dct_type['Офисный'] += 1
    elif row[14] == 'Режиссер театра и кино':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №15'] = f'Полученное значение-{row[14]} не совпадает с эталонными:[Администратор] или [Режиссер театра и кино]'

    # 16
    if row[15] == 'Официант':
        dct_type['Реалистический'] += 1
    elif row[15] == 'Врач':
        dct_type['Социальный'] += 1
    else:
        dct_error['Вопрос №16'] = f'Полученное значение-{row[15]} не совпадает с эталонными:[Официант] или [Врач]'

    # 17
    if row[16] == 'Психолог':
        dct_type['Интеллектуальный'] += 1
    elif row[16] == 'Торговый агент':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №17'] = f'Полученное значение-{row[16]} не совпадает с эталонными:[Психолог] или [Торговый агент]'

    # 18
    if row[17] == 'Страховой агент':
        dct_type['Офисный'] += 1
    elif row[17] == 'Хореограф':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №18'] = f'Полученное значение-{row[17]} не совпадает с эталонными:[Страховой агент] или [Хореограф]'

    # 19
    if row[18] == 'Ювелир-гравер':
        dct_type['Реалистический'] += 1
    elif row[18] == 'Журналист':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №19'] = f'Полученное значение-{row[18]} не совпадает с эталонными:[Ювелир-гравер] или [Журналист]'

    # 20
    if row[19] == 'Искусствовед':
        dct_type['Интеллектуальный'] += 1
    elif row[19] == 'Продюсер':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №20'] = f'Полученное значение-{row[19]} не совпадает с эталонными:[Искусствовед] или [Продюсер]'

    # 21
    if row[20] == 'Редактор':
        dct_type['Офисный'] += 1
    elif row[20] == 'Музыкант':
        dct_type['Артистический'] += 1
    else:
        dct_error['Вопрос №21'] = f'Полученное значение-{row[20]} не совпадает с эталонными:[Редактор] или [Музыкант]'

    # 22
    if row[21] == 'Дизайнер интерьера':
        dct_type['Реалистический'] += 1
    elif row[21] == 'Экскурсовод':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №22'] = f'Полученное значение-{row[21]} не совпадает с эталонными:[Дизайнер интерьера] или [Экскурсовод]'

    # 23
    if row[22] == 'Композитор':
        dct_type['Интеллектуальный'] += 1
    elif row[22] == 'Арт-директор':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №23'] = f'Полученное значение-{row[22]} не совпадает с эталонными:[Композитор] или [Арт-директор]'

    # 24
    if row[23] == 'Музейный работник':
        dct_type['Офисный'] += 1
    elif row[23] == 'Актер театра и кино':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №24'] = f'Полученное значение-{row[23]} не совпадает с эталонными:[Музейный работник] или [Актер театра и кино]'

    # 25
    if row[24] == 'Верстальщик':
        dct_type['Реалистический'] += 1
    elif row[24] == 'Гид-переводчик':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №25'] = f'Полученное значение-{row[24]} не совпадает с эталонными:[Верстальщик] или [Гид-переводчик]'

    # 26
    if row[25] == 'Лингвист':
        dct_type['Интеллектуальный'] += 1
    elif row[25] == 'Антикризисный управляющий':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error[
            'Вопрос №26'] = f'Полученное значение-{row[25]} не совпадает с эталонными:[Лингвист] или [Антикризисный управляющий]'

    # 27
    if row[26] == 'Корректор':
        dct_type['Офисный'] += 1
    elif row[26] == 'Художественный редактор':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №27'] = f'Полученное значение-{row[26]} не совпадает с эталонными:[Корректор] или [Художественный редактор]'

    # 28
    if row[27] == 'Наборщик текстов':
        dct_type['Реалистический'] += 1
    elif row[27] == 'Юрисконсульт':
        dct_type['Социальный'] += 1
    else:
        dct_error[
            'Вопрос №28'] = f'Полученное значение-{row[27]} не совпадает с эталонными:[Наборщик текстов] или [Юрисконсульт]'

    # 29
    if row[28] == 'Программист':
        dct_type['Интеллектуальный'] += 1
    elif row[28] == 'Брокер':
        dct_type['Предпринимательский'] += 1
    else:
        dct_error['Вопрос №29'] = f'Полученное значение-{row[28]} не совпадает с эталонными:[Программист] или [Брокер]'

    # 30
    if row[29] == 'Бухгалтер':
        dct_type['Офисный'] += 1
    elif row[29] == 'Литературный переводчик':
        dct_type['Артистический'] += 1
    else:
        dct_error[
            'Вопрос №30'] = f'Полученное значение-{row[29]} не совпадает с эталонными:[Бухгалтер] или [Литературный переводчик]'

        # проверяем на ошибки
    if len(dct_error) > 0:
        begin_str = 'Скопируйте правильные значения для указанных вопросов из квадратных скобок в вашу форму. \n'
        # создаем строку с результатами
        for sphere, value in dct_error.items():
            begin_str += f'{sphere} - {value};\n'
        return begin_str
    else:
        # сортируем по убыванию
        result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)
        begin_str = ''
        # создаем строку с результатами
        for sphere, value in result_lst:
            begin_str += f'{sphere} - {value};\n'

        return begin_str


def processing_result_dcok(row):
    """
Функция для вычисления итогового балла  результатов теста Диагностика ценностных ориентаций в карьере
"""

    # Создаем словарь для хранения данных
    dct_type = {'Профессиональная компетентность': 0, 'Менеджмент': 0, 'Автономия (независимость)': 0,
                'Стабильность работы': 0,
                'Стабильность места жительства': 0, 'Служение': 0, 'Вызов': 0,
                'Интеграция стилей жизни': 0, 'Предпринимательство': 0}
    dct_error = {}  # словарь для хранения ошибочных  значений, для того чтобы было легче находить ошибки при обновлении
    # 1
    dct_type['Профессиональная компетентность'] += row[0]

    # 2
    dct_type['Менеджмент'] += row[1]

    # 3
    dct_type['Автономия (независимость)'] += row[2]

    # 4
    dct_type['Стабильность работы'] += row[3]

    # 5
    dct_type['Служение'] += row[4]

    # 6
    dct_type['Вызов'] += row[5]

    # 7
    dct_type['Интеграция стилей жизни'] += row[6]

    # 8
    dct_type['Предпринимательство'] += row[7]

    # 9
    dct_type['Профессиональная компетентность'] += row[8]

    # 10
    dct_type['Менеджмент'] += row[9]

    # 11
    dct_type['Автономия (независимость)'] += row[10]

    # 12
    dct_type['Стабильность работы'] += row[11]

    # 13
    dct_type['Служение'] += row[12]

    # 14
    dct_type['Вызов'] += row[13]

    # 15
    dct_type['Интеграция стилей жизни'] += row[14]

    # 16
    dct_type['Предпринимательство'] += row[15]

    # 17
    dct_type['Профессиональная компетентность'] += row[16]

    # 18
    dct_type['Менеджмент'] += row[17]

    # 19
    dct_type['Автономия (независимость)'] += row[18]

    # 20
    dct_type['Стабильность места жительства'] += row[19]

    # 21
    dct_type['Служение'] += row[20]

    # 22
    dct_type['Вызов'] += row[21]

    # 23
    dct_type['Интеграция стилей жизни'] += row[22]

    # 24
    dct_type['Предпринимательство'] += row[23]

    # 25
    dct_type['Профессиональная компетентность'] += row[24]

    # 26
    dct_type['Менеджмент'] += row[25]

    # 27
    dct_type['Автономия (независимость)'] += row[26]

    # 28
    dct_type['Стабильность места жительства'] += row[27]

    # 29
    dct_type['Служение'] += row[28]

    # 30
    dct_type['Вызов'] += row[29]

    # 31
    dct_type['Интеграция стилей жизни'] += row[30]

    # 32
    dct_type['Предпринимательство'] += row[31]

    # 33
    dct_type['Профессиональная компетентность'] += row[32]

    # 34
    dct_type['Менеджмент'] += row[33]

    # 35
    dct_type['Автономия (независимость)'] += row[34]

    # 36
    dct_type['Стабильность работы'] += row[35]

    # 37
    dct_type['Служение'] += row[36]

    # 38
    dct_type['Вызов'] += row[37]

    # 39
    dct_type['Интеграция стилей жизни'] += row[38]

    # 40
    dct_type['Предпринимательство'] += row[39]

    # 41
    dct_type['Стабильность места жительства'] += row[40]

    # Делим на 5 результаты
    for key, value in dct_type.items():
        dct_type[key] = round(dct_type[key] / 5)
    # Сортируем
    result_lst = sorted(dct_type.items(), key=lambda t: t[1], reverse=True)

    begin_str = ''
    # создаем строку с результатами
    for sphere, value in result_lst:
        begin_str += f'{sphere} - {value};\n'

    return begin_str

def processing_dcok(base_df: pd.DataFrame, answers_df: pd.DataFrame, size: int,name_test):
    """
    Фугкция для обработки данных ДЦОК
    :return:
    """
    if answers_df.shape[1] != size:
        raise WrongNumberColumn
    answers_df.columns = [f'{name_test}_Вопрос_ №_{i}' for i in range(1, answers_df.shape[1] + 1)]

    answers_df = answers_df.astype(int)

    # Создаем колонку для результов первичного подсчета
    answers_df[f'{name_test}_Необработанный_результат'] = answers_df.apply(processing_result_dcok, axis=1)
    answers_df[f'{name_test}_Обработанный_результат'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_key_max_value)
    answers_df[f'{name_test}_Числовое_значение_результата'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_max_value)

    # Создаем датафрейм для данных отчета
    report_df = answers_df.iloc[::, size + 1:]

    # Создаем датафрейм в который будем заносить итоговые результаты
    finish_report_df = report_df[f'{name_test}_Обработанный_результат'].value_counts().to_frame()

    # получаем процента
    finish_report_df['Доля_от_общего_количества'] = round(
        (finish_report_df[f'{name_test}_Обработанный_результат'] / report_df.shape[0]) * 100, 2)

    finish_report_df = finish_report_df.reset_index()

    finish_report_df.columns = ['Категория', 'Количество', 'Доля в % от общего количества']


    # соединяем после обработки
    df = pd.concat([base_df, answers_df], axis=1)
    description_result = """
По каждой из девяти карьерных ориентаций подсчитывается количество баллов. Таким образом определяется ведущая карьерная ориентация - количество набранных для этого баллов должно быть не менее пяти. Иногда ведущей не становится ни одна карьерная ориентация - в таком случае карьера не является центральной в жизни личности. 

1) Профессиональная компетентность -быть профессионалом, мастером в своем деле. 
Эта ориентация связана с наличием способностей и талантов в определенной области.
Люди с такой ориентацией хотят быть мастерами своего дела, они бывают особенно счастливы, когда достигают успеха в профессиональной сфере, но быстро теряют интерес к работе, которая не позволяет развивать их способности. Вряд ли их заинтересует даже значительно более высокая должность, если она не связана с их профессиональными компетенциями. Они ищут признания своих талантов, что должно выражаться в статусе, соответствующем их мастерству. Они готовы управлять другими в пределах своей компетенции, но управление не представляет для них особого интереса. Поэтому многие из этой категории отвергают работу руководителя, управление рассматривают как необходимое условие для продвижения в своей профессиональной сфере.
2) Менеджмент - Управлять – людьми, проектами, бизнес-процессами и т.п.
Для этих людей первостепенное значение имеет ориентация личности на интеграцию усилий других людей, полнота ответственности за конечный результат и соединение различных функций организации. С возрастом и опытом эта карьерная ориентация проявляется сильнее. Возможности для лидерства, высокого дохода, повышенных уровней ответственности и вклад в успех своей организации являются ключевыми ценностями и мотивами. Самое главное для них – управление: людьми, проектами, любыми бизнес-процессами – это в целом не имеет принципиального значения. Центральное понятие их профессионального развития – власть, осознание того, что от них зависит принятие ключевых решений. Причем для них не является принципиальным управление собственным проектом или целым бизнесом, скорее наоборот, они в большей степени ориентированы на построение карьеры в наемном менеджменте, но при условии, что им будут делегированы значительные полномочия. Человек с такой ориентацией будет считать, что не достиг цели своей карьеры, пока не займет должность, на которой будет управлять различными сторонами деятельности предприятия.
3) Автономия (независимость) – Главное в работе – это свобода и независимость. 
Первичная забота личности с такой ориентацией –освобождение от организационных правил, предписаний и ограничений. Они испытывают трудности, связанные с установленными правилами, процедурами, рабочим днем, дисциплиной, формой одежды и т.д. Они любят выполнять работу своим способом, темпом и по собственным стандартам. Они не любят, когда работа вмешивается в их частную жизнь, поэтому предпочитают делать независимую карьеру собственным путем. Они скорее выберут низкосортную работу, чем откажутся от автономии и независимости. Для них первоочередная задача развития карьеры – получить возможность работать самостоятельно, самому решать, как, когда и что делать для достижения тех или иных целей. Карьера для них – это, прежде всего, способ реализации их свободы, поэтому любые рамки и строгое подчинение оттолкнут их даже от внешне привлекательной вакансии. Такой человек может работать в организации, которая обеспечивает достаточную степень свободы.
4) Стабильность работы - стабильная, надежная работа на длительное время.
Эти люди испытывают потребность в безопасности, защите и возможности прогнозирования и будут искать постоянную работу с минимальной вероятностью увольнения. Эти люди отождествляют свою работу со своей карьерой. Их потребность в безопасности и стабильности ограничивает выбор вариантов	карьеры.
Авантюрные или краткосрочные проекты и только становящиеся на ноги компании их, скорее всего, не привлекают. Они очень ценят социальные гарантии, которые может предложить работодатель, и, как правило, их выбор места работы связан именно с длительным контрактом и стабильным положением компании на рынке. Такие люди ответственность за управление своей карьерой перекладывают на нанимателя. Часто данная ценностная ориентация сочетается с невысоким уровнем притязаний.
5) Стабильность места жительства - Главное – жить в своем городе (минимум переездов, командировок).
Важнее остаться на одном месте жительства, чем получить повышение или новую работу на новой местности. Переезд для таких людей неприемлем, и даже частые командировки являются для них негативным фактором при рассмотрении	предложения о работе.
6) Служение - Воплощать в работе свои идеалы и ценности.
Данная ценностная ориентация характерна для людей, занимающихся делом по причине желания реализовать в своей работе главные ценности. Они часто ориентированы больше на ценности, чем на требующиеся в данном виде работы способности. Они стремятся приносить пользу людям, обществу, для них очень важно видеть конкретные плоды своей работы, даже если они и не выражены в материальном эквиваленте. Основной тезис построения их карьеры – получить возможность максимально эффективно использовать их таланты и опыт для реализации общественно	важной цели. Люди, ориентированные на служение, общительны и часто консервативны. Человек с такой ориентацией не будет работать в организации, которая враждебна его целям и ценностям.
7) Вызов - Сделать   невозможное – возможным, решать   уникальные   задачи. 
Эти люди считают успехом преодоление непреодолимых препятствий, решение неразрешимых проблем или просто выигрыш. Они ориентированы на то, чтобы “бросать вызов”. Для одних людей вызов представляет более трудная работа, для других это — конкуренция и межличностные отношения. Они ориентированы на решение заведомо сложных задач, преодоление препятствий ради победы в конкурентной борьбе. Они чувствуют себя преуспевающими только тогда, когда постоянно вовлечены в решение трудных проблем или в ситуацию соревнования. Карьера для них – это постоянный вызов их профессионализму, и они всегда готовы его принять. Социальная ситуация чаще всего рассматривается с позиции “выигрыша – проигрыша”. Процесс борьбы и победа более важна для них, чем конкретная область деятельности или квалификация. Новизна, разнообразие и вызов имеют для них очень большую ценность, и, если все идет слишком просто, им становиться скучно.
8) Интеграция стилей жизни - Сохранение гармонии между сложившейся личной жизнью и карьерой.
Для людей этой категории карьера должна ассоциироваться с общим стилем жизни, уравновешивая потребности человека, семьи и карьеры. Они хотят, чтобы организационные отношения отражали бы уважение к их личным и семейным проблемам.
Выбирать и поддерживать определенный образ жизни для них важнее, чем добиваться успеха в карьере. Развитие карьеры их привлекает только в том случае, если она не нарушает привычный им стиль жизни и окружение. Для них важно, чтобы все было уравновешено – карьера, семья, личные интересы и т.п. Жертвовать   чем-то   одним   ради   другого   им    явно    не    свойственно. Такие люди обычно в своем поведении проявляют конформность (тенденция изменять свое поведение в зависимости от влияния других людей с тем, чтобы оно соответствовало мнению окружающих)
9) Предпринимательство – Создавать новые организации, товары, услуги.
Этим людям нравится создавать новые организации, товары или услуги, которые могут быть отождествлены с их усилиями. Работать на других – это не их, они – предприниматели по духу, и цель их карьеры – создать что-то новое, организовать свое дело, воплотить в жизнь идею, всецело принадлежащую только им. Вершина карьеры в их понимании – собственный бизнес.
"""
    # создаем описание результата
    if 'ФИО' in df.columns:
        df[f'{name_test}_Описание_результата'] = df['ФИО'] + '.' + ' \nДиагностика ценностных ориентаций в карьере.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result
    else:
        df[f'{name_test}_Описание_результата'] = 'Диагностика ценностных ориентаций в карьере.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result

    # генерируем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)



    # Создаем сокращенный вариант
    send_df = df.iloc[:, :threshold_base]
    # Добавляем колонки с результатами
    send_df[f'{name_test}_Необработанный_результат'] = df[f'{name_test}_Необработанный_результат']
    send_df[f'{name_test}_Обработанный_результат'] = df[f'{name_test}_Обработанный_результат']
    send_df[f'{name_test}_Числовое_значение_результата'] = df[f'{name_test}_Числовое_значение_результата']
    send_df[f'{name_test}_Описание_результата'] = df[f'{name_test}_Описание_результата']
    # создаем датафреймы для возврата в основную функцию
    out_full_df = df.iloc[:, threshold_base:]  # датафрейм с вопросами и результатами без анкетных данных
    out_result_df = send_df.iloc[:, threshold_base:]

    # Сортировка
    df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    send_df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    df.to_excel(f'{path_to_end_folder_complex}/Полная таблица с результатами {name_test} от {current_time}.xlsx', index=False,
                engine='xlsxwriter')
    send_df.to_excel(f'{path_to_end_folder_complex}/Краткая таблица с результатами {name_test}  от {current_time}.xlsx',
                     index=False, engine='xlsxwriter')
    finish_report_df.to_excel(f'{path_to_end_folder_complex}/Отчет {name_test}  от {current_time}.xlsx',
                              index=False, engine='xlsxwriter')



    return out_full_df, out_result_df


def processing_optl(base_df: pd.DataFrame, answers_df: pd.DataFrame, size: int,name_test):
    """
    Функция для обработки результатов на определение профессионального типа личности
    """
    if answers_df.shape[1] != size:
        raise WrongNumberColumn

    answers_df.columns = [f'{name_test}_Вопрос_ №_{i}' for i in range(1, answers_df.shape[1] + 1)]

    answers_df = answers_df.astype(str)

    answers_df = answers_df.applymap(lambda x: x.strip())
    answers_df[f'{name_test}_Необработанный_результат'] = answers_df.apply(processing_result_optl, axis=1)
    answers_df[f'{name_test}_Обработанный_результат'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_key_max_value)
    answers_df[f'{name_test}_Числовое_значение_результата'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_max_value)

    # Создаем датафрейм для данных отчета
    report_df = answers_df.iloc[::, size + 1:]

    # Создаем датафрейм в который будем заносить итоговые результаты
    finish_report_df = report_df[f'{name_test}_Обработанный_результат'].value_counts().to_frame()

    # получаем процента
    finish_report_df['Доля_от_общего_количества'] = round(
        (finish_report_df[f'{name_test}_Обработанный_результат'] / report_df.shape[0]) * 100, 2)

    finish_report_df = finish_report_df.reset_index()

    finish_report_df.columns = ['Категория', 'Количество', 'Доля в % от общего количества']

    # соединяем после обработки
    df = pd.concat([base_df, answers_df], axis=1)

    description_result = """
Обработка результатов теста 
8-10 баллов – ярко выраженный тип;  
5-7 баллов – средне выраженный тип;  
2-4 баллов – слабо выраженный тип.  
Наибольшее количество баллов указывает на доминирующий тип. В чистом виде эти профессиональные типы встречаются редко – обычно можно говорить только о преобладающем типе личности. Выбирая профессию, необходимо учитывать свой профессиональный тип. Если профессия не соответствует вашему типу личности, работа будет даваться вам ценой значительного нервно-психического напряжения.  
Интерпретация результатов теста 
1. Реалистический тип (Р) 
Люди, относящиеся к этому типу, предпочитают выполнять работу, требующую силы, ловкости, подвижности, хорошей координации движений, навыков практической работы. Результаты труда профессионалов этого типа ощутимы и реальны – их руками создан весь окружающий нас предметный мир. Люди реалистического типа охотнее делают, чем говорят, они настойчивы и уверены в себе, в работе предпочитают четкие и конкретные указания. Придерживаются традиционных ценностей, поэтому критически относятся к новым идеям.  
Близкие типы: интеллектуальный и офисный.  
Противоположный тип: социальный.  
Хороший продавец и хороший ремонтник никогда не будут голодать. Шенк 
2. Интеллектуальный (И) 
Людей, относящихся к этому типу, отличают аналитические способности, рационализм, независимость и оригинальность мышления, умение точно формулировать и излагать свои мысли, решать логические задачи, генерировать новые идеи. Они часто выбирают научную и исследовательскую работу. Им нужна свобода для творчества. Работа способна увлечь их настолько, что стирается грань между рабочим временем и досугом. Мир идей для них может быть важнее, чем общение с людьми. Материальное благополучие для них обычно не на первом месте.  
Близкие типы: реалистический и артистический.  
Противоположный тип: предпринимательский.  
Научная работа не подходит человеку, который обеими ногами стоит на земле и обеими руками тянется к долларам. М.Ларни 
3. Социальный (С) 
Люди, относящиеся к этому типу, предпочитают профессиональную деятельность, связанную с обучением, воспитанием, лечением, консультированием, обслуживанием. Люди этого типа гуманны, чувствительны, активны, ориентированы на социальные нормы, способны понять эмоциональное состояние другого человека. Для них характерно хорошее речевое развитие, живая мимика, интерес к людям, готовность прийти на помощь. Материальное благополучие для них обычно не на первом месте.  
Близкие типы: артистический и предпринимательский.  
Противоположный тип: реалистический.  
Если больному после разговора с врачом не стало легче, то это не врач. В.Бехтерев 
4. Офисный (О) 
Люди этого типа обычно проявляют склонность к работе, связанной с обработкой и систематизацией информации, предоставленной в виде условных знаков, цифр, формул, текстов (ведение документации, установление количественных соотношений между числами и условными знаками). Они отличаются аккуратностью, пунктуальностью, практичностью, ориентированы на социальные нормы, предпочитают четко регламентированную работу. Материальное благополучие для них более значимо, чем для других типов. Склонны к работе, не связанной с широкими контактами и принятием ответственных решений.  
Близкие типы: реалистический и предпринимательский.  
Противоположный тип: артистический.  
Офис может работать без шефа, но не без секретаря. Дж.Фонда 
5. Предпринимательский (П)  
Люди этого типа находчивы, практичны, быстро ориентируются в сложной обстановке, склонны к самостоятельному принятию решений, социально активны, готовы рисковать, ищут острые ощущения. Любят и умеют общаться. Имеют высокий уровень притязаний. Избегают занятий, требующих усидчивости, большой и длительной концентрации внимания. Для них значимо материальное благополучие. Предпочитают деятельность, требующую энергии, организаторских способностей, связанную с руководством, управлением и влиянием на людей.  
Близкие типы: офисный и социальный.  
Противоположный тип: исследовательский.  
Специальность налетчика куда менее заманчива, чем смежные с ней профессии политика или биржевого спекулянта. О.Генри  
6. Артистический (А)  
Люди этого типа оригинальны, независимы в принятии решений, редко ориентируются на социальные нормы и одобрение, обладают необычным взглядом на жизнь, гибкостью мышления, эмоциональной чувствительностью.
Отношения с людьми строят, опираясь на свои ощущения, эмоции, воображение, интуицию. Они не выносят жесткой регламентации, предпочитая свободный график работы. Часто выбирают профессии, связанные с литературой, театром, кино, музыкой, изобразительным искусством.  
Близкие типы: интеллектуальный и социальный.  
Противоположный тип: офисный.  
Только поэты и женщины умеют обращаться с деньгами так, как деньги того заслуживают. А.Боннар 
"""
    if 'ФИО' in df.columns:
        df[f'{name_test}_Описание_результата'] = df['ФИО'] + '.' + ' \nОпределение профессионального типа личности.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result
    else:
        df[f'{name_test}_Описание_результата'] = 'Определение профессионального типа личности.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result

    # генерируем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)



    # Создаем сокращенный вариант
    send_df = df.iloc[:, :threshold_base]
    # Добавляем колонки с результатами
    send_df[f'{name_test}_Необработанный_результат'] = df[f'{name_test}_Необработанный_результат']
    send_df[f'{name_test}_Обработанный_результат'] = df[f'{name_test}_Обработанный_результат']
    send_df[f'{name_test}_Числовое_значение_результата'] = df[f'{name_test}_Числовое_значение_результата']
    send_df[f'{name_test}_Описание_результата'] = df[f'{name_test}_Описание_результата']
    # создаем датафреймы для возврата в основную функцию
    out_full_df = df.iloc[:, threshold_base:]  # датафрейм с вопросами и результатами без анкетных данных
    out_result_df = send_df.iloc[:, threshold_base:]
    # Сортировка
    df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    send_df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    df.to_excel(f'{path_to_end_folder_complex}/Полная таблица с результатами {name_test} от {current_time}.xlsx', index=False,
                engine='xlsxwriter')
    send_df.to_excel(f'{path_to_end_folder_complex}/Краткая таблица с результатами {name_test}  от {current_time}.xlsx',
                     index=False, engine='xlsxwriter')
    finish_report_df.to_excel(f'{path_to_end_folder_complex}/Отчет {name_test}  от {current_time}.xlsx',
                              index=False, engine='xlsxwriter')



    return out_full_df, out_result_df


def processing_sppu(base_df: pd.DataFrame, answers_df: pd.DataFrame, size: int,name_test):
    """
    Функция для обработки результатов тестирования сферы профессиональных предпочтений учащихся
    :return:
    """
    if answers_df.shape[1] != size:
        raise WrongNumberColumn

    answers_df.columns = [f'{name_test}_Вопрос_ №_{i}' for i in range(1, answers_df.shape[1] + 1)]

    answers_df = answers_df.astype(str)

    answers_df = answers_df.applymap(lambda x: x.strip())

    answers_df[f'{name_test}_Необработанный_результат'] = answers_df.apply(processing_result_sppu, axis=1)
    answers_df[f'{name_test}_Обработанный_результат'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_key_max_value)
    answers_df[f'{name_test}_Числовое_значение_результата'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_max_value)

    # Создаем датафрейм для данных отчета
    report_df = answers_df.iloc[::, size + 1:]

    # Создаем датафрейм в который будем заносить итоговые результаты
    finish_report_df = report_df[f'{name_test}_Обработанный_результат'].value_counts().to_frame()

    # получаем процента
    finish_report_df['Доля_от_общего_количества'] = round(
        (finish_report_df[f'{name_test}_Обработанный_результат'] / report_df.shape[0]) * 100, 2)

    finish_report_df = finish_report_df.reset_index()

    finish_report_df.columns = ['Категория', 'Количество', 'Доля в % от общего количества']

    # соединяем после обработки
    df = pd.concat([base_df, answers_df], axis=1)

    # Создаем строку с описанием
    description_result = """
Шкала оценки результатов
10-12 баллов – ярко выраженная профессиональная склонность;
7-9 баллов – средне выраженная профессиональная склонность;
4-6 баллов – слабо выраженная профессиональная склонность;
0-3 баллов – профессиональная склонность не выражена.

Примеры профессий для каждой сферы
Сфера работы с людьми: учитель, педагог, экскурсовод, воспитатель,  социолог, психолог, менеджер по персоналу, следователь.
Сфера умственного труда: ученый-исследователь (математик, физик, химик, кибернетик, археолог, геолог),  инженер, юрист, врач, эколог, архитектор, продюсер.
Сфера технических интересов:  программист, электротехник, радиотехник, Web-мастер, статистик, водитель, технолог, диспетчер, секретарь-машинистка, телефонист.
Сфера эстетики и искусства: художник, дизайнер, писатель, поэт,  режиссер, артист, конструктор, косметолог, костюмер, гример, кондитер, портной-кутюрье, цветовод. 
Сфера физического труда,  подвижной деятельности: спортсмен, фотограф, экспедитор, парикмахер,  бармен, официант, стюардесса, продавец, закройщик, специалист по ремонту, кассир, медперсонал, бригадир, кладовщик,  почтальон,  фермер,  водитель-дальнобойщик, полицейский, военный.
Сфера материальных интересов,  планово-экономических видов работ: экономист, администратор, менеджер, предприниматель, аудитор, специалист по рекламе, брокер, агент страховых компаний, коммерсант, завхоз.
"""

    if 'ФИО' in df.columns:
        df[f'{name_test}_Описание_результата'] = df['ФИО'] + '.' + ' \nСфера профессиональных предпочтений учащихся.\n' + \
                                         df[f'{name_test}_Необработанный_результат'] + description_result
    else:
        df[f'{name_test}_Описание_результата'] = 'Сфера профессиональных предпочтений учащихся.\n' + df[
            f'{name_test}_Необработанный_результат'] + description_result

    # генерируем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)



    # Создаем сокращенный вариант
    send_df = df.iloc[:, :threshold_base]
    # Добавляем колонки с результатами
    send_df[f'{name_test}_Необработанный_результат'] = df[f'{name_test}_Необработанный_результат']
    send_df[f'{name_test}_Обработанный_результат'] = df[f'{name_test}_Обработанный_результат']
    send_df[f'{name_test}_Числовое_значение_результата'] = df[f'{name_test}_Числовое_значение_результата']
    send_df[f'{name_test}_Описание_результата'] = df[f'{name_test}_Описание_результата']
    # создаем датафреймы для возврата в основную функцию
    out_full_df = df.iloc[:, threshold_base:]  # датафрейм с вопросами и результатами без анкетных данных
    out_result_df = send_df.iloc[:, threshold_base:]
    # Сортируем по убыванию
    df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    send_df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)

    df.to_excel(f'{path_to_end_folder_complex}/Полная таблица с результатами {name_test} от {current_time}.xlsx', index=False,
                engine='xlsxwriter')
    send_df.to_excel(f'{path_to_end_folder_complex}/Краткая таблица с результатами {name_test}  от {current_time}.xlsx',
                     index=False, engine='xlsxwriter')

    finish_report_df.to_excel(f'{path_to_end_folder_complex}/Отчет {name_test}  от {current_time}.xlsx',
                              index=False, engine='xlsxwriter')
    return out_full_df, out_result_df


def processing_ddo(base_df: pd.DataFrame, answers_df: pd.DataFrame, size: int,name_test):
    """
    Фугкция для обработки данных ДДО
    :return:
    """
    # Создаем словари для создания текста письма
    global dct_prof
    dct_prof = {
        'Человек-природа': 'Тракторист, рыбовод, зоотехник, агроном, садовник, ветеринар, животновод, геолог, биолог, почвовед и т.д.',
        'Человек-техника': 'Водитель, токарь, инженер, слесарь, радиотехник, швея, электрик, механик, монтажник и т.п.',
        'Человек-человек': 'Продавец, медсестра, секретарь, бортпроводник, учитель, воспитатель, няня, преподаватель, врач, официант, администратор и т.п.',
        'Человек-знаковые системы': 'Наборщик, кассир, делопроизводитель, бухгалтер, программист, чертежник, корректор, экономист, радист, оператор ПЭВМ, машинистка, наборщик и т.п.',
        'Человек-художественный образ': 'Парикмахер, модельер, чеканщик, маляр, гравер, резчик по камню, фотограф, актер, художник, музыкант и т.п.'}

    global dct_desciprion
    dct_desciprion = \
        {'Человек-природа': """Человек-природа.\n
Представителей этих профессий объединяет одно очень важное качество — любовь к 
природе. Но любовь не созерцательная. Которой обладают практически все люди, 
считая природу наиболее благоприятной средой для отдыха, а деятельная связанная с
познанием ее законов и применением их. Одно дело — любить животных и растения,
играть с ними, радоваться им. И совсем другое — регулярно, день за днем ухаживать
за ними, наблюдать, лечить, выгуливать, не считаясь с личным временем и планами.
Специалист должен не просто все знать о живых организмах, но и прогнозировать
возможные изменения в них и принимать меры. От человека требуется инициатива и
самостоятельность в решении конкретных задач, заботливость, терпение и
дальновидность.\n 
Человек, работающий в сфере «человек-природа», должен быть спокойным и уравновешенным.""",
         'Человек-техника': """Человек-техника.\n
Особенность технических объектов в том, что они, как правило, могут быть точно
измерены по многим признакам. При их обработке, преобразовании, перемещении
или оценке от работника требуется точность, определенность действий. Техника как
предмет труда представляет широкие возможности для новаторства, выдумки,
творчества, поэтому важное значение приобретает такое качество, как практическое
мышление. Техническая фантазия, способность мысленно соединять и разъединять
технические объекты и их части — важные условия для успеха в данной области.
""", 'Человек-человек': """Человек-человек.\n
Главное содержание труда в профессиях типа «человек-человек» сводится к
взаимодействию между людьми. Если не наладится это взаимодействие, значит, не
наладится и работа. Качества, необходимые для работы с людьми: устойчивое,
хорошее настроение в процессе работы с людьми, потребность в общении,
способность мысленно ставить себя на место другого человека, быстро понимать
намерения, помыслы, настроение людей, умение разбираться в человеческих
взаимоотношениях, хорошая память (умение держать в уме имена и особенности
многих людей), терпение.
""", 'Человек-знаковые системы': """Человек-знаковая система.\n
Мы встречаемся со знаками значительно чаще, чем обычно представляем себе. Это 
цифры. Коды, условные знаки, естественные или искусственные языки, чертежи,
таблицы формулы. В любом случае человек воспринимает знак как символ реального
объекта или явления. Поэтому специалисту, который работает со знаками, важно
уметь, с одной стороны, абстрагироваться от реальных физических, химически,
механических свойств предметов, а с другой —представлять и воспринимать
характеристики реальных явлений или объектов, стоящих за знаками. Чтобы успешно
работать в какой-нибудь профессии данного типа, необходимо уметь мысленно
погружаться в мир, казалось бы, сухих обозначений и сосредотачиваться на
сведениях, которые они несут в себе. Особые требования профессии этого типа
предъявляют к вниманию.
""", 'Человек-художественный образ': """Человек-художественный образ.\n
Важнейшие требования, которые предъявляют профессии, связанные с изобразительной, музыкальной, литературно-художественной, актерско-сценической деятельностью человека—
Наличие способности к искусствам, творческое воображение, образное мышление, талант, трудолюбие.
"""}

    if answers_df.shape[1] != size:
        raise WrongNumberColumn

    answers_df.columns = [f'{name_test}_Вопрос_ №_{i}' for i in range(1, answers_df.shape[1] + 1)]

    answers_df = answers_df.astype(str)

    answers_df = answers_df.applymap(lambda x: x.strip())
    # получаем результаты
    answers_df[f'{name_test}_Необработанный_результат'] = answers_df.apply(processing_result_ddo, axis=1)
    # обрабатываем результаты и получаем ключ с максимальным значением
    answers_df[f'{name_test}_Обработанный_результат'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_key_max_value)
    answers_df[f'{name_test}_Числовое_значение_результата'] = answers_df[f'{name_test}_Необработанный_результат'].apply(extract_max_value)
    answers_df[f'{name_test}_Описание_результата'] = answers_df[f'{name_test}_Обработанный_результат'].apply(create_out_str_ddo)

    # Создаем датафрейм для данных отчета
    report_df = answers_df.iloc[::, size + 1:]

    # Создаем датафрейм в который будем заносить итоговые результаты
    finish_report_df = report_df[f'{name_test}_Обработанный_результат'].value_counts().to_frame()

    # получаем процента
    finish_report_df['Доля_от_общего_количества'] = round(
        (finish_report_df[f'{name_test}_Обработанный_результат'] / report_df.shape[0]) * 100, 2)

    finish_report_df = finish_report_df.reset_index()

    finish_report_df.columns = ['Категория', 'Количество', 'Доля в % от общего количества']

    # соединяем после обработки
    df = pd.concat([base_df, answers_df], axis=1)

    # Проверяем наличие колонки ФИО, если она есть то добавляем ее значение, если нет не используем

    if 'ФИО' in df.columns:
        df[f'{name_test}_Описание_результата'] = df['ФИО'] + '.' + ' \nДифференциально-диагностический опросник.\n' + df[
            f'{name_test}_Описание_результата']
    else:
        df[f'{name_test}_Описание_результата'] = 'Дифференциально-диагностический опросник.\n' + df[
            f'{name_test}_Описание_результата']
    # генерируем текущее время
    t = time.localtime()
    current_time = time.strftime('%H_%M_%S', t)



    # Создаем сокращенный вариант
    send_df = df.iloc[:, :threshold_base]
    # Добавляем колонки с результатами
    send_df[f'{name_test}_Необработанный_результат'] = df[f'{name_test}_Необработанный_результат']
    send_df[f'{name_test}_Обработанный_результат'] = df[f'{name_test}_Обработанный_результат']
    send_df[f'{name_test}_Числовое_значение_результата'] = df[f'{name_test}_Числовое_значение_результата']
    send_df[f'{name_test}_Описание_результата'] = df[f'{name_test}_Описание_результата']
    # создаем датафреймы для возврата в основную функцию, до сортировки
    out_full_df = df.iloc[:, threshold_base:]  # датафрейм с вопросами и результатами без анкетных данных
    out_result_df = send_df.iloc[:, threshold_base:]

    df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    send_df.sort_values(by=f'{name_test}_Числовое_значение_результата', ascending=False, inplace=True)
    df.to_excel(f'{path_to_end_folder_complex}/Полная таблица с результатами {name_test} от {current_time}.xlsx', index=False,
                engine='xlsxwriter')
    send_df.to_excel(f'{path_to_end_folder_complex}/Краткая таблица с результатами {name_test}  от {current_time}.xlsx',
                     index=False, engine='xlsxwriter')
    finish_report_df.to_excel(f'{path_to_end_folder_complex}/Отчет {name_test}  от {current_time}.xlsx',
                              index=False, engine='xlsxwriter')

    return out_full_df, out_result_df




def select_end_folder_complex():
    """
    Функция для выбора конечной папки куда будут складываться итоговые файлы
    :return:
    """
    global path_to_end_folder_complex
    path_to_end_folder_complex = filedialog.askdirectory()


def select_file_data_xlsx_complex():
    """
    Функция для выбора файла с данными на основе которых будет генерироваться документ
    :return: Путь к файлу с данными
    """
    global file_data_xlsx_complex
    # Получаем путь к файлу
    file_data_xlsx_complex = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_file_params_complex():
    """
    Функция для выбора файла с данными на основе которых будет генерироваться документ
    :return: Путь к файлу с данными
    """
    global file_params_complex
    # Получаем путь к файлу
    file_params_complex = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def processing_complex():
    """
    Функция для обработки произвольных тестов в произвольном порядке
    """
    try:
        # потом в ооп когда нибудь перепишу
        # создаем словарь с параметрами скриптов формата {аббревиатура:(название функции для обработки, количество вопросов(колонок))}
        global DCT_PARAMS_SCRIPT
        DCT_PARAMS_SCRIPT = {'ДЦОК': (processing_dcok, 41), 'ОПТЛ': (processing_optl, 30),
                             'СППУ': (processing_sppu, 24), 'ДДО': (processing_ddo, 20)}

        global threshold_base
        threshold_base = var_entry_threshold_complex.get()
        # создаем счетчик обработанных колонок
        threshold_finshed = threshold_base

        # получаем базовый датафрейм
        df = pd.read_excel(file_data_xlsx_complex)

        base_df = df.iloc[:, :threshold_base]  # создаем датафрейм с данными не относящимися к тесту
        # делаем строковыми названия колонок
        base_df.columns = list(map(str, base_df.columns))

        # заменяем пробелы на нижнее подчеркивание и очищаем от пробельных символов в начале и конце
        base_df.columns = [column.strip().replace(' ', '_') for column in base_df.columns]

        # очищаем от всех символов кроме букв цифр
        base_df.columns = [re.sub(r'[^_\d\w]', '', column) for column in base_df.columns]

        params_df = pd.read_excel(file_params_complex, header=None)  # считываем файл с параметрами
        lst_tests = params_df[0].tolist()
        # Создаем копию датафрейма с анкетными данными для передачи в функцию
        base_df_for_func = base_df.copy()
        # создаем копию для датафрейма с результатами
        result_df = base_df.copy()

        # Перебираем полученные названия тестов
        for name_test in lst_tests:
            """
            запускаем функцию хранящуюся в словаре
            передаем туда датафрейм с анкетными данными, датафрейм с данными теста, количество колонок которое занимает данный тест
            получаем 2 датафрейма с результатами для данного теста которые добавляем в основные датафреймы
            """
            # получаем колонки относящиеся к тесту
            temp_df = df.iloc[:, threshold_finshed:threshold_finshed + DCT_PARAMS_SCRIPT[name_test][1]]
            # обрабатываем и получаем датафреймы для добавления в основные таблицы
            temp_full_df, temp_result_df = DCT_PARAMS_SCRIPT[name_test][0](base_df_for_func, temp_df,
                                                                           DCT_PARAMS_SCRIPT[name_test][1],name_test)
            base_df = pd.concat([base_df, temp_full_df],
                                axis=1)  # соединяем анкетные данные и вопросы вместе с результатами
            result_df = pd.concat([result_df, temp_result_df], axis=1)
            # увеличиваем предел обозначающий количество обработанных колонок
            threshold_finshed += DCT_PARAMS_SCRIPT[name_test][1]

        # генерируем текущее время
        t = time.localtime()
        current_time = time.strftime('%H_%M_%S', t)
        # Сохраняем результаты
        base_df.to_excel(
            f'{path_to_end_folder_complex}/Полная таблица с результатами комплексного теста от {current_time}.xlsx',
            index=False,
            engine='xlsxwriter')

        result_df.to_excel(
            f'{path_to_end_folder_complex}/Краткая таблица с результатами комплексного теста от {current_time}.xlsx',
            index=False,
            engine='xlsxwriter')


    except NameError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.2',
                             f'Выберите файлы с данными и папку куда будет генерироваться файл')
    except KeyError as e:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.2',
                             f'Название теста не найдено, проверьте правильность написания названия в таблице параметров {e.args}\n'
                             f'Проверьте правильность написания по руководству пользователя')
    except FileNotFoundError:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.2',
                             f'Перенесите файлы которые вы хотите обработать в корень диска. Проблема может быть\n '
                             f'в слишком длинном пути к обрабатываемым файлам')
    except WrongNumberColumn:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.2',
                             f'Неправильное количество колонок в таблице!\n'
                             f'Проверьте количество вопросов в тестах!\n'
                             f'ДЦОК -41 колонка т.е.41 тестовый вопрос\n'
                             f'ОПТЛ - 30 колонок т.е. 30 тестовых вопросов\n'
                             f'СППУ - 24 колонки т.е. 24 тестовых вопроса\n'
                             f'ДДО - 20 колонок т.е. 20 тестовых вопросов')
    else:
        messagebox.showinfo('Лахеcис Обработка результатов профориентационных тестов ver 5.2',
                            'Данные успешно обработаны')


def select_file_template_doc():
    """
    Функция для выбора файла шаблона
    :return: Путь к файлу шаблона
    """
    global name_file_template_doc
    name_file_template_doc = filedialog.askopenfilename(
        filetypes=(('Word files', '*.docx'), ('all files', '*.*')))


def select_file_data_doc():
    """
    Функция для выбора файла с данными на основе которых будет генерироваться документ
    :return: Путь к файлу с данными
    """
    global name_file_data_doc
    # Получаем путь к файлу
    name_file_data_doc = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_end_folder_doc():
    """
    Функция для выбора папки куда будут генерироваться файлы
    :return:
    """
    global path_to_end_folder_doc
    path_to_end_folder_doc = filedialog.askdirectory()


def create_doc_convert_date(cell):
    """
    Функция для конвертации даты при создании документов
    :param cell:
    :return:
    """
    try:
        string_date = datetime.datetime.strftime(cell, '%d.%m.%Y')
        return string_date
    except ValueError:
        return 'Не удалось конвертировать дату.Проверьте значение ячейки!!!'
    except TypeError:
        return 'Не удалось конвертировать дату.Проверьте значение ячейки!!!'



def processing_generate_docs():
    """
    Функция для создания документов из произвольных таблиц(т.е. отличающихся от структуры базы данных Веста Обработка таблиц и создание документов ver 1.29)
    :return:
    """
    try:
        folder_structure = entry_folder_structure.get() # получаем по каким колонкам будет формироваться структура папок
        name_file = entry_name_file.get() # получаем по каким колонкам будет формироваться название файла
        name_type_file = entry_type_file.get() # получаем тип документа который будет создаваться

        # получаем состояние переключателя режима
        mode_full = mode_full_type.get()
        # получаем состояние чекбокса создания pdf
        mode_pdf = mode_pdf_value.get() # чекбокс нужно ли создавать пдф версии

        generate_result_docs(name_file_data_doc,name_file_template_doc,path_to_end_folder_doc,folder_structure,
                             name_file,name_type_file,mode_pdf,mode_full)

    except NameError as e:
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов',
                             f'Выберите шаблон,файл с данными и папку куда будут генерироваться файлы')

def select_file_params_comparsion():
    """
    Функция для выбора файла с параметрами колонок т.е. кокие колонки нужно обрабатывать
    :return:
    """
    global file_params
    file_params = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_first_comparison():
    """
    Функция для выбора  первого файла с данными которые нужно сравнить
    :return: Путь к файлу с данными
    """
    global name_first_file_comparison
    # Получаем путь к файлу
    name_first_file_comparison = filedialog.askopenfilename(filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_second_comparison():
    """
    Функция для выбора  второго файла с данными которые нужно сравнить
    :return: Путь к файлу с данными
    """
    global name_second_file_comparison
    # Получаем путь к файлу
    name_second_file_comparison = filedialog.askopenfilename(
        filetypes=(('Excel files', '*.xlsx'), ('all files', '*.*')))


def select_end_folder_comparison():
    """
    Функция для выбора папки куда будет генерироваться итоговый файл
    :return:
    """
    global path_to_end_folder_comparison
    path_to_end_folder_comparison = filedialog.askdirectory()

def convert_columns_to_str(df, number_columns):
    """
    Функция для конвертации указанных столбцов в строковый тип и очистки от пробельных символов в начале и конце
    """

    for column in number_columns:  # Перебираем список нужных колонок
        try:
            df.iloc[:, column] = df.iloc[:, column].astype(str)
            # Очищаем колонку от пробельных символов с начала и конца
            df.iloc[:, column] = df.iloc[:, column].apply(lambda x: x.strip())
        except IndexError:
            messagebox.showerror('Веста Обработка таблиц и создание документов ver 1.29',
                                 'Проверьте порядковые номера колонок которые вы хотите обработать.')


def convert_params_columns_to_int(lst):
    """
    Функция для конвератации значений колонок которые нужно обработать.
    Очищает от пустых строк, чтобы в итоге остался список из чисел в формате int
    """
    out_lst = [] # Создаем список в который будем добавлять только числа
    for value in lst: # Перебираем список
        try:
            # Обрабатываем случай с нулем, для того чтобы после приведения к питоновскому отсчету от нуля не получилась колонка с номером -1
            number = int(value)
            if number != 0:
                out_lst.append(value) # Если конвертирования прошло без ошибок то добавляем
            else:
                continue
        except: # Иначе пропускаем
            continue
    return out_lst


def clean_ending_columns(lst_columns:list,name_first_df,name_second_df):
    """
    Функция для очистки колонок таблицы с совпадающими данными от окончаний _x _y

    :param lst_columns:
    :param time_generate
    :param name_first_df
    :param name_second_df
    :return:
    """
    out_columns = [] # список для очищенных названий
    for name_column in lst_columns:
        if '_x' in name_column:
            # если они есть то проводим очистку и добавление времени
            cut_name_column = name_column[:-2] # обрезаем
            temp_name = f'{cut_name_column}_{name_first_df}' # соединяем
            out_columns.append(temp_name) # добавляем
        elif '_y' in name_column:
            cut_name_column = name_column[:-2]  # обрезаем
            temp_name = f'{cut_name_column}_{name_second_df}'  # соединяем
            out_columns.append(temp_name)  # добавляем
        else:
            out_columns.append(name_column)
    return out_columns



def convert_date(cell):
    """
    Функция для конвертации даты в формате 1957-05-10 в формат 10.05.1957(строковый)
    """

    try:
        string_date = datetime.datetime.strftime(cell, '%d.%m.%Y')
        return string_date

    except TypeError:
        print(cell)
        messagebox.showerror('Лахеcис Обработка результатов профориентационных тестов ver 5.2',
                             'Проверьте правильность заполнения ячеек с датой!!!')
        logging.exception('AN ERROR HAS OCCURRED')
        quit()


def check_date_columns(i, value):
    """
    Функция для проверки типа колонки. Необходимо найти колонки с датой
    :param i:
    :param value:
    :return:
    """
    try:
        itog = pd.to_datetime(str(value), infer_datetime_format=True)
    except:
        pass
    else:
        return i


def set_rus_locale():
    """
    Функция чтобы можно было извлечь русские названия месяцев
    """
    locale.setlocale(
        locale.LC_ALL,
        'rus_rus' if sys.platform == 'win32' else 'ru_RU.UTF-8')

def processing_date_column(df, lst_columns):
    """
    Функция для обработки столбцов с датами. конвертация в строку формата ДД.ММ.ГГГГ
    """
    # получаем первую строку
    first_row = df.iloc[0, lst_columns]

    lst_first_row = list(first_row)  # Превращаем строку в список
    lst_date_columns = []  # Создаем список куда будем сохранять колонки в которых находятся даты
    tupl_row = list(zip(lst_columns,
                        lst_first_row))  # Создаем список кортежей формата (номер колонки,значение строки в этой колонке)

    for idx, value in tupl_row:  # Перебираем кортеж
        result = check_date_columns(idx, value)  # проверяем является ли значение датой
        if result:  # если да то добавляем список порядковый номер колонки
            lst_date_columns.append(result)
        else:  # иначе проверяем следующее значение
            continue
    for i in lst_date_columns:  # Перебираем список с колонками дат, превращаем их в даты и конвертируем в нужный строковый формат
        df.iloc[:, i] = pd.to_datetime(df.iloc[:, i], errors='coerce', dayfirst=True)
        df.iloc[:, i] = df.iloc[:, i].apply(create_doc_convert_date)


def extract_number_month(cell):
    """
    Функция для извлечения номера месяца
    """
    return cell.month


def extract_name_month(cell):
    """
    Функция для извлечения названия месяца
    Взято отсюда https://ru.stackoverflow.com/questions/1045154/Вывод-русских-символов-из-pd-timestamp-month-name
    """
    return cell.month_name(locale='Russian')


def extract_year(cell):
    """
    Функция для извлечения года рождения
    """
    return cell.year



def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller
    Функция чтобы логотип отображался"""
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

"""
Функции для создания контекстного меню(Копировать,вставить,вырезать)
"""


def make_textmenu(root):
    """
    Функции для контекстного меню( вырезать,копировать,вставить)
    взято отсюда https://gist.github.com/angeloped/91fb1bb00f1d9e0cd7a55307a801995f
    """
    # эта штука делает меню
    global the_menu
    the_menu = Menu(root, tearoff=0)
    the_menu.add_command(label="Вырезать")
    the_menu.add_command(label="Копировать")
    the_menu.add_command(label="Вставить")
    the_menu.add_separator()
    the_menu.add_command(label="Выбрать все")


def callback_select_all(event):
    """
    Функции для контекстного меню( вырезать,копировать,вставить)
    взято отсюда https://gist.github.com/angeloped/91fb1bb00f1d9e0cd7a55307a801995f
    """
    # select text after 50ms
    window.after(50, lambda: event.widget.select_range(0, 'end'))


def show_textmenu(event):
    """
    Функции для контекстного меню( вырезать,копировать,вставить)
    взято отсюда https://gist.github.com/angeloped/91fb1bb00f1d9e0cd7a55307a801995f
    """
    e_widget = event.widget
    the_menu.entryconfigure("Вырезать", command=lambda: e_widget.event_generate("<<Cut>>"))
    the_menu.entryconfigure("Копировать", command=lambda: e_widget.event_generate("<<Copy>>"))
    the_menu.entryconfigure("Вставить", command=lambda: e_widget.event_generate("<<Paste>>"))
    the_menu.entryconfigure("Выбрать все", command=lambda: e_widget.select_range(0, 'end'))
    the_menu.tk.call("tk_popup", the_menu, event.x_root, event.y_root)


def on_scroll(*args):
    canvas.yview(*args)

def set_window_size(window):
    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()

    # Устанавливаем размер окна в 80% от ширины и высоты экрана
    if screen_width >= 3840:
        width = int(screen_width * 0.2)
    elif screen_width >= 2560:
        width = int(screen_width * 0.31)
    elif screen_width >= 1920:
        width = int(screen_width * 0.41)
    elif screen_width >= 1600:
        width = int(screen_width * 0.5)
    elif screen_width >= 1280:
        width = int(screen_width * 0.62)
    elif screen_width >= 1024:
        width = int(screen_width * 0.77)
    else:
        width = int(screen_width * 1)

    height = int(screen_height * 0.8)

    # Рассчитываем координаты для центрирования окна
    x = (screen_width - width) // 2
    y = (screen_height - height) // 2

    # Устанавливаем размер и положение окна
    window.geometry(f"{width}x{height}+{x}+{y}")






if __name__ == '__main__':
    window = Tk()
    window.title('Лахеcис Обработка результатов профориентационных тестов ver 6.0')

    # Устанавливаем размер и положение окна
    set_window_size(window)

    window.resizable(True, True)
    # Добавляем контекстное меню в поля ввода
    make_textmenu(window)

    # Создаем вертикальный скроллбар
    scrollbar = Scrollbar(window, orient="vertical")

    # Создаем холст
    canvas = Canvas(window, yscrollcommand=scrollbar.set)
    canvas.pack(side="left", fill="both", expand=True)

    # Привязываем скроллбар к холсту
    scrollbar.config(command=canvas.yview)

    # Создаем ноутбук (вкладки)
    tab_control = ttk.Notebook(canvas)
    """
    Обработка комплексных результатов
    """
    # Создаем вкладку обработки данных complex
    tab_report_complex = ttk.Frame(tab_control)
    tab_control.add(tab_report_complex, text='Обработка результатов')
    tab_control.pack(expand=1, fill='both')
    # Добавляем виджеты на вкладку
    # Создаем метку для описания назначения программы
    lbl_hello_complex = Label(tab_report_complex,
                              text='Центр опережающей профессиональной подготовки Республики Бурятия\nКомплексный тест \n'
                                   'Все колонки таблицы не относящиеся к тестовым вопросам\n должны быть в начале и в конце таблицы.'
                                   )
    lbl_hello_complex.grid(column=0, row=0, padx=10, pady=25)

    # Картинка
    path_to_img_complex = resource_path('logo.png')

    img_complex = PhotoImage(file=path_to_img_complex)
    Label(tab_report_complex,
          image=img_complex
          ).grid(column=1, row=0, padx=10, pady=25)

    # Создаем кнопку Выбрать файл с параметрами
    btn_choose_data_complex = Button(tab_report_complex, text='1) Выберите файл с параметрами',
                                     font=('Arial Bold', 14),
                                     command=select_file_params_complex
                                     )
    btn_choose_data_complex.grid(column=0, row=2, padx=10, pady=10)

    # Создаем кнопку Выбрать файл с данными
    btn_choose_data_complex = Button(tab_report_complex, text='2) Выберите файл с результатами',
                                     font=('Arial Bold', 14),
                                     command=select_file_data_xlsx_complex
                                     )
    btn_choose_data_complex.grid(column=0, row=3, padx=10, pady=10)

    # Создаем кнопку для выбора папки куда будут генерироваться файлы

    btn_choose_end_folder_complex = Button(tab_report_complex, text='3) Выберите конечную папку',
                                           font=('Arial Bold', 14),
                                           command=select_end_folder_complex
                                           )
    btn_choose_end_folder_complex.grid(column=0, row=4, padx=10, pady=10)

    # Создаем поле для ввода количества колонок без вопросов(анкетные данные)
    # Определяем переменную
    var_entry_threshold_complex = IntVar()
    # Описание поля
    label_name_threshold_complex = Label(tab_report_complex,
                                         text='4) Введите количество колонок в начале таблицы\n не относящихся к вопросам теста')
    label_name_threshold_complex.grid(column=0, row=5, padx=10, pady=5)
    # поле ввода
    entry_threshold_complex = Entry(tab_report_complex, textvariable=var_entry_threshold_complex, width=30)
    entry_threshold_complex.grid(column=0, row=6, padx=5, pady=5, ipadx=30, ipady=4)

    # Создаем кнопку обработки данных

    btn_proccessing_data_complex = Button(tab_report_complex, text='5) Обработать данные', font=('Arial Bold', 14),
                                          command=processing_complex
                                          )
    btn_proccessing_data_complex.grid(column=0, row=7, padx=10, pady=10)
    """
    Создание отчетов
    """

    tab_create_doc = ttk.Frame(tab_control)
    tab_control.add(tab_create_doc, text='Генерация результатов тестирования')
    tab_control.pack(expand=1, fill='both')

    # Добавляем виджеты на вкладку Создание документов
    # Создаем метку для описания назначения программы
    lbl_hello = Label(tab_create_doc,
                      text='Центр опережающей профессиональной подготовки Республики Бурятия\nГенерация результатов тестирования'
                           '')
    lbl_hello.grid(column=0, row=0, padx=10, pady=25)

    # Картинка
    path_to_img = resource_path('logo.png')
    img = PhotoImage(file=path_to_img)
    Label(tab_create_doc,
          image=img
          ).grid(column=1, row=0, padx=10, pady=25)

    # Создаем область для того чтобы поместить туда подготовительные кнопки(выбрать файл,выбрать папку и т.п.)
    frame_data_for_doc = LabelFrame(tab_create_doc, text='Подготовка')
    frame_data_for_doc.grid(column=0, row=2, padx=10)

    # Создаем кнопку Выбрать шаблон
    btn_template_doc = Button(frame_data_for_doc, text='1) Выберите шаблон документа', font=('Arial Bold', 14),
                              command=select_file_template_doc
                              )
    btn_template_doc.grid(column=0, row=3, padx=10, pady=10)
    #
    # Создаем кнопку Выбрать файл с данными
    btn_data_doc = Button(frame_data_for_doc, text='2) Выберите файл с данными', font=('Arial Bold', 14),
                          command=select_file_data_doc
                          )
    btn_data_doc.grid(column=0, row=4, padx=10, pady=10)
    #
    # Создаем кнопку для выбора папки куда будут генерироваться файлы

    # Определяем текстовую переменную
    entry_folder_structure = StringVar()
    # Описание поля
    label_folder_structure = Label(frame_data_for_doc,
                                   text='3) Введите через запятую порядковые номера колонок таблице\n по которым будет создаваться структура папок.\n'
                                        'Например 3,4,5 или 2,3. Может быть указано не более 4 колонок')
    label_folder_structure.grid(column=0, row=5, padx=10, pady=5)
    # поле ввода
    entry_folder_structure = Entry(frame_data_for_doc, textvariable=entry_folder_structure, width=30)
    entry_folder_structure.grid(column=0, row=6, padx=5, pady=5, ipadx=30, ipady=4)

    # Поле для ввода названия генериуемых документов
    # Определяем текстовую переменную
    entry_name_file = StringVar()
    # Описание поля
    label_name_file = Label(frame_data_for_doc,
                                   text='4) Введите через запятую порядковые номера колонок в таблице\n по которым файлы будут называться.\n'
                                        'Например 6,7 или 3,4. Может быть указано не более 2 колонок')
    label_name_file.grid(column=0, row=7, padx=10, pady=5)
    # поле ввода
    entry_name_file = Entry(frame_data_for_doc, textvariable=entry_name_file, width=30)
    entry_name_file.grid(column=0, row=8, padx=5, pady=5, ipadx=30, ipady=4)


    entry_type_file = StringVar()
    # Описание поля
    label_name_column_type_file = Label(frame_data_for_doc, text='5) Введите что вы создаете.\n Например Результат тестирования или просто Результат')
    label_name_column_type_file.grid(column=0, row=9, padx=10, pady=5)
    # поле ввода
    type_file_column_entry = Entry(frame_data_for_doc, textvariable=entry_type_file, width=30)
    type_file_column_entry.grid(column=0, row=10, padx=5, pady=5, ipadx=30, ipady=4)

    btn_choose_end_folder_doc = Button(frame_data_for_doc, text='6) Выберите конечную папку', font=('Arial Bold', 14),
                                       command=select_end_folder_doc
                                       )
    btn_choose_end_folder_doc.grid(column=0, row=11, padx=10, pady=10)

    # Создаем переключатель для вариантов короткого или полного
    mode_full_type = StringVar()
    mode_full_type.set('No')
    # Создаем чекбокс для выбора режима создания документов
    chbox_full_type = Checkbutton(frame_data_for_doc,
                                 text='Поставьте галочку, если вам нужно  \n'
                                      'включить краткий режим при нем будут создаваться только pdf.\n'
                                      'В полном режиме создаются docx, объединенный файл, файл с архивом ',
                                 variable=mode_full_type,
                                 offvalue='No',
                                 onvalue='Yes')
    chbox_full_type.grid(column=0, row=12, padx=1, pady=1)


    # Создаем чекбокс для режима создания pdf
    # Создаем переменную для хранения результа переключения чекбокса
    mode_pdf_value = StringVar()

    # Устанавливаем значение по умолчанию для этой переменной. По умолчанию PDF варианты создаваться не будут
    mode_pdf_value.set('No')

    # Создаем чекбокс для выбора режима подсчета

    chbox_mode_pdf = Checkbutton(frame_data_for_doc,
                                 text='Поставьте галочку, если вам нужно чтобы \n'
                                      'в полном режиме дополнительно создавались pdf версии документов',
                                 variable=mode_pdf_value,
                                 offvalue='No',
                                 onvalue='Yes')
    chbox_mode_pdf.grid(column=0, row=13, padx=1, pady=1)


    # Создаем кнопку для создания документов из таблиц с произвольной структурой
    btn_create_files_other = Button(tab_create_doc, text='7) Получить результаты',
                                    font=('Arial Bold', 14),
                                    command=processing_generate_docs
                                    )
    btn_create_files_other.grid(column=0, row=14, padx=10, pady=10)



    # Создаем виджет для управления полосой прокрутки
    canvas.create_window((0, 0), window=tab_control, anchor="nw")

    # Конфигурируем холст для обработки скроллинга
    canvas.config(yscrollcommand=scrollbar.set, scrollregion=canvas.bbox("all"))
    scrollbar.pack(side="right", fill="y")

    # Вешаем событие скроллинга
    canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

    window.bind_class("Entry", "<Button-3><ButtonRelease-3>", show_textmenu)
    window.bind_class("Entry", "<Control-a>", callback_select_all)
    window.mainloop()
